---
title: "파일시스템과 파일입출력"

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

## 파일 시스템

### 스크립트를 실행할 때의 파일 정보

Julia 스크립트가 실행 될 때 몇가지 파일과 경로에 대한 정보를 가지고 실행됩니다. 예를 들어 다음의 julia 스크립트 파일로 저장하고 실행시켜봅시다

```julia
#! /usr/bin/env julia

println(homedir())
println(pwd())
println(@__DIR__)
println(@__FILE__)
```

Julia 스크립트는 보통 확장자로 `jl` 을 사용합니다. 위의 코드를 `pathes.jl` 로 저장해 봅시다. 맨 앞줄의 `#! /usr/bin/env julia` 는 Shebang 이라고 하며 일반적으로 셸스크립트나 파이썬스크립트와 같은 스크립트의 실행 정보를 담고 있습니다. Linux 나 맥 OSX 같은 유닉스 계열의 OS 라면 터미널에서 

```sh
julia pathes.jl
```

명령어로서 실행합니다. 실행이 제대로 된다면 4줄을 출력할 것입니다.

- `homedir()` 은 사용자의 홈 디렉토리의 경로를 문자열로 반환하는 함수입니다.

- `pwd()` 는 스크립트가 어떤 작업을 할 때의 기준 디렉토리 즉 작업디렉토리를 문자열로 반환하는 함수입니다.

- `@__DIR__` 은 매크로로 이 매크로를 호출한 파일의 디렉토리를 반환합니다. 
 
- `@__FILE__` 역시 매크로로 이 매크로를 호출한 파일의 파일명을 포함하는 전체 경로를 반환합니다.


</br>

### Julia 에서 파일과 디렉토리 다루기

여기서는 함수 이름만 나열합니다. 자세한 사용법은 Julia 의 도움말을 확인하기 바랍니다.



| 기능 | 함수 |
|:---------|:------|
| home directory | `homedir()` | 
| working directory 확인 | `pwd()`| 
| working directory 변경 | `cd()`|
| working directory를 home directory로 변경 | `cd()` | 
| directory내 파일 및 폴더 리스트 확인 |`readdir()`|
| directory 만들기 |`mkpath()`|
| 파일/폴더 이동 | `mv()`| 
| 파일/폴더 삭제 | `rm()`|
| 폴더인지 확인 | `isdir()` |
| 파일인지 확인 | `isfile()`|
| 유효한 경로인지 확인 | `ispath()` |
| 절대경로 확인 | `abspath()`|
| 절대경로인지 확인 | `isabspath()`|
| 경로 합성 | `joinpath()`|
| 디렉토리 이름과 파일 이름으로 분할  | `splitdir()` |
| 경로를 세부 단위로 분할 | `splitpath()`|
| 파일크기 확인 | `filesize()` |
| 파일의 세부 정보 얻기 | `stat()` |
: 파일 입출력 함수 {#tbl-julia_file_functions}

</br>

## 저수준 파일 입출력

### 파일 열고 닫기

일반적인 프로그래밍 언어에서 기본적으로 파일을 다루는 것은 파일을 열고(open), 읽거나(read) 쓰고(write), 닫는(close) 절차로 이루어집니다. 파일을 연다는 것은 특정 파일을 지정하여 그 파일에 접근할 수 있는 통로의 문을 여는 것으로 이해 할 수 있습니다. 워드나 편집기 프로그램과 다른것은 파일을 연다는 것이 여기서는 파일의 내용을 읽는것이 아니라는 것입니다. 파일을 닫는것은 이제 그 파일에 접근할 필요가 없으므로 그 통로를 닫는다는 것으로 이해 할 수 있습니다. 파일을 지우거나 고치거나 하지 않습니다.

Julia 에서 파일을 열고 닫는 방법은 보통 두가지가 많이 쓰입니다. 하나는 `open()` 함수로 명시적으로 열고 `close()` 함수로 명시적으로 닫는 것입니다. 예를 들어 앞의 `pathes.jl` 파일의 절대경로가 `/Users/juliano/pathes.jl` 라고 하면 다음과 같이 합니다. 현재 디렉토리(`pwd()` 명령어로 확인할 수 있습니다) 에 대한 상대경로를 사용할 수도 있습니다. 

```julia
f = open("/Users/juliano/pathes.jl")
    # f 를 이용하여 일을 한다.
close(f)
```

나머지 하나는 `do` 블럭을 이용하는 것입니다. 이 방법은 `close()` 함수를 명시적으로 호출할 필요가 없습니다.

```julia
open("/Users/juliano/pathes.jl") do f
    # f 를 이용하여 일을 한다.
end
```

</br>

### 파일 접근 모드

파일을 열 때는 몇가지 모드가 있으며 `open` 함수의 두번째 인자로 전달되거나 키워드 인자로 전달됩니다. 어떤 모드도 지정되지 않았다면 `"r"` 모드입니다. 아래의 표는 가능한 모드들입니다. 아래의 표에서 [truncate] 는 기존의 파일이 있다면 그 파일의 내용을 지우고 빈 파일로 만든다는 의미입니다. 따라서 파일이 지워져서는 안되는 파일이라면 미리 확인해야 합니다.(`ispath()`, 나 `isfile()` 함수로 확인 할 수 있습니다.) [새로 만들기] 는 지정된 경로에 파일이 없다면 파일을 새로 만든다는 뜻입니다. [새로 만들기] 모드가 없고 지정된 경로에 파일이 없다면 에러가 발생합니다. [덧붙이기] 는 기존의 파일을 유지하면서 기존 파일의 끝부터 내용을 쓴다는 의미입니다.

| 모드 | 키워드 인자 | 설명 | 
|:--:| :----------:| :--------- |
| `"r"`	 |  | 읽기 |	
| `"w"` |	`write = true` | 쓰기, 새로 만들기, 제거하기 |	
| `"a"` |	`append = true` | 쓰기, 새로 만들기, 덧붙이기 |
| `"r+"` | `read = true`, `write = true` | 읽기, 쓰기  |
| `"w+"` | `truncate = true`, `read = true` | 읽기, 쓰기, 새로 만들기, 제거하기 | 
| `"a+"`	| `append = true`, `read = true` | 읽기, 쓰기, 새로 만들기, 덧붙이기 | 

: 파일 접근 모드 {#tbl-file_mode}

</br>

다음의 명령어는 동일합니다.
```julia
open("/Users/juliano/pathes.jl")
open("/Users/juliano/pathes.jl", "r")
```

아래의 두 명령어도 동일합니다.
```julia
open("/Users/juliano/pathes/jl", "w")
open("/Users/juliano/pathes/jl"; write = true)
```

</br>

### 파일 읽기


앞에서 `open` 파일은 실제로 파일에서 내용을 읽지 않는다고 언급했습니다. 파일을 열게 되면 `IOStream` 객체가 생성 됩니다. 이 객체에 대한 정보는 `stat()` 함수를 통해 얻을 수 있습니다. `IOStream` 객체는 바이트별로 데이터를 처리할 수 있으며 현재의 위치를 기억합니다. 현재의 위치는 `position()` 함수를 통해 알 수 있으며, 파일을 읽거나 쓰면 그만큼 현재의 위치가 이동합니다. 위치는 사용자가 바이트 단위로 옮길 수가 있는데 `0` 이 시작위치이며 끝 위치는 `filesize()` 함수로 얻을 수 있습니다.

```txt
In [1]: f1=open("pathes.jl")
Out[1]: IOStream(<file pathes.jl>)

In [2]: stat(f1)
Out[2]: StatStruct for RawFD(20)
   size: 93 bytes
 device: 16777220
  inode: 49833799
   mode: 0o100755 (-rwxr-xr-x)
  nlink: 1
    uid: 501 (jiyong)
    gid: 20 (staff)
   rdev: 0
  blksz: 4096
 blocks: 8
  mtime: 2023-12-04T18:11:59+0900 (19 hours ago)
  ctime: 2023-12-04T18:11:59+0900 (19 hours ago)

In [3]: position(f1)
Out[3]: 0

In [4]: read(f1, 3)
Out[4]: 3-element Vector{UInt8}:
 0x23
 0x21
 0x20

In [5]: position(f1)
Out[5]: 3

In [6]: seek(f1, 0)
Out[6]: IOStream(<file pathes.jl>)

In [7]: position(f1)
Out[7]: 0
```

파일에서 내용을 읽는 것은 `read()`, `readline()`, `readlines()` 함수를 이용합니다. `read()` 함수는 현재의 위치부터 인자로 전달되는 바이트 수 만큼을 읽고 `Vector{UInt8}` 로 반환합니다. 인자가 없다면 현재의 위치부터 끝까지 읽습니다. `readline()` 함수는 현재의 위치부터 다음 개행문자까지 읽고 문자열로 반환합니다. `readlines()` 함수는 현재의 위치부터 끝까지 읽고, 개행문자로 분할하여 문자열의 1차원 배열로 반환합니다. [개행문자는 일반 아스키나 유니코드 텍스트 파일에서 줄바꿈을 나타내는 문자이며 운영체제마다 다르지만 지금 사용하는 함수에서는 알아서 구분하여 분할해 줍니다.]{.aside}

</br>

그런데 위의 세 함수 `read`, `readline`, `readlines` 는 `open` 함수를 통해 파일에 접근하는 `IOStream` 객체를 만들지 않고 직접 파일 이름을 첫번째 인자로 입력하여 똑같은 일을 할 수 있습니다. 차이가 있다면 `IOStream` 을 통해 접근하면 파일에서의 현재위치(`position` 함수로 알 수 있는)가 유지되는 반면에 `read` 함수 등으로 직접 접근하면 함수를 호출할 때마다 파일의 현재위치가 초기화 된다는 것입니다.


</br>

#### 텍스트 파일 읽고 쓰기

이제 실제로 읽고 써 봅시다. 다음의 내용을 담은 파일을 기록한다고 해 봅시다.

```{.txt}
# 실험자 : 홍길동
# 실험 일시 : 2023년 12월 10일
# 데이터

10
4
7
6
33
5
2
```

하나의 문자열로 만든 다음에 통째로 `data1.txt` 파일로 적겠습니다. 현재 디렉토리가 파일로 저장하고자 하는 디렉토리라고 하고 상대경로를 사용하겠습니다.


```txt
In [1]: p="""
        # 실험자 : 홍길동
        # 실험 일시 : 2023년 12월 10일
        # 데이터

        10
        4
        7
        6
        33
        5
        2"""
Out[1]: "# 실험자 : 홍길동\n# 실험 일시 : 2023년 12월 10일\n# 데이터\n\n10\n4\n7\n6\n33\n5\n2"

In [2]: open("data1.txt", "w") do f
        f.write(p)
        end
```

이제 `data1.txt` 에 위의 내용이 기록되어 있음을 확인 할 수 있을 것입니다. 이제 이 파일을 읽고 처리하도록 하겠습니다. 가장 쉬운 방법은 `readlines()`로 통째로 줄 단위로 읽는 것입니다. 파일 전체를 읽을 것이므로 `readlines()` 함수를 통해 읽겠습니다.

```txt
In [1]: p = readlines("data1.txt")
Out[1]: 11-element Vector{String}:
 "# 실험자 : 홍길동"
 "# 실험 일시 : 2023년 12월 10일"
 "# 데이터"
 ""
 "10"
 "4"
 "7"
 "6"
 "33"
 "5"
 "2"
```

문자열의 베열을 얻었으며, 빈 줄 역시 `""` 로 표현됩니다. 네번째 줄부터 데이터이므로 이것을 정수의 배열로 바꾸겠습니다. `parse(T, x)` 는 값 `x` 를 타입 `T` 로 변경해주는 함수입니다.

```txt
In [11]: data = [parse(Int64, x) for x in p[5:end]]
Out[11]: 7-element Vector{Int64}:
 10
  4
  7
  6
 33
  5
  2
```

</br>

#### 이진 파일 읽고 쓰기

텍스트 파일과 이진 파일은 파일 자체로는 본질적으로 차이가 없고 읽을 때 개행문자를 어떻게 처리하는지의 차이가 있을 뿐입니다. 예를 들어 `UInt8` 타입의 정수 12개를 기록한다고 해 봅시다. 정수 하나가 1바이트이므로 총 8바이트를 기록하게 됩니다. 

```txt
In [1]: p = collect(UInt8, 1:1:8)
Out[1]: 8-element Vector{UInt8}:
 0x01
 0x02
 0x03
 0x04
 0x05
 0x06
 0x07
 0x08

In [2]: write("data2.bin", p)
Out[2]: 8

In [3]: read("data2.bin")
Out[3]: 8-element Vector{UInt8}:
 0x01
 0x02
 0x03
 0x04
 0x05
 0x06
 0x07
 0x08
```

</br>

여기까지는 큰 문제가 없습니다. 만약 `Float64` 타입의 실수 4개를 기록한다고 합시다. 

```txt
In [4]: nb = collect(Float64, 0.0:1.0:3.0)
Out[4]: 4-element Vector{Float64}:
 0.0
 1.0
 2.0
 3.0

In [6]: write("data3.bin", nb)
Out[6]: 32

In [7]: read("data3.bin")
Out[7]: 32-element Vector{UInt8}:
 0x00
 0x00
 0x00
 0x00
 0x00
...
```

`Float64` 부동소수는 8바이트이므로 4개의 `Float64` 부동소수는 32 바이트를 차지합니다. 따라서 우리는 32 개의 `UInt8` 정수를 얻었으며 이것을 다시 `Float64` 로 변환해야 합니다. 대신에 데이터가 저장될 배열을 생성하고 `read!` 함수를 사용해 봅시다. 

```txt
In [12]: v=Vector{Float64}(undef, 4);

In [13]: read!("data3.bin", v)
Out[13]: 4-element Vector{Float64}:
 0.0
 1.0
 2.0
 3.0
```

`v` 는 읽어들일 데이터가 저장될 배열입니다. 데이터를 읽고 배열을 변경하기 때문에 julia 의 관례에 따라 함수 이름 끝에 `!` 가 붙었습니다.


</br>

지금까지 텍스트 파일과 이진 파일의 저수준 입출력에 관해 간단히 알아보았습니다. 텍스트 파일은 메모장이나 텍스트 편집기로 파일 내용을 읽고 쓸수 있다는 큰 장점이 있습니다. 이진파일은 그 내용을 보더라도 의미를 알기 힘듭니다. 그러나 큰 데이터를 저장할 때 텍스트 파일은 이진 파일보다 몇배의 공간을 차지하기 때문에 큰 데이터를 저장하는데 적합하지 않습니다. 

또하나 생각해야 할 것은 파일에 데이터 뿐만 아니라 데이터에 대한 다양한 정보(이를 메타데이터라고 합니다)까지 같이 저장하는 경우 어디서부터가 어떤 형식의 데이터인지를 정확히 알아야 하며 그것에 맞추어 코딩을 해야 하는데 이것이 때때로 매우 번거롭습니다. 하지만 이미 존재하는 많은 파일 형식들과 그것을 쉽게 읽고 쓸 수 있도록 해주는 많은 라이브러리들이 있습니다. 이제 이것을 알아봅시다.




</br>

## 포맷이 정해진 파일의 입출력

Julia 에서 파일 입출력을 지원하는 [FileIO.jl](https://github.com/JuliaIO/FileIO.jl) 패키지가 있습니다. 많은 파일 형식에 관한 입출력 함수는 이 패키지의 `load` 함수와 `save` 함수를 메소드 디스패치하여 지원됩니다. 예를 들어 아래에 설명될 `CSV` 파일을 읽기 위해서는 `CSV.jl` 패키지가 필요한데, 이 `CSV.jl` 패키지에서 파일 입출력은 `FileIO.jl` 패키지를 이용하여 구현되었다는 의미입니다. [Registry table](https://juliaio.github.io/FileIO.jl/stable/registry/) 에는 `FileIO.jl` 의 `load/save` 를 이용하여 읽고 쓸 수 있는 포맷들이 나열되어 있습니다.


### CSV

데이터를 저장하는데 아주 많이 사용되는 포멧입니다. 아래와 같은 테이블을 생각합시다.

| value1 | value2 | value3 |
|:----:| :----:| :----:|
| 1 | 3 | 5 |
| 4 | 2 | 7 |
: Fruit prices {.hover}

위의 테이블이 아래와 같은 문자열로 저장되는 것이 CSV 입니다.

```txt
value1,value2,value3
1,3,5
4,2,7 
```
텍스트 포멧이며 모든 값은 "," 로 구분됩니다. `CSV` 의 이름 자체가 comma-separated values, 즉 콤마로 구분되는 값들 이라는 의미입니다. 보통은 주 데이터 뿐만 아니라 주 데이터에 대한 설명을 포함합니다. 가장 간단한 방법은 [CSV.jl](https://github.com/JuliaData/CSV.jl) 패키지를 사용하는 것입니다. 링크된 홈페이지에 자세히 설명이 되어 있습니다.

</br>



### HDF5

HDF5 는 단순히 하나 혹은 유사한 데이터의 나열이 아니라 구조적이고 거대한 데이터를 저장하는데 목적을 둔 데이터 포맷입니다. Julia 의 사전 자료형을 생각하면 됩니다. [HDF5.jl](https://juliaio.github.io/HDF5.jl/stable/) 을 참고하시기 바랍니다. C/C++ 을 비롯한 많은 언어에서 HDF5 파일을 읽고 쓸 수 있게 해 주는 라이브러리를 지원합니다. 다양한 언어에서 사용할 구조화된 대용량 데이터 포맷으로는 가장 적합합니다. 


</br>

### JLD2

HDF5 와 유사하지만 Julia 에서 사용하기 훨씬 편하며 다른 언어에서는 거의 사용할 수 없습니다. Julia 언어 내부에서만 사용할 경우에는 이 포맷이 좋습니다. [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) 를 참고하시기 바랍니다.

