## 이분법 (Bisection Method)

함수 $f$ 가 $(a,\,b)$ 에서 연속이며, $f(a)<0$ 이고 $f(b)>0$ 이거나 혹은 $f(a)>0$ 이고 $f(b)<0$ 이라 하자. 이 두 조건을 하나의 식으로 표현하면  $f(a)\cdot f(b)<0$ 이 되겠다. [중간값 정리](../ch05_calculus_of_one_variable_function/01_basic.qmd#thm-intermediate_value_theorem) 에 따라, $f(a)\cdot f(b)<0$ 이면, $(a,\,b)$ 구간의 최소한 한 점에서 $f(x)=0$ 의 해가 존재한다는 것을 안다. 이 조건만으로는 해가 $(a,\,b)$ 구간에서 몇개인지는 모르지만 최소한 하나는 존재한다는 것을 알 수 있다. Bisection method 는 주어진 구간의 모든, 혹은 가능한 많은 갯수의 해를 구하는 것이 아니라, 주어진 구간에서 하나의 해를 구하는 방법이다.

1. 일단 $f(a)<0,\, f(b)>0$ 인 경우에 대해 생각하자. $c=\dfrac{a+b}{2}$ 로 놓으면 $a<b<c$ 이다.

2. 우연히도 $f(c) =0$ 이면 우리는 원하는 것을 얻었으므로 끝이다. $f(c)>0$ 이면, $f(a)\cdot f(c)<0$ 이므로 역시 중간값 정리에 의해 $(a,\,c)$ 구간에 해가 반드시 존재한다. $(c,\,b)$ 구간에 존재여부는 이 조건에서는 알 수 없으며, 우리는 이 구간은 이제 잊는다. $f(c)<0$ 이면 $f(c)\cdot f(b)<0$ 이므로 $(c,\,b)$ 구간에 해가 존재한다.

3. 이제 우리는 해가 반드시 존재하는 원래 구간 길이의 1/2 인 새로운 구간을 얻었다. 이제 1. 로 돌아가 새로운 구간에서 다시 수행한다.

이 방법을 한번 쓸 때 마다 해가 존재하는것이 확실한 구간이 이전보다 $\dfrac{1}{2}$ 씩 준다.  이것을 $n$ 번 수행하면, 운 좋게도 $f(c)=0$ 이 되지 않는 한, 해가 존재하는 구간의 길이는 $\dfrac{1}{2^{n}}|b-a|$ 로 계속 준다. 10번 수행하면 처음 시작 구간의 약 0.1% 로, 100 번 하면 약 백만분의 일로 준다. 사람이 하면 지루한 과정이지만, 컴퓨터는 불평하지 않고, 빠른 시간에 할 수 있다.

$f(a)>0,\,f(b)<0$ 인 경우에도 같은 방법을 쓸 수 있다는것은 쉽게 이해 할 수 있을 것이다.



</br>

### 이분법 과정

![이분법](bisection_concept.png)

이 과정을 프로그래밍 입장에서 다시 정리해보자.  일단 처음 주어지는 함수 $f(x)$ 와 $a,\,b$ 에 대해 $a<b$ 로 주어졌다고 하자. 그리고 우리는 실제의 근 $x_0$ 와 우리가 구한 근의 차이를 $\delta$ 보다 작게 하고자 한다.

1. $a_0=a,\,b_0=b,\,c_0=\dfrac{a+b}{2}$ 로 놓는다.  만약 $f(a_0) \cdot f(c_0)<0$ 이면  역시 중간값 정리에 의해 $(a_0,\, c_0)$ 구간에 해가 존재함을 알 수 있다. 그렇다면 $a_1=a_0,\, b_1=c_0$ 으로 놓는다. 반대로 $f(a_0)\cdot f(c_0)>0$ 이면 $f(c_0)\cdot f(b_0)<0$ 이므로 $(c_0,\,b_0)$ 구간에 해가 존재한다. 이때는 $a_1=c_0,\, b_1=b_0=b$ 로 놓는다. $f(c_0)=0$ 이면 $c$ 이 $f(x)=0$ 의 해이므로 더이상 진행하지 않는다.

2. $a_n<b_n$ 에 대해 $f(a_n)\cdot f(b_n)<0$ 이라 하자. $|b_n-a_n|<2\delta$ 이면 실제의 근 $x_0$ 와 $c_n =\dfrac{a_n+b_n}{2}$ 의 차이는 $\delta$ 보다 작기 때문에 $c_n$ 이 우리가 구하고자 하는 수치적인, 그리고 근사적인 근이 된다. $|b_n-a_n|\ge 2\delta$ 이면, $c_n =\dfrac{a_n+b_n}{2}$ 이라 놓는다. $f(c_n)=0$ 이면 우리는 하나의 해를 구했으므로 종료한다. $f(a_n)\cdot f(c_n)<0$ 이면 $(a_n,\,c_n)$ 구간에서 하나의 해가 존재하므로 $a_{n+1}=a_n,\, b_{n+1}=b_n$ 으로 놓고 이 과정을 계속 한다. $f(a_n)\cdot f(c_n)>0$ 이면 $f(b_n) \cdot f(c_n)<0$ 이므로 $a_{n+1}=c_n,\, b_{n+1}=b_n$ 으로 놓는다.

</br>

이제 이것을 줄리아로 구현해 보자. 그 전에 주의해야 할 것이 있다.

</br>

#### 무한루프

수치해석은 기본적으로 `for ~ end` 문이나 `while ~ end` 같은 루프가 아주 많이 쓰인다. 이 가운데 `while (condition) ~ end` 구문은 조건이 참인지 아닌지 여부만을 따져 수행을 반복하기 때문에 잘못하면 수행이 끝나지 않을 수 있다. 예를 들어,

```julia
v = 1
while v<10
    v=v*1
end
```

같은 코드는 종료되지 않는다. Bisection method 를 `while ~ end` 루프로 구현할 경우, 코딩 오류 등으로 인해 무한루프에 빠질 수 있다. 프로그래밍에 익숙한 사용자라면 일정 시간이 흘러도 결과가 나오지 않으면 무한루프에 빠졌다는 것을 쉽게 알 수 있을 수도 있다. 그러나 함수값 하나 얻는 데 시간이 오래 결리는 경우는, 수행시간이 오래 지났더라도 이것이 정상적인 실행중인지, 무한루프에 빠졌는지 불확실할 경우도 있다. 그래서 이런 경우는 보통 최대 반복 횟수를 정해놓고 이 횟수에 도달하면 에러를 발생시키는 등으로 정상적인 결과를 얻지 못했다는 것을 알려 주는것이 좋다.

</br>

### Bisection method 에 대한 julia 함수

함수 $f(x) = -10+4 e^{2x}$ 의 해를 구해보도록 하자. $f(x)$ 를 코드상에서 `myfunc` 라고 이름을 붙이자. 최대 시행 횟수는 `maxiter` 라는 변수로 넣어주도록 한다. $\delta$ 는 `xtol` 이란 변수로 입력한다.

```julia
function bisection(f::Function, a, b, xtol=1e-10, maxiter::Integer=10_000)
    Nitter = 0
    a, b = minmax(a, b)
    
    f(a)*f(b) <= 0 || error("f(a)*f(b) should be negative") 
    c=0
    while ((b-a) > xtol) 
        Nitter +=1
        Nitter < maxiter || error("Interation 횟수가 정해진 최댓값에 도달했습니다")
        c = (a+b)/2
        if f(c) == 0.0
            break
        elseif f(a)*f(c) < 0 
            a, b = a, c
        else 
            a, b = c, b 
        end
    end
    println("Number of Iterlation = $Nitter")
    return c    
end
```

이제 이분법을 이용하여 $\sqrt{2}$ 의 근사값을 구할 수 있다. $\sqrt{2}$ 는 $f(x)=x^2-2$ 의 근이므로

```julia
sqrt2 = bisection(x -> x^2-2, 0.0, 4.0)
realsqrt2 = sqrt(2.0)
difference = realsqrt2-sqrt2
println("실제값 = $realsqrt2, 계산값 = $sqrt2, 차이 = $difference")
```

결과는

```sh
Number of Iterlation = 36
실제값 = 1.4142135623730951, 계산값 = 1.4142135623260401, 차이 = 4.705502654189786e-11
```

을 얻는다.

</br>


::: {.callout-note}
앞의 코드에서 `f(a)*f(b) <= 0 || error("f(a)*f(b) should be negative")` 는 소위 **단락 계산 (short-circit evaluation)** 을 사용한 표현이다. 표현식 `a && b` 에서, 하위 표현식 `b`는 오직 `a` 가 `true` 일때만 실행된다. 반면 표현식 `a || b` 에서, 하위 표현식 `b` 는 오직 `a` 가  `false` 로 계산될 때만 계산을 받는다. 왜냐 하면, `a` 가 `false` 이면, `b` 의 값에 관계없이 `a && b` 는 무조건 `false` 가 되고, `a` 가 `true` 이면, `b` 의 값에 관계없이 `a && b` 는 무조건 `true` 가 되기 때문이다. 따라서 `f(a)*f(b)` 가 0 보다 큰 경우에만 에러를 발생시킨다. 이것은

```julia
if f(a)*f(b) <= 0
    error("f(a)*f(b) )
```

와 같은 표현이다.
:::

</br>
