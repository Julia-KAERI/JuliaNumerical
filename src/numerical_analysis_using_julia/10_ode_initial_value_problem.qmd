---
title: "상미분 방정식의 초기값 문제"
language: ../_language-ko_custom.yml 

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

## 상미분 방정식 (Ordinary Differential Equations) 과 초기값 문제

상미분 방정식은 하나의 독립변수에 대한 미분방정식이다. $f(t)$ 에 대한 미분방정식이 $f$ 에 대해 최대 $n$ 차 미분까지 포함되었을 경우, $n$-차 상미분 방정식이라 한다. 일반적으로 $n$ 차 미분 방정식은 다음 꼴로 주어진다.

$$
f^{(n)}(t) + a_{n-1} f^{(n-1)}(t) + \cdots a_1 f(t) + a_0 = 0
$$

 상미분 방정식 자체로는 어떤 미지수를 가질 수 밖에 없으며, 이 미지수를 초기값 $t_1$ 에 대한 $f^{(k)}(t_1)$ $k=1,\,2,\ldots$ 값을 통해 알아내는 것을 **초기값 문제 (initial value problem)** 이라고 한다. 

</br>

### 오일러 방법 (Newton's method)

오일러 방법은 초기값이 주어졌을 때 수치해석적으로 미분방정식의 해를 구하는 가장 간단한 방법이다. 가장 간단한 만큼 일반적으로 오차가 크지만 상미분방정식의 초기값 문제를 푸는 여러가지 기법을 익힐 수 있다. 

#### 일변수 일차 미분 방정식

아래와 같은 미분방정식

$$
x'(t) = \dfrac{dx}{dt} = f(t, x)
$$

과 초기조건 $x(t_1)$ 이 주어졌다고 하자. 테일러 전개에 의해

$$
\begin{aligned}
x(t+h) &= x(t) + x'(t)h + O(h^2) \\
&= x(t) + f(t, x)h + O(h^2)
\end{aligned}
$$

를 이용하는 방법이다. 


#### 다변수 일차 미분 방정식

$\boldsymbol{x}:\mathbb{R}\to \mathbb{R}^n$ 이며 $x_i(t)$ 가 $\boldsymbol{x}(t)$ 의 $i$ 번째 성분일 때 미분방정식이 $\boldsymbol{f}:\mathbb{R}^{n+1}\to \mathbb{R}^n$ 에 대해

$$
\boldsymbol{x}'(t)=\dfrac{d\boldsymbol{x}}{dt} = \boldsymbol{f}(t, x_1,\ldots,\,x_n)
$$

로 주어지고, 초기값 $t_1,\,\boldsymbol{x}(t_1)$ 가 주어졌을 때 가장 간단하게 $\boldsymbol{x}(t)$ 를 구하는 방법이다. 테일러 전개를 이용하면,

$$
x_i(t + h) = y_i(t) + x_i'(t)h+ \dfrac{x_i''(\xi)}{2}h^2
$$

를 만족하는 $\xi\in (t,\, t+h)$ 이 존재한다는 것을 안다. 이 때 $|h | \ll 1$ 이면,

$$
x_i(t + h) \approx x_i(t) + x_i'(t)h
$$

임을 이용하는 것이 오일러 벙법이다.

$t_{k+1}=t_k+h$ 일 때,

$$
\boldsymbol{x}(t_{k+1}) = \boldsymbol{x} (t_k) + \boldsymbol{f}(t_k, x_1(x_k), \ldots, x_n(t_k))\, h
$$

를 이용하여 $\boldsymbol{x}(t_{k+1})$ 값을 구한다. 아래와 같이 julia 로 구현 할 수 있다.

```julia
# 일변수에 대한 오일러 방법
function ode_euler(
    fp::Function,
    t1::Real, 
    x1::Real,
    Npoints::Integer, 
    h = 1.0e-6)
    
    tn = t1 .+ collect(0:1:(Npoints-1)) * h
    xn = zero(tn)
    xn[1] = x1
    for i in 1:(Npoints-1)
        xn[i+1] = xn[i] + fp(tn[i], xn[i])* h
    end
    return tn, xn
end


# 다변수에 대한 오일러 방법
function ode_euler(
    fp::Vector{<:Function}, 
    t0::Real, 
    x0::Vector{<:Real}, 
    Npoints::Integer, 
    h = 1.0e-6)
    
    tn = t0 .+ collect(0:1:(Npoints-1)) * h
    xn = zeros((length(x0), length(tn)))
    xn[:,1] = x0
    for i in 1:(Npoints-1)
        xn[:, i+1] = xn[:, i] .+ [f(t) for (f, t) ∈ zip(fp, tn[i])] .* h
    end
    return tn, xn
end
```

$f(x,\,y)$ 가 변수 2개에 대한 함수일 때는 위의 함수를 약간 수정하여 구현 할 수 있을 것이다.

우리는 $y'= e^x,\, y(0)=1$ 일 때, $y=e^x$ 임을 알고 있다. 아래 그림은 위의 `ode_euler` 함수를 이용하여 미분방정식을 푼 값과, 실제 함수값을 비교해 보았다.

</br>
[`LaTeXStrings` 는 $\LaTeX$ 의 수식을 사용 할 수 있도록 해 주는 패키지이다.]{.aside}
```julia
using LaTeXStrings, Plots
tn, xn = ode_euler((t, x)->exp(t), 0.0, 1.0, 500, 1.0e-2)
plot(tn, xn, lw = 2, frame = :box, label = "Euler method")#, dpi=300)
plot!(tn, exp.(tn), lw=2, ls = :dash, label = L"f(t) = e^t")
```


![Euler 방법](ch10_ode/euler_method.png){width=600}

</br>

다변수 오일러 방법을 사용해 볼 수 있는 문제중의 하나는 로렌츠 방정식이다.

$$
\begin{aligned}
\dfrac{dx}{dt} &  = \sigma (y-x), \\
\dfrac{dy}{dt} & = x(\rho - z)-y, \\
\dfrac{dz}{dt} &= xy-\beta z.
\end{aligned}
$$ {#eq-lorentz_equation}

$\boldsymbol{x} =\begin{bmatrix} x & y & z\end{bmatrix}^T$ 로 놓고 다변수 오일러 방법을 통해 구해보자. 어떤 조건에서 위의 미분방정식의 해가 나비를 닮았기 때문에 함수 이름을 `butterfly3d` 로 하였다. $\sigma=10$, $\rho=28$, $\beta=8/3$ 일 때, 

```julia
function butterfly3d(v, σ::Real, ρ::Real, β::Real)
    return [σ*(v[2]-v[1]), v[1]*(ρ - v[3])-v[2], v[1]*v[2]-β*v[3]]
end

tn, xn = ode_euler((t, v)->butterfly3d(v, 10, 28, 8/3), 0.0, [0.0, 1.0, 1.0], 4000, 1.0e-2)
```

를 통해 얻은 궤적을 그리면 다음과 같다.

```julia
using Plot, LaTeXStrings
p0 = plot(xn[1,:], xn[2,:], xn[3,:], frame=:box, aspect_ratio=1.0, label=L"xyz", dpi=300)
p1 = plot(xn[1,:], xn[2,:], frame=:box, aspect_ratio=1.0, label=L"xy", color=:red)
p2 = plot(xn[2,:], xn[3,:], frame=:box, aspect_ratio=1.0, label=L"yz", color=:green)
p3 = plot(xn[3,:], xn[1,:], frame=:box, aspect_ratio=1.0, label=L"zx", color=:blue)

plot!(p0, p1, p2, p3, layout=4)
```

![로렌츠 방정식](ch10_ode/lorentz.png){width=600}

</br>


#### 다변수 이차 미분 방정식
 $\dfrac{d^2\boldsymbol{x}}{dt^2} = \boldsymbol{f}(t, \boldsymbol{x}, \boldsymbol{x}')$ 으로 주어진 미분방정식은,

$$
\begin{aligned}
\boldsymbol{v}(t_{n}+h) &=\boldsymbol{v}(t_n) + \boldsymbol{f}(t, \boldsymbol{x}(t_n), \boldsymbol{v}(t_n)) h,\\
\boldsymbol{x}(t_n+h) &=\boldsymbol{x}(t_n) + \boldsymbol{v}(t_n)h 
\end{aligned}
$$

와 같이 2개의 1차 미분방정식에 대한 오일러 방법에 의한 해로 주어진다. 가장 간단한 1차원 조화진동자 문제를 보자. 미분방정식이 

$$
x''(t) = -k\cdot x(t)
$$ 

로 주어졌을 때 $\boldsymbol{y}(t) = \begin{bmatrix} x(t) \\ x'(t) \end{bmatrix}$ 로 놓으면, 

$$
\boldsymbol{y}(t+h) = \begin{bmatrix} x(t+h) \\ x'(t+h)\end{bmatrix} = \begin{bmatrix} x(t) + x'(t)h \\ x'(t) -k  x(t) h \end{bmatrix} = \boldsymbol{y}(t) + h\begin{bmatrix} 0 & 1\\ -k & 0\end{bmatrix} \boldsymbol{y}(t)
$$

이를 위해 다음과 같은 코드를 작성하였으며 그래프로 그려보면 다음과 같다.

```julia
function sho1d(y::Vector{<:Real}, k::Real, x0=0.0)
    return [y[2], -k*(y[1]-x0)]

tn, xn = ode_euler((t, y)->sho1d(y, 3, 1.0), 2.0, [1.1, 0.0], 10000, 1.0e-2)
plot(tn, xn[1,: ], label = :none)
```

![오일러 방법으로 계산한 1차원 조화진동자](ch10_ode/euler_sho1d.png){width=600}


1차원 조화진동자는 잘 알려져 있다 시피 삼각함수로 그 진폭이 커지면 안되지만 여기서는 커지는데 이것은 오일러 방법이 기본적으로 에러에 취약하기 때문이다. 이로 인해 실제 계산에서는 오일러 방법은 잘 사용되지 않는다. 

</br>

### 2차 룽게-쿠타 방법 (Runge-Kutta method)

역시
$$
\dfrac{d\boldsymbol{x}}{dt} = \boldsymbol{f}(t, \boldsymbol{x})
$$

와 초기조건 $\boldsymbol{x}_0 = \boldsymbol{f}(t_0)$ 가 주어졌다고 하자.  우리는 여기서,

$$
\dfrac{d^2\boldsymbol{x}}{dt^2 } = \dfrac{d}{dt}f(t, \,\boldsymbol{x}) = \dfrac{\partial f}{\partial t} + \sum_j\dfrac{dx_j}{dt} \cdot \dfrac{\partial \boldsymbol{f}}{\partial x_j}
$$

라는 것을 안다. 이것을 이용하여 2차항까지 테일러 전개를 하면,
$$
\begin{aligned}
x_i(t+h) & = x_i(t) + \dfrac{dx_i}{dt}h  + \dfrac{1}{2}\dfrac{d^2 x_i}{dt^2}h^2 + \cdots \\
&= x_i(t)  + f_i(t, \boldsymbol{x})\, h + \dfrac{1}{2} \left(\dfrac{\partial f_i}{\partial t} + \sum_j \dfrac{dx_j}{dt} \dfrac{\partial f_i}{\partial x_j}\right) h^2 + \cdots \\
&= x_i(t)  + f(t, \boldsymbol{x})\, h + \dfrac{1}{2} \left(\dfrac{\partial f}{\partial t} + \sum_j f_j(t,\,\boldsymbol{x}) \dfrac{\partial f_i}{\partial x_j}\right) h^2 + \cdots
\end{aligned}
$$

이다. 이 때,

$$
\begin{aligned}
\boldsymbol{k}_1 &= \boldsymbol{f}(t_n, \boldsymbol{x}(t_n)) \,,\\
\boldsymbol{k}_2 &= \boldsymbol{f}\left( t_n + \dfrac{h}{2},\, \boldsymbol{x}(t_n) + \dfrac{h}{2} \boldsymbol{k}_1\right)
\end{aligned}
$$

라 하자. 그렇다면, 야코비안 행렬 $\left(\boldsymbol{J}_\boldsymbol{f}(t_n, \boldsymbol{x}(t_n))\right)_{ij} = \dfrac{\partial f_i}{\partial x_j}(t_n, \boldsymbol{x}(t_n))$ 에 대해 

$$
\begin{aligned}
\boldsymbol{k}_2 &= \boldsymbol{f}(t_n,\, \boldsymbol{x}(t_n)) +  \dfrac{h}{2} \dfrac{\partial \boldsymbol{f}}{\partial t}(t_n,\, \boldsymbol{x}(t_n)) + \dfrac{h}{2} \boldsymbol{J}_\boldsymbol{f}(t_n, \boldsymbol{x}(t_n)) \boldsymbol{k}_1 \\
&= \boldsymbol{k}_1 + \dfrac{h}{2} \left(\dfrac{\partial \boldsymbol{f}}{\partial t}(t_n,\, \boldsymbol{x}(t_n))  + \boldsymbol{J}_\boldsymbol{f}(t_n, \boldsymbol{x}(t_n)) \boldsymbol{k}_1 \right)
\end{aligned}
$$

이므로,

$$
\begin{aligned}
\dfrac{\partial \boldsymbol{f}}{\partial t}(t_n,\, \boldsymbol{x}(t_n))  + \boldsymbol{J}_\boldsymbol{f}(t_n, \boldsymbol{x}(t_n)) \boldsymbol{k}_1 & = \dfrac{2}{h}(\boldsymbol{k}_2-\boldsymbol{k}_1)
\end{aligned}
$$

이다. 이를 이용하면,

$$
\boldsymbol{x}(t_{n+1}) = \boldsymbol{x}(t_n) + \boldsymbol{k}_1h + \dfrac{h^2}{2} \dfrac{2}{h} (\boldsymbol{k}_2-\boldsymbol{k}_1) = \boldsymbol{x}(t_n)+ \dfrac{h}{2}(\boldsymbol{k}_1+\boldsymbol{k}_2)
$$

을 얻는다. 이것을 2차 룽게-쿠타 방법이라 한다.

</br>

### 4차 룽게-쿠타 방법

2차 룽게 쿠타 방법은 테일러 전개의 2차항까지 사용하였다. 4차 룽게-쿠타 방법은 테일러 전개의 4차항까지 사용한다.
$$
\boldsymbol{x}(t+h)  = \boldsymbol{x}(x) + \boldsymbol{x}'(x) h + \dfrac{\boldsymbol{x}''(t)}{2} h^2 + \dfrac{\boldsymbol{x}^{(3)}(t)}{6}h^3 + \dfrac{\boldsymbol{x}^{(4)}(t)}{24}h^4 + \cdots
$$

아래와 같이 $\boldsymbol{k}_1,\,\boldsymbol{k}_2,\,\boldsymbol{k}_3,\,\boldsymbol{k}_4$ 를 정의하면,
$$
\begin{aligned}
\boldsymbol{k}_{1} &= \boldsymbol{f}(t_{n},\, \boldsymbol{x}(t_{n})),\\
\boldsymbol{k}_{2}&=\ \boldsymbol{f}\!\left( t_{n}+{\frac {h}{2}},\, \boldsymbol{x}(t_{n})+ \frac{h}{2}\boldsymbol{k}_{1}\right),\\
\boldsymbol{k}_{3}&=\ \boldsymbol{f}\!\left(t_{n}+{\frac {h}{2}},\,  \boldsymbol{x}(t_{n})+\frac{h}{2} \boldsymbol{k}_{2}\right),\\
\boldsymbol{k}_{4}&=\ \boldsymbol{f}\!\left(t_{n}+h,\, \boldsymbol{x}(t_{n})+h\boldsymbol{k}_{3}\right).
\end{aligned}
$$

4차항까지의 테일러 전개가 아래와 같다는 것을 보일 수 있다. 아주 지루한 과정이므로 여기서는 생략한다.
$$
\begin{aligned}
t_{n+1}&=t_{n}+h, \\
\boldsymbol{x}(t_{n+1})&=\boldsymbol{x}(t_{n})+{\frac {h}{6}}\left(\boldsymbol{k}_{1}+2 \boldsymbol{k}_{2}+2\boldsymbol{k}_{3}+\boldsymbol{k}_{4}\right).
\end{aligned}
$$

오일러 방법, 2차 및 4차 룽게-쿠타 방법을 이용하여 상미분 방정식을 푸는 julia 코드는 아래와 같다. 모두 이변수 함수 `f` 와 초기값 `x0`, `y0`, 위의 $h$ 에 해당하는 값 `epsilon` 과 초기 값을 포함하여 몇개의 점에 대해 얻을지에 대한 `Npoints` 를 인자로 받는다.

```julia
function ode_euler(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T<:AbstractFloat
    eps = convert(T, epsilon)
    xp = x0 .+ collect(0:1:(Npoints-1)) * eps
    yp = zeros(T, length(xp))
    yp[1] = y0
    for i in 2:Npoints
        yp[i] = yp[i-1]+ f(xp[i-1], yp[i-1]) * eps
    end
    return xp, yp
end

function ode_runge_kutta2(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T<:AbstractFloat
    eps = convert(T, epsilon)
    xp = x0 .+ collect(0:1:(Npoints-1)) * eps
    yp = zeros(T, length(xp))
    yp[1] = y0
    for i in 2:Npoints
        xn, yn = xp[i-1], yp[i-1]
        k1 = f(xn, yn)
        k2 = f(xn + eps/2, yn + k1*eps/2)
        yp[i] = yn + (k1+k2)*eps/2
    end
    return xp, yp
end

function ode_runge_kutta4(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T<:AbstractFloat
    eps = convert(T, epsilon)
    xp = x0 .+ collect(0:1:(Npoints-1)) * eps
    yp = zeros(T, length(xp))
    yp[1] = y0
    for i in 2:Npoints
        xn, yn = xp[i-1], yp[i-1]
        k1 = f(xn, yn)
        k2 = f(xn + eps/2, yn + eps*k1/2)
        k3 = f(xn + eps/2, yn + eps* k2/2)
        k4 = f(xn + eps, yn + eps*k3)
        yp[i] = yn + (k1 + 2*k2 + 2*k3 + k4)*eps/6
    end
    return xp, yp
end
```

간단한 사용법은 아래와 같다.

```julia
f1(x, y) = cos(0.1*x)*x
x0 = 0.0
y0 = 0.0
xp, yp1 = ode_euler2(f1, x0, y0, 10000, 1.0e-1);
xp, yp2 = ode_runge_kutta2(f1, x0, y0, 10000, 1.0e-1);
xp, yp3 = ode_runge_kutta4(f1, x0, y0, 10000, 1.0e-1);
```

</br>

### 예제 (Examples)

#### 단순 감쇠

$$
\dfrac{dy}{dt} = -a y(t),\, y(0)=y_0
$$

의 해가 $y=y_0 e^{-at}$ 라는 것을 알지만, 이것을 수치해석적으로 풀어보기로 하자. 오일러 방법으로도 좋은 결과를 얻을 수 있으므로 오일러 방법만을 수행하기로 한다.

```julia
using Plots
a=1.0
f(x, y) = -a*y
xp, y_newton = ode_euler((x, y)->-a*y, 0.0, 1.0, 10000, 1.0e-3)
plot(xp, exp.(-a.*xp), label=L"e^{-ax}")
plot!(xp, y_newton, label="Euler method")
```

이 결과는 다음과 같다.

</br>

<img src = "ch10_ode/decay.png"/>

</br>

#### 단순 조화 진동자

$$
m \dfrac{d^2x}{dt^2}  =- kx
$$
를 단순조화진동자 문제라고 한다. 이와 같은 이차미분방정식은 $x_1 = x,\, x_2 = \dfrac{dx_1}{dt}$ 라 놓으면

$$
\dfrac{dx_2}{dt} = -\dfrac{k}{m}x_1,\, \dfrac{dx_1}{dt} = x_2
$$

로 놓을 수 있다. $\mathbf{x}(t) = \begin{bmatrix} x_1(t) \\ x_2(t) \end{bmatrix}$ 라 놓으면,

$$
\dfrac{d\mathbf{x}}{dt}= \begin{bmatrix} x_2 \\ - \dfrac{k}{m} x_1 \end{bmatrix}
$$

이다.

이제 오일러 방법과 룽게-쿠타 방법을 벡터에 대한 미분방정식으로 확장하자. Julia 에서 제공하는 [다중 디스패치(multiple dispatch)](https://docs.julialang.org/en/v1/manual/methods/) 는 함수 이름이 같을 때 인자의 갯수와 타입에 가장 적합한 함수를 자동으로 선택하여 실행시킨다.

벡터 $\mathbf{x}$ 에 대한 시간 미분이 $f(t,\, \mathbf{x})$ 라 하자. 즉,

$$
\dfrac{d\mathbf{x}}{dt} = f(t,\,\mathbf{x})
$$

```julia
function ode_euler(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T<:AbstractFloat
    N = length(x0)
    eps = convert(T, epsilon)
    tp = t0 .+ collect(0:1:(Npoints-1)) * eps
    xp = zeros(T,  N, Npoints)
    xp[:,1] = x0[:]
    for i in 2:Npoints
        xp[:, i] = xp[:, i-1] .+ f(tp[i-1], xp[:, i-1]) .*eps 
    end
    return t, xp
end

function ode_runge_kutta2(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T<:AbstractFloat
    N = length(x0)
    eps = convert(T, epsilon)
    tp = t0 .+ collect(0:1:(Npoints-1)) * eps
    xp = zeros(T,  N, Npoints)
    xp[:,1] = x0[:]
    for i in 2:Npoints
        tn, xn = tp[i-1], xp[:, i-1]
        k1 = f(tn, xn)
        k2 = f(tn + eps/2, xn .+ (eps/2) .* k1)
        xp[:, i] = xn .+ (k1 .+ k2) .* (eps/2)
    end
    return tp, xp
end

function ode_runge_kutta4(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T<:AbstractFloat
    N = length(x0)
    eps = convert(T, epsilon)
    tp = t0 .+ collect(0:1:(Npoints-1)) * eps
    xp = zeros(T,  N, Npoints)
    xp[:,1] = x0[:]
    for i in 2:Npoints
        tn, xn = t[i-1], xp[:, i-1]
        k1 = f(tn, xn)
        k2 = f(tn + eps/2, xn .+ (eps/2) .* k1)
        k3 = f(tn + eps/2, xn .+ (eps/2) .* k2)
        k4 = f(tn + eps, xn .+ eps.*k3)
        xp[:, i] = xn .+ (k1 .+ 2*k2 .+ 2*k3 .+ k4).*(eps/6)
    end
    return tp, xp
end
```

$k=1.0,\, m=1.0$ 으로 정하여 오일러 방법과 4차 룽게-쿠타 방법을 이용하여 미분방정식을 다음과 같이 수치해석적으로 풀 수 있다.

```julia
k = 1.0
m = 1.0
f_ho(t, x) = return [x[2], -k/m*x[1]]

t, xp1 = ode_euler(f_ho, 0.0, [0.0 ; 1.0], 10000, 1.0e-3)
t, xp2 = ode_runge_kutta4(f_ho, 0.0, [0.0 ; 1.0], 10000, 1.0e-3)
```

그 결과를 그래프로 그리면 다음과 같다.

<img src = "ch10_ode/harmonic.png" />

</br>

#### 감쇄 조화 진동자

$$
m \dfrac{d^2x}{dt^2} + \gamma \dfrac{dx}{dt} + kx=0
$$

로 기술되는 $x(t)$ 를 감쇄조화진동자라 한다. 일단 방정식을 간단히 하자.

$$
\dfrac{d^2x}{dt^2} + \dfrac{\gamma}{m}\dfrac{dx}{dt} + \dfrac{k}{m} x = 0
$$

$v=\dot{x}$ 라 하면 $\dot{v} = -\dfrac{\gamma}{m}\dfrac{dx}{dt} - \dfrac{k}{m} x$ 이므로,

$$
\dfrac{d}{dt} \begin{bmatrix} x \\ v\end{bmatrix} = \begin{bmatrix} v \\ -\dfrac{\gamma}{m}v - \dfrac{k}{m} x\end{bmatrix}
$$

이다.

많은 고전물리학 책에 이 감쇄조화진동자가 나와 있다. 감쇄조화진동자의 해는 다음과 같다.

$$
x(t) = \exp(-\lambda t) \left[ a \exp \left(\sqrt{-\omega_0^2} \right)+ b \exp \left(-\sqrt{-\omega_0^2}\right)\right]\qquad \text{where }  \lambda  =\dfrac{\gamma}{2m},\, \omega_0^2 = \dfrac{k}{m}-\dfrac{b^2}{4m^2}
$$

이다. 여기서 $a,\,b$ 는 초기조건 $x(t=0),\, \dot{x}(t=0)$ 에 의해 정해진다.

$\omega_0^2 >0$ 이면 $x(t)$ 의 $[\,\cdots]$ 부분이 $\cos$ 함수 (혹은 $\sin$ 함수) 꼴로 나타날 수 있으므로 진폭이 점점 줄어드는 진동을 한다. 이를 *underdamping* 라 한다. $\omeg_0^2 <0 $ 이면 진동 없이 감쇄만 하게 되며 이를 *overdamping* 라 한다. $\omega_0^2 = 0$ 일 경우를 *critical damping* 이라 한다.

$m=1,\, \gamma=1,\, k=1$ 과 $x(t=0)=0,\, \dot{x}(t=0)=1$ 일 때에 대해 오일러 방법, 2차 및 4차 룽게 쿠타 방법과, 해석적 해를 같이 그려보자.

</br>

<img src = "ch10_ode/dho.png"/>

</br>

#### 진자(Pendulum) 문제

<img src="ch10_ode/simple pendulum.png" width="250"/>

</br>

중력가속도 $g$ 의 영향을 받는 길이 $L$인 진자의 운동은 다음의 미분방정식으로 기술된다.

$$
\dfrac{d^2 \theta}{dt^2} = -\dfrac{g}{L} \sin \theta
$$

보통 $\theta$ 가 아주 작을 때 $\sin \theta \approx \theta$ 로 가정하여 풀면

$$
\dfrac{d^2\theta}{dt^2}= -\left( \dfrac{g}{L} \right)\theta
$$

이므로 단순조화진동자 문제이다.

이제 수치적으로 풀어보자. $\phi= \dfrac{d\theta}{dt}$, $\mathbf{x} = \begin{bmatrix} \theta \\ \phi \end{bmatrix}$ 라 하면,

$$
\dfrac{d}{dt}\begin{bmatrix} \theta \\ \phi \end{bmatrix} = \begin{bmatrix} \phi \\ -g/L \sin \theta  \end{bmatrix}
$$

가 된다. $g=1.0,\, L=2.0$ 으로 잡고 시간 간격을 $1\times 10^{-2}$ 간격으로 미분방정식을 3가지 방법으로 풀면

```julia
g = 1
L = 2.0
Np = 10000
epsilon = 1.0e-2
θ0, ϕ0 = 0.0, 1.0

f_pendulum(t, x) = return [x[2], -g/L*sin(x[1])]
t, xp1 = ode_euler(f_pendulum, 0.0, [ θ0 ; ϕ0], Np, epsilon)
t, xp2 = ode_runge_kutta2(f_pendulum, 0.0, [θ0 ; ϕ0], Np, epsilon)
t, xp3 = ode_runge_kutta4(f_pendulum, 0.0, [θ0 ; ϕ0], Np, epsilon)

plot(t, xp1[1, :], label = "Euler", frame = :box, loc=:topcenter)
plot!(t, xp2[1, :], xlabel = "t", label = "RK2")
plot!(t, xp3[1, :], xlabel = "t", label = "RK4")
```

</br>

<img src = "ch10_ode/pendulum1.png"/>

</br>

와 같다. 여기서는 세 방법이 시간이 지날수록 큰 차이를 보인다. 그러나 시간간격을 앞서보다 1/10 으로 줄여서 풀어 그리면 차이가 앞서보다 많이 주는 것을 볼 수 있다.

</br>

<img src = "ch10_ode/pendulum2.png"/>

</br>

### 마치며

이번 장에서는 상미분 방정식을 푸는 가장 기본적인 방법인 오일러 방법과 2차, 4차 룽게-쿠타 방법을 배웠다. 수치해석이 늘 그렇듯이 간단한 미분방정식은 잘 풀 수 있지만 다양하고 복잡한 문제에서는 더 정확한 방법을 사용해야 한다.
