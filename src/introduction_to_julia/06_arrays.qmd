---
title: "배열"

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

## 배열 (Array) {#sec-array}

### 배열에 대한 용어 {#sec-terms_on_array}

Julia 는 0 차원 배열부터 임의의 **차원(dimension)**의 배열을 지원합니다. 1차원 배열은 `Vector`, 2차원 배열은 `Matrix` 라는 별명(alias)을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 **축(axis)** 이라고 부릅니다. 배열의 **형태(shape)** 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 `(3, 4, 5)` 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다. 

1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.

```txt
In [1]: arr1 = [1.0, 2.0, 3.0, 4.0]
Out[1]: 4-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0

In [2]: arr2 = [4.0; 5; 6]
Out[2]: 3-element Vector{Float64}:
 4.0
 5.0
 6.0

In [3]: arr3 = [1 2 3 4]
Out[3]: 1×4 Matrix{Int64}:
 1  2  3  4

In [4]: arr4=[3 2;4 5]
Out[4]: 2×2 Matrix{Int64}:
 3  2
 4  5
```

`arr1` 과 같이 `[ ]` 안에 콤마로 분리된 경우와 `arr2` 와 같이 `;` 로 분리된 경우는 1 차원 벡터입니다. `Out[1]` 의 `Vector{Float64}` 는 성분이 `Float64` 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 `Vector` 는 1차원 배열과 같은 의미이며 (`alias` 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) `Matrix` 는 2차원 배열의 alias 입니다. `arr3` 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 `[1 2]` 와 `[1, 2]` 는 다릅니다. `arr4` 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 `;` 를 사용합니다. 배열의 각 성분에 접근할 때는 `arr2[3]` 이나 `arr3[1, 1]` 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 [배열의 인덱스](#sec-index_of_array) 에서 좀 더 자세히 다룹니다.

`;` 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.

</br>

```txt
In [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]
Out[5]: 2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

In [6]: arr5 = [1;;2;;3;;4]
Out[6]: 1×4 Matrix{Int64}:
 1  2  3  4

In [7]: arr6 = [1;;;2;;;3;;;4]
Out[7]: 1×1×4 Array{Int64, 3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

[:, :, 4] =
 4

[:, :, 2] =
 7   9  11
 8  10  12

In [8]: ndims(arr5)
Out[8]: 2

In [9]: size(arr6)
Out[9]: (1, 1, 4)

In [10]: sizeof(arr3d)
Out[10]: 96

In [11]: length(arr3d)
Out[11]: 12
```

`In [8]` 에서 `ndims()` 함수는 배열의 차원을 반환합니다. 배열의 형태는 `size()` 함수로 알 수 있습니다. `sizeof()` 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. `arr3d` 는 `Int64` 타입의 성분으로 이루어져 있으며, `Int64` 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 `length()` 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다.

</br>

## 배열의 생성 {#sec-array_initialization}

앞에서와 같이 각각 배열의 성분을 입력 할 수도 있겠지만, 배열이 클 경우는 거의 불가능한 방법입니다. Julia 는 배열을 생성하고 초기화 할 수 있는 다양한 방법을 제공합니다.

</br>

### Array comprehension 을 이용한 배열의 생성 {#sec-array_comprehension}

`[ ]` 안에 루프를 사용하여 배열을 만들 수 있으며 이렇게 배열을 만드는 것을 **Array comprehension** 이라고 합니다. 1 부터 10 까지의 정수의 제곱을 순서대로 포함하는 배열은 아래와 같이 만들 수 있습니다.

```julia
ac1 = [x^2 for x in 1:10]
```

다차원 배열도 다음과 같이 만들 수 있습니다.

```txt
In [6]: [x+y for x = 1:3, y = 1:2]
Out[6]: 3×2 Matrix{Int64}:
 2  3
 3  4
 4  5
```

`[ ]` 안에 조건을 넣을 수도 있습니다. 예를 들어 앞의 2차원 배열에서 `x+y>3` 인 경우에는 `0` 으로 채우고 싶다면,

```txt
In [7]: [if x+y > 3 0 else x+y end for x = 1:3, y = 1:2]
Out[7]: 3×2 Matrix{Int64}:
 2  3
 3  0
 0  0
```

와 같이 쓸 수 있습니다. 3항 연산자를 사용하여 다음과 같이 쓸 수도 있습니다.

```txt
In [8]: [(x+y > 3) ? 0 : x+y  for x = 1:3, y = 1:2]
Out[8]: 3×2 Matrix{Int64}:
 2  3
 3  0
 0  0
```

그런데 `if` 문이 뒤에 가면 전혀 다른 결과가 발생합니다.

```txt
In [9]: [x for x in 1:10 if x>4]
Out[9]: 6-element Vector{Int64}:
  5
  6
  7
  8
  9
 10

In [10]: [x+y for x = 1:3, y = 1:2 if x+y>3]
Out[10]: 3-element Vector{Int64}:
 4
 4
 5
```

`In[7]` 과 같이 `for` 가 `if` 뒤에 있으면, 중첩된 `for` 의 갯수에 따라 다차원 배열을 만든 후 연산을 수행합니다. 반대로 `In[9]` 나 `In [10]` 과 같이 `if` 가 `for` 의 뒤에 있다면 1차원 배열에 대해 `if` 문이 일종의 `filter` 함수 역할을 수행하며 이 `filter` 에 대해 `true` 인 경우 1차원 배열에 삽입합니다.

</br>

간단한 규칙으로 배열을 생성하는 경우 Array comprehension 을 사용하는 것이 `for` 를 이용하는 것보다 빠른 경우가 많습니다. 예를 들어 $A_{ij} = i^{j-1}$ 의 규칙으로 생성되는 배열을 두가지 방법으로 만들어 봅시다. 

```julia
# for loop
V1 = zeros(Int64,(10, 10))
for i ∈ 1:10, j ∈ 1:10
    V1[i, j] = i^(j-1)
end

# Array comprehension
V2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]
```

두 결과는 같은 결과를 냅니다. `BenchmarkTools` 패키지의 `@btime` 매크로로 수행 시간을 측정해보면

```julia
using BenchmarkTools

V1 = zeros(Int64,(10, 10))
@btime begin
for i ∈ 1:10, j ∈ 1:10
    V1[i, j] = i^(j-1)
end
end

@btime V2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]
```

두번째 경우가 첫번째 경우보다 6배 이상 빠릅니다. 하지만 배열 작성 규칙이 복잡해지고 배열의 크기가 커질수록 역전되며 array comprehenshion 에서는 복잡한 과정을 넣기 힘들기 때문에 오히려 `for` 문을 사용하는 것이 좋습니다.

</br>

### 특정 값으로만 이루어진 배열의 생성 {#sec-array_initialization_using_functions}

`zeros()`, `ones()`, `fill()` 함수가 대표적으로 배열을 초기화 하는 함수입니다. `zeros(T, dims)` 는 `T` 의 타입에서의 0 값(`zero(T)`)으로 채워진 `dims` 차원의 배열을 반환합니다. `ones(T, dims)` 은 `one(T)` 로 채워진 배열의 형상이`dims` 인 배열을 반환하며 `fill(v, dims)` 는 값 `v` 로 채워진 `dims` 형상의 배열을 반환합니다.  `T` 가 주어지지 않을 경우는 `Float64` 타입으로 정해지며 `dims` 는 1차원 배열의 경우는 정수, 다차원 배열의 경우는 튜플, 혹은 연속적인 정수입니다.  
 
```txt
In [1]: zeros(Float32, (2, 3))
Out[1]: 2×3 Matrix{Float32}:
 0.0  0.0  0.0
 0.0  0.0  0.0

In [2]: ones(UInt8, (2,2,2)) # == ones(UInt8, 2,2,2)
Out[2]: 2×2×2 Array{UInt8, 3}:
[:, :, 1] =
 0x01  0x01
 0x01  0x01

[:, :, 2] =
 0x01  0x01
 0x01  0x01

In [3]: fill(2.0, 1, 3)  # == fill(2.0, (1, 3))
Out[3]: 1×3 Matrix{Float64}:
 2.0  2.0  2.0
```

</br>

`undef` 키워드를 사용하여 타입과 크기만을 지정하고 값을 정하지 않고 초기화 할 수도 있습니다.

```julia
A1 = Vector{Int8}(undef, 4) # 1차원 배열 초기화
A2 = Matrix{Float64}(undef,10,10) # 2차원 배열 초기화
A3 = Array{Float32}(undef, 2, 2, 2) #3차원 배열 초기화
```

이 경우 배열의 성분은 임의의 값이 정해집니다. 이렇게 임의의 값이 채워진 배열을 초기화 하는 이유는 이렇게 배열을 만드는 것이 특정 값으로 채워서 초기화 하는 것보다 훨씬 빠르기 때문입니다. 제 컴퓨터에서는 `Float64` 타입의 $10000 \times 10000$ 배열을 만드는데 `zeros` 함수를 사용하는 것보다 `undef` 를 사용하는 것이 50000 배 정도 빨랐습니다. 만약 배열의 모든 성분이 이후의 계산과정에서 채워지는것이 확실하다면 굳이 특정 값으로 초기화 시키지 않고 `undef` 를 사용하여 배열을 생성하는 것이 좋습니다.

</br>

### 이미 존재하는 배열과 같은 크기의 배열 생성 {#sec-array_initialization_using_existing_array}

배열의 타입과 크기를 지정하지 않고 이미 존재하는 배열을 이용하여 초기화 할 수 있습니다. 예를 들어 어떤 배열 `A` 와 같은 크기와 타입을 갖지만 모든 성분이 0 인 배열을 만들 때 `zero(A)` 를 사용 할 수 있습니다. (`zeros(A)` 가 아닙니다) `A` 가 정사각 행렬일 경우 `one(A)` 는 `A` 와 같은 크기와 타입을 갖는 항등행렬을 리턴합니다.

```txt
In [1]: A=[1.0 -2.0 3.0;4.0 -3.0 -1.0]
Out[1]: 2×3 Matrix{Float64}:
 1.0  -2.0   3.0
 4.0  -3.0  -1.0

In [2]: zero(A)
Out[2]: 2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0

In [3]: B=[1 2;3 4]
Out[3]: 2×2 Matrix{Int64}:
 1  2
 3  4

In [4]: one(B)
Out[4]: 2×2 Matrix{Int64}:
 1  0
 0  1
```

</br>

배열을 초기화 할 때 `undef` 키워드를 사용하는 것처럼 일단 주어진 배열과 같은 크기와 타입을 갖는, 하지만 그 안에 채워지는 값을 보장하지 않는 배열을 `similar()` 함수를 통해 만들 수 있습니다. `similar()` 를 사용하는 이유도 속도 때문이며, `undef` 키워드로 배열을 만드는 것과 같이, 이후 연산으로 그 값이 다 채워진다면 충분히 사용할 만 합니다. 

```txt
In [8]: C=[1.0 3.0;2.0 -1.0]
Out[8]: 2×2 Matrix{Float64}:
 1.0   3.0
 2.0  -1.0

In [9]: similar(C)
Out[9]: 2×2 Matrix{Float64}:
 0.0           2.39288e-314
 2.39288e-314  0.0
```

</br>

### 배열을 확장하여 생성 {#sec-array_initialization_using_concatenation}

2차원 배열을 생성할 때 `[1 3;2 4]` 와 같이 열 구별은 공백을, 행 구별은 `;` 을 이용하여 생성하는 방법을 이미 알아 보았습니다. 이 방법은 스칼라 뿐만 아니라 배열을 사용 할 수도 있는데 예를 들면 

```txt
In [1]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]
Out[1]: 1-element Vector{Int64}:
 9

In [2]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]
Out[2]: 1-element Vector{Int64}:
 9

In [3]: F1=[A B]
Out[3]: 2×3 Matrix{Int64}:
 1  2  5
 3  4  6

In [4]: F2=[A;C]
Out[4]: 3×2 Matrix{Int64}:
 1  2
 3  4
 7  8

In [5]: F3=[A B;C D]
Out[5]: 3×3 Matrix{Int64}:
 1  2  5
 3  4  6
 7  8  9
```

와 같습니다. 즉 부분 행렬을 모아 더 큰 행렬을 만들 때 행 방향으로의 확장은 공백으로, 열 방향으로의 확장은 `;` 를 이용합니다. 이렇게 작은 배열을 모아 큰 배열을 만드는 것을 **concatenation** 이라고 합니다. Concatenation 을 이용할 때는 각 부분행렬의 행과 열의 갯수가 서로 잘 맞도록 해줘야 합니다. `[A B; C D]` 형태로 concatenation 을 할 때는 `A` 와 `B` 의 행의 갯수가 같아야 하며 `A` 와 `C` 의 열의 갯수가 같아야 하고 `B` 의 열의 갯수와 `D` 의 열의 갯수도 같아야 하며 `C` 와 `D` 의 행의 갯수가 같아야 합니다. 복잡하게 설명했지만 결국 크기가 다른 타일을 빈 틈 없이 맞추는 경우로 생각할 수 있겠습니다.

Concatenation 을 해 주는 함수로는 `cat`, `vcat`, `hcat`, `hvcat`, `hvncat` 이 있습니다.

```txt
In [1]: A=[1 2;3 4];B=[5 6;7 8];C=[-1 -2; -3 -4];

In [2]: vcat(A, B)
Out[2]: 4×2 Matrix{Int64}:
 1  2
 3  4
 5  6
 7  8

In [3]: hcat(A, B, C)
Out[3]: 2×6 Matrix{Int64}:
 1  2  5  6  -1  -2
 3  4  7  8  -3  -4

In [4]: hvcat((2, 3), [1 2;3 4], [-1;-2], [5; 6], [7;8], [9;10])
Out[4]: 4×3 Matrix{Int64}:
 1  2  -1
 3  4  -2
 5  7   9
 6  8  10

In [5]: [[1 2;3 4] [-1;-2] ; [5; 6] [7;8] [9;10]]
Out[5]: 4×3 Matrix{Int64}:
 1  2  -1
 3  4  -2
 5  7   9
 6  8  10

In [6]: hvcat(2, [1 2;3 4], [5;6])
Out[6]: 2×3 Matrix{Int64}:
 1  2  5
 3  4  6
```

`vcat(A, B)` 는 `[A; B]` 와 같으며 `hcat(A, B)` 는 `[A B]` 와 같습니다. 즉 `vcat` 은 배열을 수직으로 위에서 아래로 쌓으며, `hcat` 은 왼쪽에서 오른쪽으로 쌓습니다. `vcat` 이나 `hcat` 의 인자로는 다수의 배열 혹은 숫자가 올 수 있습니다. `hvcat` 은 인자로서 처음에 정수 혹은 정수의 터플이 오며, 그 다음부터 다수의 배열이 위치합니다. `In [4]` 의 `hcat` 함수의 첫번째 인자 `(2, 3)` 는 첫번째 블록열은 2개의 행렬로, 두번째 블록열은 그 다음 세개의 행렬로 이루어진다는 것을 의미합니다. 즉 `[1 2;3 4], [-1;-2]` 가 첫번째 열을 이루고, ` [5; 6], [7;8], [9;10]` 가 두번째 열을 이룹니다. 따라서 `In [5]` 와 같습니다. `hvcat` 의 첫번째 인자로 정수만 있을 때는 첫번째 블록열로만 이루어집니다.


`cat` 함수는 좀 많이 복잡합니다. 우리는 여기서는 1차원과 2차원 배열에 대해서만 다루겠습니다. 우선 `cat` 함수의 시그너쳐는 다음과 같습니다.

```julia
cat(A...; dims)
```

`dims` 는 자연수, 혹은 자연수의 터플이 올 수 있습니다. Julia 1.8 부터는 `Val{x}` 타입도 가능하지만 여기서는 다루지 않겠습니다. 자연수가 올 때는 그 차원 방향으로 확장합니다.

```txt
In [1]: cat(1, [2;3], dims=1)
Out[1]: 3-element Vector{Int64}:
 1
 2
 3

In [2]: cat([1;2], [3;4], dims=2)
Out[2]: 2×2 Matrix{Int64}:
 1  3
 2  4
```


`dims` 에 자연수의 컨테이너가 올 때는 마치 블록 대각 행렬을 만드는 것 처럼 확장됩니다. 다음을 봅시다.

```txt
In [3]: cat(1, [2;3], [4 5; 6 7], dims=(1, 2))
Out[3]: 5×4 Matrix{Int64}:
 1  0  0  0
 0  2  0  0
 0  3  0  0
 0  0  4  5
 0  0  6  7
```

`dims=(1, 2)` 이므로 첫번째 차원(수직) 과 두번째 차원 (수평) 으로 확장되며 주어진 배열 (스칼라는 0차원 배열로 간주됩니다) 대각으로 놓게 됩니다. 

</br>

## 배열의 인덱스 {#sec-index_of_array}

프로그래밍 언어에서 배열을 다룰 때 첫번째 인덱스가 `0` 인 언어가 있으며(C/C++, Java, Python, Javascript 등), `1` 인 언어(Fortran, Matlab, R 등) 가 있습니다. Julia는 1부터 시작합니다. `end` 는 각 차원의 마지막 인덱스를 의미하는 키워드입니다. 물론 배열의 차원과 형태를 알고 있다면 인덱스를 직접 써도 됩니다. 

```txt
In [1]: A = [1 4 7 10;2 5 8 11;3 6 9 12] 
Out[1]: 3×4 Matrix{Int64}:
 1  4  7  10
 2  5  8  11
 3  6  9  12

In [2]: A[1, 1] # a의 1 행 1열
Out[2]: 1

In [3]: A[2, end] # a의 2 행 마지막 열
Out[3]: 11

In [4]: A[end, end] # a 의 마지막 행 마지막 열
Out[4]: 12
```

</br>

### 인덱스를 이용한 배열 연산

인덱스의 범위를 지정할 수도 있습니다. 전체 볌위는 `:` 로 표기하며, 벡터나 튜플, StepRange 를 사용하여 선택적으로 지정할 수도 있습니다. 

```txt
In [5]: A[:, 1]   # 전체 행, 1 열
Out[5]: 3-element Vector{Int64}:
 1
 2
 3

In [6]: A[2, 1:2:end]  # 2행 의 1열부터 끝열까지 2열 간격으로
Out[6]: 2-element Vector{Int64}:
 2
 8

In [7]: A[3, [2, 3]] # 3행 의 2열과 3열
Out[7]: 2-element Vector{Int64}:
 6
 9
```

</br>

`B=A[:, 1]` 라고 하면  `B` 는 `A` 의 1 행과 같은 값을 갖는 벡터이며 `A` 의 1행이 아닙니다. 즉 `B=A[:, 1]` 을 수행하고 `B` 벡터의 성분을 바꾼다고 해도 `A` 가 변하지 않습니다. 이에 대해서는 [배열의 복사](#sec-copy_of_array) 와 [`view` 와 `@view`](#sec-array_view) 를 참고하시기 바랍니다.

```txt
In [9]: B=A[:, 1]
Out[9]: 3-element Vector{Int64}:
 1
 2
 3

In [10]: B[2]=-3
Out[10]: -3

In [11]: A
Out[11]: 3×4 Matrix{Int64}:
 1  4  7  10
 2  5  8  11
 3  6  9  12

In [12]: B
Out[12]: 3-element Vector{Int64}:
  1
 -3
  3
```

</br>

### 행렬의 열/행 우선 방식 {#sec-majority_of_index}

예를 들어 $\boldsymbol{A} =\begin{bmatrix} 1&2\\3&4\end{bmatrix}$ 를 메모리상에 저장할 때 1행 1열, 1행 2열,... 1행 마지막열, 2행 1열, ... 순으로 저장하는 것을 행 우선 순서(row-major order) 라고 하고 1행 1열 2행 1열,..., 마지막행 1열, 2행 1열, 2행 2열,...  순으로 저장하는 것을 열 우선 방식(column-major order)이라고 합니다. 행 우선 방식에서는 배열 `A` 가 `1 2 3 4` 의 순으로 저장이 되며 열 우선방식에서는 `1 3 2 4` 순으로 저장이 됩니다.  행 우선 방식을 쓰는 언어로는 C/C++ 과 Python 의 numpy 가 있고 열 우선 방식을 쓰는 언어로는 Fortran, MATLAB, Julia, R 등이 있습니다. 또한 언어에서 사용하는 자료구조나 함수에 따라 달라질 수 있습니다.

::: {.callout-warning}

이것이 문제가 될 수 있는 경우는 우선순위가 다른 언어나 라이브러리간에 데이터를 교환 할 때 입니다. 예를 들어 julia 의 배열을 파일로 저장 한 후 python 의 numpy 로 읽으면 행과 열이 바뀔 수 있습니다. 

:::

열/행 우선 방식이 본질적으로 동일한 계산의 계산 속도에 영향을 줄 수 있습니다. 아래의 코드는 $10000 \times 10000$ 배열의 합을 두가지 방법으로 구하는 코드입니다. 우선 각 행에대헤 열을 순회하며 합을 구하였고, 그 다음은 각 열에 대해 행을 순회하며 합을 구하였습니다.

```julia
using BenchmarkTools
M = 10000
mat= rand(M, M)

@btime begin
    r1  =0.0
    for i ∈ 1:M, j ∈ 1:M
        r1 += mat[i, j]
    end
end

@btime begin
    r2 =  0.0
    for j ∈ 1:M, i ∈ 1:M
        r2 += mat[i, j]
    end
end
```

그 결과는 

```txt
  13.454 s (489818979 allocations: 8.79 GiB)
  8.744 s (489818979 allocations: 8.79 GiB)
```

로 아래의 방법이 훨씬 빨랐습니다. 이것은 julia 에서는 배열이 열 우선방식으로 정렬되기 때문이며, 행보다 열을 많이 변화시키는 것이 전체적으로 더 빠릅니다. 같은 열에서 다음 행으로 넘어갈 때는 바로 다음칸으로 넘어가면 되지만, 같은 행에서 다음 열로 넘어갈 때 열의 갯수 +1 만큼 넘어가야 하기 때문입니다. 예를 들어 첫번째 합 계산의 경우, 행이 10000 번 변할 동안 열은 1억번 변하는데, 두번째 계산의 경우는 열이 10000 번 변할 동안 행이 1억번 변합니다. 이 차이가 계산 속도의 차이를 만들어 냅니다.

</br>

### 데카르트 인덱스와 선형 인덱스 {#sec-cartesian_and_linear_index}

지금까지 2차원 배열`A` 의 2행 3열 성분을 `A[2, 3]` 으로 접근했습니다. 이와 같이 배열의 차원의 갯수만큼의 자연수로 접근하는 것을 **데카르트 인덱스(Cartesian index)** 혹은 **카르테시안 인덱스** 라고 합니다.[프랑스의 철학자이자 과학자인 르네 데카르트(René Descartes) 의 이름에서 따왔습니다. 데카르트의 라틴어명이 Renatus Cartesius 이기 때문에 영어로는 Cartesian index 라고 씁니다.]{.aside} 다른 접근 방법도 있는데, 다차원 배열의 각 성분을 1부터 하나의 자연수로 접근하는 방법도 사용합니다. 이것을 **선형 인덱스(linear index)** 라고 합니다. 앞서 알아본 열 우선 방식에서 배열을 나열할 때의 차례입니다. 예를 들어 `A=[1 3;2 4]` 의 경우 `A[3]=3` 이며 `A[4]=4` 입니다. 

```txt
In [13]: A=[1 2;3 4]
Out[13]: 2×2 Matrix{Int64}:
 1  2
 3  4

In [14]: A[3]
Out[14]: 2
```

데카르트 인덱스로부터 선형 인덱스를, 선형 인덱스로부터 데카르트 인덱스르 얻는 방법이 존재합니다. 배열 `A` 에 대해 `CartesianIndices(A)[10]` 은 배열 `A` 의 선형 인덱스 `10` 에 대한 데카르트 인덱스를 리턴합니다. `A` 가 삼차원 배열일 경우 `LinearIndices(A)[1, 2, 3]` 은 배열 `A` 의 데카르트 인덱스`(1, 2, 3)` 에 대한 선형 인덱스를 리턴합니다. 고차원 배열에대해서도 차원의 갯수만큼의 데카르트 인덱스를 받아 선형 인덱스를 리턴합니다.

```txt
In [1]: A=Array(reshape(1:2*3*4, (2, 3, 4)))
Out[1]: 2×3×4 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12

[:, :, 3] =
 13  15  17
 14  16  18

[:, :, 4] =
 19  21  23
 20  22  24

In [2]: CartesianIndices(A)[10]
Out[2]: CartesianIndex(2, 2, 2)

In [3]: LinearIndices(A)[1, 2, 3]
Out[3]: 15
```

</br>

## 배열의 복사 {#sec-copy_of_array}

배열을 복사할 때는 `copy()` 혹은 `deepcopy()` 명령어를 사용합니다. 주의해야 할 것은 배열 `A` 에 대해 `B=A` 와 `B=copy(A)` 는 다르다는 것입니다. 아래 코드를 봅시다.

```txt
In [13]: A=[1 2]
Out[13]: 1×2 Matrix{Int64}:
 1  2

In [14]: B=A;C=copy(A)
Out[14]: 1×2 Matrix{Int64}:
 1  2

In [15]: B[1, 1]=3
Out[15]: 3

In [16]: A
Out[16]: 1×2 Matrix{Int64}:
 3  2

In [17]: C
Out[17]: 1×2 Matrix{Int64}:
 1  2

In [18]: C[1, 2]=-1
Out[18]: -1

In [19]: A
Out[19]: 1×2 Matrix{Int64}:
 3  2
```

`B=A` 라는 표현식은 `B` 와 `A` 변수가 같은 행렬에 대한 변수라는 뜻입니다. 따라서 `B` 라는 변수를 이용해 행렬 값을 변화시키면 `A` 변수로 접근하더더라도 변화된 행렬에 접근하게 됩니다. `B=copy(A)` 는 `A` 복사본을 만들어 `B` 라는 변수에 지정합니다. 따라서 `B` 변수를 이용해 행렬을 바꾸더라도 `A` 변수에 지정된 행렬은 변화하지 않습니다. `B=A[:]` 는 `B=A` 가 아닌 `copy(A)` 를 의미합니다. 

객체를 복사하는 `deepcopy()` 함수 가 있습니다. 다음 예를 봅시다.

```txt
In [1]: A = [1, 2, 3, [4, 5, 6]]
Out[1]: 4-element Vector{Any}:
 1
 2
 3
  [4, 5, 6]

In [2]: B = A[:]; C=copy(A); D=deepcopy(A);

In [3]: A[4][2]=-1
Out[3]: -1

In [4]: B
Out[4]: 4-element Vector{Any}:
 1
 2
 3
  [4, -1, 6]

In [5]: C
Out[5]: 4-element Vector{Any}:
 1
 2
 3
  [4, -1, 6]

In [6]: D
Out[6]: 4-element Vector{Any}:
 1
 2
 3
  [4, 5, 6]
```

`A = [1, 2, 3, [4, 5, 6]]` 는 벡터이며 정수와 벡터를 성분으로 갖기 때문에 `Any` 타입에 대한 벡터가 됩니다. `A` 의 네번째 성분은 벡터이며 실제로 `A` 변수에 내부적으로 저장되는것은 벡터 `[4, 5, 6]` 에 대한 주소입니다. `C=copy(A)` 명령어는 값 1, 2, 3 과 벡터 `[4, 5, 6]` 의 복사본을 만들지 않고 단지 주소만을 복사하여 변수 `C` 에 할당합니다. `deepcopy` 함수는 벡터 `[4, 5, 6]` 에 대해서도 복사본을 만들기 때문에 `D=deepcopy(A)` 명령어로 `D` 에 할당된 배열은 `A` 와는 같은 값을 갖는 완전히 별개인 배열이 됩니다.   

</br>

## 배열에 대한 함수

### 인덱스 순회에 대한 함수들 : `eachindex`, `CartesianIndex`


배열의 인덱스, 혹은 성분 각각에 대해 `for ... end` 루프를 수행하는 방법은 여러가지가 있습니다. 배열의 선형 인덱스를 이용하여 순회할 때는 `eachindex` 를 씁니다.

```txt
In [1]: A = [1 2; 3 4];

In [2]: for i in eachindex(A)
        @show i, A[i]
        end
(i, A[i]) = (1, 1)
(i, A[i]) = (2, 3)
(i, A[i]) = (3, 2)
(i, A[i]) = (4, 4)

In [3]: for i in CartesianIndices(A)
        @show i, A[i]
        end
(i, A[i]) = (CartesianIndex(1, 1), 1)
(i, A[i]) = (CartesianIndex(2, 1), 3)
(i, A[i]) = (CartesianIndex(1, 2), 2)
(i, A[i]) = (CartesianIndex(2, 2), 4)
```

위에서 알 수 있듯이 `eachindex(A)` 는 배열 `A` 에 대한 선형 인덱스를 사용하여 순회하도록 하며 `CartesianIndices(A)` 는 데카르트 인덱스를 이용하여 순회합니다. 

</br>

### 타입과 모양의 변환

우리는 앞서 타입이름이 타입 변환함수로 사용될 수 있다는 것을 보았습니다. 예를 들어 `Float32(6)` 은 `Int64` 타입의 `6` 을 4바이트 부동소수 타입인 `Float32` 타입으로 변환시킵니다. 또한 우리는 `.` 연산자를 통해 컨테이너의 각각의 성분에 대해 함수를 적용시킬 수 있다는 것을 알았습니다. 따라서 `Float32.([1, 2, 3, 4])` 는 `Float32` 타입의 성분을 갖는 `[1.0f0, 2.0f0, 3.0f0, 4.0f0]` 입니다.


$3\times 5$ 배열을 $5 \times 3$ 배열로 바꾸거나 $12 \times 5$ 배열을 $3\times 4 \times 5$ 로 바꾸는 것과 같이 그 크기를 유지하지만 배열의 모양을 바꾸는 함수는 `reshape` 입니다. 예를 들어 보겠습니다.

```txt
In [1]: A = Array(1:6)
Out[1]: 6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6

In [2]: reshape(A, (2, 3))
Out[2]: 2×3 Matrix{Int64}:
 1  3  5
 2  4  6
 ```

`In[1]` 에서의 `A` 는 6개의 성분을 갖는 1차원 벡터였지만 `reshape(A, (2, 3))` 를 통해 $2 \times 3$ 행렬이 되었습니다. 다시 말하지만 원래의 행렬과 변환된 행렬의 총 성분 수는 같아야 합니다. 즉 `length` 가 같아야 합니다. `reshape` 는 원래 행렬과 변환 행렬의 선형 인덱스가 같도록 변환됩니다.

</br>

### `view` 와 `@view` {#sec-array_view}

`view` 는 이미 존재하는 배열로부터 특정 부분을 추출하여 만든 배열에 대한 타입이며, 이런 연산을 하는 함수이기도 합니다. 배열 `A` 에 대해 `a=view(A, 1)` 은 배열 `A` 의 첫번째 성분을 가리킵니다. 가리킨다라고 표현한 것은 단지 같은 값을 가질 뿐만 아니라 `a` 를 변경시키면 `A` 도 변경되기 때문입니다. 

```txt
In [4]: A= [1 2;3 4];

In [5]: a = view(A, 1)
Out[5]: 0-dimensional view(::Vector{Int64}, 1) with eltype Int64:
1

In [6]: a[1]=3;

In [7]: A
Out[7]: 2×2 Matrix{Int64}:
 3  2
 3  4
```

다차원 배열의 경우 인덱스를 쓰거나 `:` 나 배열을 이용하여 범위를 특정 할 수 있습니다.

```txt
In [8]: B=reshape(Array(1:12), (3, 4))
Out[8]: 3×4 Matrix{Int64}:
 1  4  7  10
 2  5  8  11
 3  6  9  12

In [9]: b=view(B, [1, 3], :)  # 1행과 3행, 그리고 열 전체에 대한 view
Out[9]: 2×4 view(::Matrix{Int64}, [1, 3], :) with eltype Int64:
 1  4  7  10
 3  6  9  12

In [10]: b[2, 2]=-6 # view 의 변경
Out[10]: -6

In [11]: B
Out[11]: 3×4 Matrix{Int64}:
 1   4  7  10
 2   5  8  11
 3  -6  9  12
```

앞서 `B[:, 3]` 과 같이 이미 존재하는 배열로부터 그 부분을 성분으로 갖는 배열을 생성하는 방법을 보았습니다. `@view` 매크로는 `view` 함수를 쓰지 않고 `B[:, 3]` 과 같은 방법으로 `view` 를 생성합니다. [매크로에 대해서는 [메타프로그래밍과 매크로](10_metaprogramming_and_macro.qmd) 를 참고하시기 바랍니다. 일단은 `@` 로 시작하는 명령문은 매크로 라고 하며 명령문 뒤에 주어진 인자나 함수에 대한 특별한 기능을 한다는 정도만 알아 둡시다]{.aside}

```txt
In [21]: B=reshape(Array(1:12), (3, 4))
Out[21]: 3×4 Matrix{Int64}:
 1  4  7  10
 2  5  8  11
 3  6  9  12

In [22]: B[:, [2, 3]]
Out[22]: 3×2 Matrix{Int64}:
 4  7
 5  8
 6  9

In [23]: @view B[:, [2, 3]]
Out[23]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:
 4  7
 5  8
 6  9
```

`B[:, [2, 3]]` 은 `B` 의 2행과 3행만을 선택하여 새로운 배열을 만들기 때문에, 일단 만든 다음에는 원래의 `B` 값과 무관하게 변경시킬 수 있습니다. `@view B[:, [2, 3]]` 는 `B` 의 부분에 대한 `view` 를 만들기 때문에 `C=@view B[:, [2, 3]]` 를 통해 `C` 에 할당한다면 `C` 를 변경하는 것은 `B` 를 변경하는 것이 됩니다.

```txt
In [24]: C=@view B[:, [2, 3]]
Out[24]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:
 4  7
 5  8
 6  9

In [25]: C[1, 1]=-1;

In [26]: B
Out[26]: 3×4 Matrix{Int64}:
 1  -1  7  10
 2   5  8  11
 3   6  9  12
```

`view` 나 `@view` 가 필요한 이유는 메모리와 시간을 절약해 주기 때문입니다. 아주 큰 배열을 다룰 때 그 부분 배열에 대해 연산이 필요하다고 합시다. 배열을 새로 생성한다면 그만큼의 메모리와 배열의 생성과 복사를 위한 시간이 필요하지만 `view` 를 사용한다면 이미 존재하는 배열을 사용하기 때문에 약간의 메모리에서의 빈 공간만으로 연산을 수행 할 수 있습니다. 다만 `view` 나 `@view` 를 이용해 얻은 부분배열을 변경할 경우 원래의 배열도 변경된다는 사실을 명심해야 합니다.


</br>

### 다차원 배열에서의 도트연산 {#sec-dot_operation_in_array}

앞서 [컨테이너](04_containers.qmd) 에서 도트 연산, 즉 연산자 앞이나 함수 뒤에 `.` 를 붙여 성분별 연산을 수행하는 것을 다루었습니다. 다차원 배열의 경우 차원이 같으면(즉 차원의 갯수와, 각 차원별 원소의 갯수가 같으면) 도트 연산을 수행할 수 있지만 차원이 다를 경우에는 차원을 확장하여 수행합니다.

- 도트 연산에서의 차원 확장은 그 차원이 정의되어 있지 않거나 차원의 성분의 갯수가 1개 일때만 이루어집니다. 즉 `[1 2] .+ [1 2; 3 4]` 나 `[1 2;] .+ [1 2; 3 4]`는 가능하지만 `[1 2;3 4] .+ [1 2 3; 2 3 4]` 는 에러를 발생시킵니다. 

- 차원 확장은 차원이 없거나 1차원인 차원으로 원래의 배열을 반복합니다. `[1 2] .+ [1 2; 3 4]` 의 경우는 `[1 2]` 를 배열로 변환시킬 때 $1 \times 2$ 배열이 되며 첫번째 차원이 하나의 성분을 가지므로 첫번째 차원에 대해 두번 반복한 `[1 2;1 2]` 와 `[1 2;3 4]` 의 연산을 수행하게 됩니다.

- 따라서 스칼라나 영차원 배열은 모든 차원의 다차원 배열에 대해 도트 연산이 가능합니다.

```txt
In [1]: [1;;2] .+ [1 2;3 4]
Out[1]: 2×2 Matrix{Int64}:
 2  4
 4  6

In [2]: [1; 2] .+ [1 2;3 4]
Out[2]: 2×2 Matrix{Int64}:
 2  3
 5  6

In [3]: [3] .* [1 2; 3 4]
Out[3]: 2×2 Matrix{Int64}:
 3   6
 9  12
```

`[1;;2]` 는 $1 \times 2$ 배열이므로 $2 \times 2$ 배열과 연산할 때는 `[1 2; 1 2]` 로 바뀌어 연산됩니다. `[1 ; 2]` 는 $2 \times 1$  배열이므로 $2 \times 2$ 배열과 연산할 때는 `[1 1; 2 2]` 로 바뀌어 연산됩니다. 

컨테이너에서의 도트 연산과 같이 `@.` 매크로도 동작합니다. `@.` 매크로를 앞에 붙이면 뒤에 나오는 함수나 연산자에 `.` 를 붙이지 않아도 julia 가 알아서 연산을 해 줍니다.


</br>


### `broadcast`

`broadcast(f, As...)` 함수는 하나 이상의 값 혹은 컨테이너인 `As...` 에 함수 혹은 연산자 `f` 를 적용합니다. `map` 함수와 같은것이라고 생각 할 수 있지만, 실제로는 julia 에서 차원과 크기가 다른 컨테이너에 함수를 적용할 때는 이 함수가 기본이 되기 때문에 다차원 배열의 연산을 이해하기 위해서는 이 함수를 이해해야 합니다. 

- `f` 를 제외한 인자가 스칼라나 0차원 배열일 경우 스칼라를 반환합니다.
- `f` 를 제외한 인자에 튜플이 포함되며, 튜플을 제외한 나머지 인자가 스칼라이면 튜플을 반환합니다.
- `f` 를 제외한 인자가 위의 두 경우와 다르다면 배열을 반환합니다. 
- `f` 를 제외한 인자가 배열이나 스칼라라면 위의 도트 연산시의 차원 확장 규칙에 따라 차원을 확장하여 [도트 연산](04_containers.qmd#sec-dot_operation)으로 계산합니다.

```txt
In [1]: broadcast(+, 2, 3)
Out[1]: 5

In [2]: ones()
Out[2]: 0-dimensional Array{Float64, 0}:
1.0

In [3]: broadcast(+, 1, ones())
Out[3]: 2.0

In [4]: broadcast(*, 2, (1, 2, 3))
Out[4]: (2, 4, 6)

In [5]: broadcast(*, (1, 2, 3), [-1, 1, 0])
Out[5]: 3-element Vector{Int64}:
 -1
  2
  0
In [6]: broadcast(sin, range(0, π, length = 5))
Out[6]: 5-element Vector{Float64}:
 0.0
 0.7071067811865475
 1.0
 0.7071067811865476
 1.2246467991473532e-16
```

크기가 다른 배열의 경우 [다차원 배열의 도트 연산](#sec-dot_operation_in_array) 과 같은 규칙으로 계산됩니다. 실제로는 도트 연산의 자체가 `broadcast` 함수를 사용하여 정의되었으므로 당연한 것입니다.

</br>
