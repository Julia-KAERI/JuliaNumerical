# Interude : 문서화 {.unnumbered}


함수나 연산자에 대해 알고 싶을 때 도움말은 다음과 같이 사용 할 수 있다.

- Julia REPL : `?` 를 쳐 들어가는 `help?` 프롬프트에 함수 이름 등을 입력하고 엔터를 누른다.
- Jupyter Notebook/Lab : 입력 셀에 `?` 이후 함수 이름등을 입력하고 실행시킨다.
- vscode notebook : 입력 셀에 함수 이름 등을 입력하고 마우스 포인터를 위로 이동시킨다.

여기서 보이는 도움말은 별도의 문서가 있는 것이 아니라 해당 함수나 뒤에 나올 복합타입 등의 위에 세겹 따옴표 `"""` 를 사용하여 표기한다. 예를 들어 다음을 `doctest01.jl` 로 저장해 보자.


~~~julia
"""
    bps(a::Number) 

`a` 에 2를 곱한다.

# Example

```julia-repl
julia> bps([1 2;3 4])

2×2 Matrix{Int64}:
 2  4
 6  8
```
"""
function bps(a::Number) 
    return a*2
end
~~~


julia REPL 이나 jupyter 노트북에서는 

```julia
include("doctest01.jl")
```

를 이용하여 파일을 포함하면 각각의 방법을 통해 `bps` 에 대한 도움말을 볼 수 있습니다. vscode 에서는 2023년 8월 현재 단순히 `include` 를 통해 포함시킨 julia 함수에 대한 도움말을 볼 수는 없는 것 같습니다.


함수 혹은 객체에 대한 도움말을 작성 할 때 julia 언어에서 권고하는 몇가지 방침이 있습니다. 여기에 공식 문서 [Documentations](https://docs.julialang.org/en/v1/manual/documentation/) 의 지침을 요약하여 설명합니다. 영어를 기준으로 기술되었기 때문에 한국어와는 잘 안맞을 수도 있습니다.

1. [Julia 마크다운(markdown)](https://docs.julialang.org/en/v1/stdlib/Markdown/) 문법으로 작성합니다.
    - Julia 의 마크다운은 일반적인 마크다운과 약간 다릅니다. 예를 들어 일반적인 마크다운에서 문장내 수식이 `$\sin x$` 형식으로 가능하지만 julia 마크다운에서는 문장 내 수식이 불가능하며 코드블럭을 이용하여 다음과 같이 사용합니다.

~~~markdown
```math
f(a) = \frac{1}{2\pi}\int_{0}^{2\pi} (\alpha+R\cos(\theta))d\theta
```
```
~~~
   
2. 4개의 공백으로 들여쓰기를 한후 함수의 시그너쳐를 표현합니다.
   - 기본적으로 함수 정의의 시그너쳐를 그대로 쓰지만 시그너쳐가 너무 길 경우 인자의 타입을 생략하는 등의 간략화도 가능합니다.
   - 기본값이 정해진 선택적 인자는 그 기본값도 표시합니다. `func(x, y=1)` 과 같이 표현합니다. 
   - 기본값이 없는 선택적 인자는 `[ ]` 안에 표현합니다. `func(x, [y])` 나 `func(x[, y[, z]])` 와 같이 표현합니다. 혹은 각각의 경우에 대해 별도의 문단에서 설명 할 수 있습니다.
   - 키워드 인자를 받는 함수의 경우 키워드 인자의 갯수가 많으면 `func(x; <keyword arguments>)` 와 같이 쓰고 뒤에 별도로 셜명합니다.

3. 시그너쳐 아랫줄의 설명은 함수가 어떤 기능을 하는지 한 문장으로 짧게 설명하는 것으로 시작합니다. 이 한문장 설명 이후  두번째 문장부터는 필요하다면 상세히 설명합니다.
   - 첫번째 한문장으로 설명하는 문장은 명령문 혹은 지시문의 형태를 사용하며 함수를 주어로 하는 3인칭을 사용하지 않으며 마침표로 끝납니다.
   - 함수의 의미를 간단 명료하게 요약하기 힘들 경우, 각각의 분야에 대해 자세하며 전체적으로는 일관된 기술로 대신 할 수 있습니다.
  

3. 반복은 피하십시요.
   - 예를 들어 첫줄의 함수 시그너쳐 부분에 함수 이름이 있기 때문에 다음에 나오는 한문장 설명이 `bps 함수는` 으로 시작될 필요가 없습니다. 또한 인자 유형이 시그너쳐에 표현될 경우 굳이 그것을 다시 설명할 필요도 없습니다.
  
4. 꼭 필요할 경우에만 인자들의 목록을 제시합니다.
   - 간단한 함수의 경우는 인자들의 역할만 기술합니다.
   - 키워드 인자가 많은 경우와 같이 함수 시그너쳐가 복잡할 경우는 인자들의 목록을 제시하는 것이 오히려 나을 경우가 있습니다.

5. 관련된 함수에 대한 정보를 제공합니다.
    - `sin` 함수에 대한 도움말에 
    
    ```md
    See also [`sind`](@ref), [`sinpi`](@ref), [`sincos`](@ref), [`cis`](@ref), [`asin`](@ref).
    ```` 
    
    라고 쓰인 것처럼 하면 됩니다.

6. `# Example` 절에 예를 들어 줍니다. 마크다운 문법에서 코드블럭은 ` ```jldoctetst` 로 시작해서 ` ``` ` 로 끝납니다.

~~~md
"""
Some nice documentation here.

# Examples
```jldoctest
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
"""
~~~


`# Examples` 섹션은 패키지가 제대로 설치되었는지 확인할 수 있는 간단한 코드를 넣습니다. 가능하면 julia REPL 에서 실행하는 코드를 넣는것이 좋습니다. 임의의 수를 생성하는 `rand` 함수 같은 것은 실행할 때 마다 결과가 다를 수 있기 때문에 꼭 필요한 경우가 아니라면 사용하지 않는 것이 좋습니다. 

</br>

물론 이 원칙이 항상 적용되는 것도 아니며, 많은 유명한 패키지들도 이런 원칙을 다 지키는 것은 아니지만 이런 것들을 따르는 것이 도움이 됩니다.


