---
title: "변수와 기본 타입"

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

## 변수

### 변수 할당

많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 `=` 기호를 사용합니다. `a` 문자에 `3` 이라는 값을 값을 할당하고, 거기에 `2` 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 `=` 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.

```txt
In [1]: a=3
Out[1]: 2
```

수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.

```txt
In [2]: a*2
Out[2]: 6

In [3]: abs(a)
Out[3]: 3
```

변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 `sin(x)` 은 짐작 할 수 있듯이 `x` 에 대한 `sin` 함수값을 반환하는 함수입니다. 그런데 `myfunc = sin` 하면 어떻게 될까요?

```txt
In [1]: myfunc = sin
Out[1]: sin (generic function with 14 methods)

In [2]: myfunc(π)
Out[2]: 0.0

In [3]: myfunc(2π)
Out[3]: -2.4492935982947064e-16
```

`myfunc` 가 `sin` 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.


</br>

### 변수 이름 규칙

변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(`A-Z`) 혹은 소문자(`a-z`) 나 밑줄 `_` 혹은 `00A0` 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. [유니코드 및 수학 기호 지원](01_julia_language.qmd#sec-unicode_support) 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 [Variables](https://docs.julialang.org/en/v1/manual/variables/) 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 `!` 나 숫자가 올 수 있습니다. 

```txt
In [4]: 파이 = π
Out[4]: π = 3.1415926535897...

In [5]: 2*파이
Out[5]: 6.283185307179586

In [6]: 맑뚫 = 3; 맑뚫*3
Out[6]: 9
```

</br>

앞서 [유니코드 및 수학 기호 지원](01_julia_language.qmd#sec-unicode_support) 에서 언급했듯이 `π` 나 `ℯ` 는 이미 값이 지정되어 있습니다. 그 외의 `θ`(`\theta` + [tab]), `φ`(`\varphi` + [tab]), `ϕ`(`\phi` + [tab]), `Γ`(`\Gamma` + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다. 

```txt
In [1]: θ = π/4; cos(θ)
Out[1]: 0.7071067811865476
```
 

</br>

## 기본적인 수 타입 {#sec-primary_number_types}


수(number) 를 포함하는 julia 에서 사용하는 모든 값(value) 은 타입(type) 을 갖습니다. 여기서는 julia 언어 자체에서 정의된 기본 타입 가운데 수(number) 에 관련된 타입은 아래와 같습니다.

| 타입 종류 | 타입들 | 
|:--:|:------|
| 부호 없는 정수 타입 | `UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt128` |
| 정수 타입 | `Int8`, `Int16`, `Int32`, `Int64`, `Int128`, `BigInt` |
| 유리수 타입 | `Rational` |
| 부동소수 타입 | `Float16`, `Float32`, `Float64`, `BigFloat` |
| 무리수 타입 | `Irrational` |
| 복소수 타입 | `Complex` |
| 불 타입 | `Bool`|

- 부호 없는 정수는 0 과 양의 정수를 말합니다.
  
- 앞서 언급한 `π` ($\pi$, 원주율) 나 `ℯ` ($e$, 자연로그의 밑) 는 무리수 타입으로, 연산할 때 가장 적절한 타입으로 변환되어 계산됩니다. 

- 타입 이름은 다른 타입의 값을 타입으로 변환시키는 함수처럼 사용 할 수 있습니다. `Float64(1)` 은 `1` 을 `Float64` 타입으로 변환시킵니다.

- 실제 Julia 의 타입 구조는 이보다 훨씬 복잡합니다. 이후 [타입 계층 구조](08_type_hierarchy.qmd#sec-type_hierarchy) 에서 좀 더 자세히 설명하도록 하겠습니다.

</br>

어떤 변수나 값의 타입을 알기 위해서는 `typeof()` 함수를 사용 할 수 있습니다.

```julia
In [4]: typeof(UInt8(2))
Out[4]: UInt8
```

</br>

### 정수형 타입 {#sec-integer_types}

우선 부호 없는 정수타입, 정수타입, 부동소수 타입의 이름의 끝부분에 붙는 `8`, `16`, `32`, `64`, `128` 은 각 타입의 값이 차지하는 비트(bit) 수 입니다. 비트는 on/off 혹은 0/1 로 구분되는 정보 단위입니다.  예를 들어 `UInt8` 의 경우는 8개의 비트로 수를 표현합니다. 2진수로 `00000000` 은 `0` 이며 2진수 `11111111` 은 `255` 입니다. `UInt8` 은 이렇게 0 부터 255 까지의 값을 표현 할 수 있습니다. `UInt64` 는 64 개의 비트로 숫자를 저장하며, 따라서 0부터 2<sup>64</sup>-1 까지의 숫자를 표현 할 수 있습니다.

`Int8` 의 경우는 8비트로 정수를 저장하지만 한 비트는 음수/양수 를 구분하기 위해 사용됩니다. -128 부터 127 까지의 정수를 표현 할 수 있습니다. `Int64` 는 -2<sup>32</sup> 부터 2<sup>32</sup>-1 까지의 숫자를 표현 할 수 있습니다.


| 타입	| 부호 |	비트수 | 최소값 |	최대값 |
|:----:|:--:|:---:|:-----:|:------:|
| `Int8` | o | 8 | -2<sup>7</sup> | 2<sup>7</sup> - 1 |
| `UInt8` | x |  8 | 0 |2<sup>8</sup> - 1 |
| `Int16` | o  |  16 |	-2<sup>15</sup> | 2<sup>15</sup> - 1 |
| `UInt16` | x | 16 | 0 | 2<sup>16</sup> - 1 |
| `Int32`	| o |  32 |	-2<sup>31</sup>	| 2<sup>31</sup> - 1 |
| `UInt32` | x | 32 | 0 | 2<sup>32</sup> - 1 |
| `Int64` | o | 64 | -2<sup>63</sup>	| 2<sup>63</sup> - 1 |
| `UInt64` | x | 64 | 0 | 2<sup>64</sup> - 1 |
| `Int128` | o | 128 |	-2<sup>127</sup> | 2<sup>127</sup> - 1 |
| `UInt128` | x | 128 | 0 | 2<sup>128</sup> - 1 |
| `Bool` | N/A | 8 | `false` (`0`) | `true` (`1`) |

</br>

`myint=3` 처럼 변수를 할당하면 시스템 마다 지정된 기본 타입으로 처리됩니다. 보통의 경우는 `Int64` 이며 시스템에 따라 `Int32` 나 다른 타입일 수 있습니다. 보통 `Int` 가 기본 정수형과 같은 의미로 사용되므로 다음과 같은 입력을 통해 기본 정수형을 알 수 있습니다.

```txt
In [1]: Int
Out[1]: Int64
```

긴 숫자를 표현할 때 오류를 줄이는 방법으로 밑줄 `_` 을 사용할 수 있습니다. 예를 들어 `a=123_4567_89_12` 는 밑줄을 없엔 `a=12345678912` 와 같습니다. 다만 두개 이상의 밑줄을 연속적으로 사용 할 수는 없습니다. `1_2` 는 사용 할 수 있지만 `1__2`는 에러를 냅니다.

```txt
In [2]: a=123_4567_89_12
Out[2]: 12345678912
```

</br>

#### Overflow

타입이 허용하는 범위의 값을 넘어서는 값을 할당하려 할 때에는 에러가 발생합니다. 

```txt
In [1]: a::UInt8 = 300
ERROR: InexactError: trunc(UInt8, 300)
...
```

`a::UInt8 = 300` 은 `UInt8` 타입의 변수 `a` 에 값 `300` 을 할당하는 명령어입니다. 만얄 `a::UInt8=2` 라면 `2` 는 `UInt8` 범위 내의 수이기 때문에 문제가 발생하지 않지만 `300` 은 `UInt8` 의 범위를 벗어나기 떼문에 에러가 발생합니다. 아래의 경우는 에러가 발생되지 않고 틀린 결과가 나옵니다.

```txt
In [2]: b = UInt8(200)+UInt8(56)
Out[2]: 0x00
```

`200` 과 `56` 은 모두 `UInt8` 의 범위 안이지만 그 합 `256` 은 범위를 벗어납니다. 이렇게 정수 타입에서 범위를 넘어서는 값이 할당되거나 계산될 때 실제 계산되어야 할 값과는 다른 값이 나오는 것을 **overflow** 라고 합니다. 해결책은 연산을 잘 조작하여 타입의 범위 내에서 원하는 결과를 얻을 수 있게 하거나, 당신의 변수가 가질 수 있을 가능성이 있는 값을 모두 포함하는 타입을 쓰는 것 밖에는 없습니다. Overflow 시 결과가 어떻게 나오는 지 알고 싶다면 공식 매뉴얼의 [Overflow behavior](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Overflow-behavior) 를 참고하시기 바랍니다.


</br>

### 부동소수 타입

부동소수는 일반적인 실수 (real number) 를 표현하기 위한 타입으로 가장 많이 사용하며, 부동소수의 기본타입인 `Float64` 타입의 경우 `fn1 = 3.33` 나 `fn2=2.3e-4` 처럼 사용합니다. 후자의 경우는 2.3 × 10<sup>-4</sup> 와 같습니다. 그리고 `e` 대신 `E` 를 사용해도 됩니다.  `e` 나 `E` 대신 `f` 를 사용하면 `Float32` 타입으로 지정됩니다.(`F` 는 사용 할 수 없습니다.) `2.3f0` 의 경우는 `Float32` 타입의 `2.3` 을 의미하며 `2.3f2` 와 `2.3f-2` 의 경우는 각각 `Float32` 타입의 2.3 × 10<sup>2</sup> 와 2.3 × 10<sup>-2</sup> 를 의미합니다. 부동정수형과 마찬가지로 숫자 사이에 밑줄을 넣어서 사용 할 수 있습니다. 혹은 정수에서와 같이 `a::Float32=3.3` 처럼 변수에 타입을 지정할 수 있습니다. 이 경우 할당되는 값이 지정된 타입(여기서는 `Float32`)으로 변환됩니다.

```julia
In [1]: 3.14_1592
Out[1]: 3.141592

In [2]: c::Float32=3.3
Out[2]: 3.3

In [3]: typeof(c)
Out[3]: Float32

In [4]: c
Out[4]: 3.3f0
```

</br>

### 유리수 타입 (Rational) 과 복소수 타입 (Complex)

유리수 타입은 두개의 정수 타입을 이용하여 하나는 분모, 하나는 분자로 사용하여 유리수를 표현합니다. 복소수 타입은 두개의 실수를 이용하여 하나는 실수부, 하나는 허수부로 사용하여 복소수를 표현합니다.

Rational 타입의 경우 `//` 연산자를 이용하거나 `Rational(3, 4)` 와 같이 할당합니다.. `a=1//3` 는 `Rational(1, 3)` 과 같고, `a` 라는 변수에 $\frac{1}{3}$ 을 저장합니다. 유리수값끼리의 혹은 유리수값과 정수의 사칙연산은 유리수가 되며, 자동적으로 약분하여 가장 간단한 값으로 처리됩니다.

```txt
In [1]: 6//5 + 1 # 유리수와 정수의 연산
Out[1]: 11//5

In [2]: 1//2 + 1.0 # 유리수와 실수의 연산
Out[2]: 1.5

In [3]: 27//12   # 유리수 입력은 자동으로 약분된다.
Out[3]: 9//4

In [4]: 1//12 + 2//12 # 유리수 연산 후 약분된다.
Out[4]: 1//4
```

</br>

Complex 타입의 경우는 `2.0 + 3.0im` 혹은 `Complex(2.0, 3.0)` 과 같이 할당합니다. Julia 에서 `im` 은 $\sqrt{-1}$ 로 정의되었으며 `i` 나 `j` 와 같은 문자를 사용하지 않습니다. `conj()` 함수는 켤레복소수를 반환합니다.

```txt
In [7]: (1.0+1.0im)*(1.0-1.0im)
Out[7]: 2.0 + 0.0im

In [8]: conj(Complex(1.0, 1.0))
Out[8]: 1.0 - 1.0im
```

</br>

### 불(Bool) 타입

불(Bool) 타입은 참을 나타내는 `true` 와 거짓을 나타내는 `false` 의 두 값만을 표현하는 정수형 타입입니다. 수로 변환하면 `true` 는 `1` 이며 `false` 는 `0` 입니다. 거꾸로 수를 불 타입으로 변환하는 경우 1 혹은 1 과 같다고 평가되는 `1.0f0` 와 같은 수는 `true` 로 `0` 혹은 `0` 과 같다고 평가되는 `0.0` 은 `false` 로 변환됩니다. [Python 과 같은 언어에서는 `0` 혹은 `0` 과 같다고 평가되는 수만 `False` 이고 나머지 수는 모두 `True` 로 평가됩니다.]{.aside}

```txt
In [1]: Bool(-3)
ERROR: InexactError: Bool(-3)
...

In [2]: Bool(1.0)
Out[2]: true

In [3]: Bool(1.0f0)
Out[3]: true

In [4]: Bool(3//3)
Out[4]: true

In [5]: Bool(0//1)
Out[5]: false
```
</br>

### 타입 확인

변수의 값이 특정 타입인지를 비교해야 할 때 가장 간단하게 사용할 수 있는 함수는 `isa` 입니다. `isa` 는 함수이기도 하지만 연산자이기도 합니다.

```txt
In [1]: isa(3.3f0, Float32)   # isa 를 함수처럼 사용할 경우
Out[1]: true

In [2]: 3.3f0 isa Float64     # isa 를 연산자처럼 사용할 경우
Out[2]: false
```

</br>

### 타입 변환

앞서 언급했듯이 타입 이름은 그 타입으로 변환시키는 함수처럼 사용 할 수 있습니다.

```txt
In [5]: Float32(3.32)
Out[5]: 3.32f0
```

어떤 언어에서는 실수를 정수로 변환할 때 억지로라도 변환시켜주지만 julia 에서는 실수가 정수와 같지 않으면 에러가 발생합니다. 

```txt
In [6]: Int64(2.0)
Out[6]: 2

In [7]: Int64(2.001)
ERROR: InexactError: Int64(2.001)
...
```

이때는 반올림 (`round`), 내림(`floor`), 올림(`ceil`) 함수를 사용 할 수 있습니다. 이 함수들은 입력값의 타입으로 반올림한 값을 반환합니다.  `round(3.3)` 처럼 사용해도 되지만 특정 정수 타입으로 변환할때는 `ceil(UInt16, 4.2)` 처럼 타입을 명시하여 변환해야 합니다.

```txt
In [8]: round(2.3)
Out[8]: 2.0

In [9]: floor(4.3f0)
Out[9]: 4.0f0

In [10]: ceil(UInt16, 4.2)
Out[10]: 0x0005
```

</br>

## 문자와 문자열, 기호 타입 {#sec-char_and_string_types}

### Char 와 String 타입

`Char` 는 ascii 나 유니코드 하나의 문자에 대한 타입이며 `String` 은 하나 이상의 문자를 포함하는 문자열에 대한 타입입니다. `Char` 타입은 `'a'` 와 같이 따옴표 `'` 로 감싸서 선언합니다. 한줄 문자열은 겹따옴표(`"`) 로 감싸고 여러줄 문자열은 겹따옴표 세개(`"""`)로 감쌉니다. 문자열을 출력할때는 `println` 함수를 사용합니다. `println` 함수의 경우 인자를 `,` 로 분리하여 계속 써 주면 각각의 인자를 문자열로 변환하여 연결시켜 하나의 문자열을 출력합니다.

```txt
In [11]: char1='가'
Out[11]: '가': Unicode U+AC00 (category Lo: Letter, other)

In [12]: str1 = "Hello, world.\n"
Out[12]: "Hello, world.\n"

In [13]: str2 = """Julia is
                a good programing
                language"""
Out[13]: "Julia is\na good programing\nlanguage"

In [14]: println(str2)
Julia is
a good programing
language

In [15]: println(1, "ab", " c_d ", 3.3)
1ab c_d 3.3
```

문자열 내의 `\n` 은 개행문자라고 해서 출력할 때 줄바꿈을 해 주는 문자입니다. asciii 는 컴퓨터 자판에서 보이는 숫자, 영어 알파벳과 기호를 포함하며 각 문자가 1바이트를 차지합니다. ascii 문자로 이루어진 문자열은 1부터 시작하는 인덱스로 접근 할 수 있습니다.


```txt
In [16]: str3 = "I love Julia language !!!"
Out[16]: "I love Julia language !!!"

In [17]: str3[1], str3[end], str3[end-4]
Out[17]: ('I', '!', 'e')
```

인덱스에서 `end` 는 맨 마지막 인덱스를 의미하며 `end-4` 은 마지막에서 다섯번째 글자를 의미합니다. `end-2` 는 마지막에서 세번째입니다. 정확히 말하면 `str3[3]` 은 문자열 `str3` 에서 세번째 글자가 아니라 세번째 바이트에서 시작하는 문자를 의미합니다. ascii 에서는 각 문자가 1 바이트를 차지하기 때문에 세번째 바이트에서 시작하는 문자와 세번째 문자가 같지만 2 바이트 이상을 차지하는 문자에서는 다른 의미가 됩니다.


</br>

### 유니코드(Unicode)

유니코드(unicode) 는 전 세계의 모든 문자를 다룰 수 있도록 제정된 표준 문자 처리 방식입니다. 유니코드를 표기할때는 U+0A03 처럼 U+ 와 16진수의 결합으로 표현합니다. 앞서 언급한 [Unicode Input](https://docs.julialang.org/en/v1/manual/unicode-input/) 에 julia 에서 표현 할 수 있는 문자들이 나열되어있습니다. 

유니코드를 문자열로 표현할 때는 탭으로 완성되는 문자를 사용 할 수도 있고 다음처럼 `\u` 혹은 `\U` 로 시작되는 문자로 표현 할 수도 있습니다. `\u` 다음에는 4개까지의 16진수 문자가 올 수 있으며 `\U` 다음에는 8개까지의 16진수 문자가 올 수 있고 `\u` 를 포함하여 더 많은 문자를 표현 할 수 있습니다. `\u` 나 `\U` 다음에 오는 숫자 가운데 자릿수를 차지하는 `0` 은 생략 할 수 있습니다. 예를 들어 `\u0033` 은 `\u33` 과 같습니다. 그리고 `\U000000` 부터 `\U00FFFF` 까지는 `\u0000` 과 `\uffff` 까지와 같습니다. 유니코드는 다음과 같이 사용합니다.

```txt
In [18]: unistr = "\u2200 x \u2203 y"
Out[18]: "∀ x ∃ y"
```

Julia 에서 유니코드는 UTF-8 로 인코딩 되어 있습니다. UTF-8 에서는 각 문자당 차지하는 바이트수가 다르기 때문에 ascii 와 같은 인덱스를 사용 할 수 없습니다. 앞서 설명했듯이 `unistr[2]` 는 문자열 `unistr` 의 2번째 바이트에서 시작하는 문자를 의미하는데 `\u2200` 은 3 바이트 문자이므로 2번째 바이트에서 시작하는 문자가 없으므로 에러가 발생합니다.

```txt
In [19]: unistr[1]
Out[19]: '∀': Unicode U+2200 (category Sm: Symbol, math)

In [20]: unistr[2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '
...

In [21]: unistr[4]
Out[21]: ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
```

그렇다면 문자열의 $n$ 번째 문자는 어떻게 추출할까요? 불편하긴 하지만 `collect` 함수를 사용할 수 있습니다. `collect` 함수는 문자열을 분리하여 배열(Array) 로 만듭니다. 즉 `unistr[2]` 는 문자가 아니지만 `collect(unistr)[2]` 는 `unistr` 문자열의 두번째 문자입니다. 

</br>

::: {.callout-note icon="false"}

#### 유니코드 문자열의 인덱스

유니코드 문자열을 다룰 때 인덱스의 의미는 언어마다 다릅니다. 예를 들어 Python 에서는 인덱스 가 `i` 일 때 `i` 번째 문자를 의미합니다. 아래는 Python shell 에서 같은 일을 한 결과입니다. 참고로 julia 는 인덱스가 1부터 시작하지만 python 은 0 부터 시작하기 때문에 인덱스가 차이가 납니다.

```txt
>>> unistr = "\u2200 x \u2203 y"
>>> unistr
'∀ x ∃ y'
>>> unistr[0]
'∀'
>>> unistr[1]
' '
>>> unistr[2]
'x'
```
:::

</br>

### 문자열 연산과 함수 {#sec-operators_and_fuctions_for_strings}

#### 결합과 반복

문자열을 합칠 때는 `*` 연산자를 이용하거나 `string()` 함수를 이용하며, 여러번 반복할때는 `^` 연산자 나 `repeat()` 함수를 이용합니다. 실제로 `string()` 함수는 인자를 차례대로 문자열로 바꾸어 주는 함수입니다.

```txt
In [1]: "가나다라"*"마바사" # 문자열 합치기
Out[1]: "가나다라마바사"

In [2]: string("가나다라", "abc", 'π', 5) # 문자열 합치기
Out[2]: "가나다라abcπ5"

In [3]: "αβγ"^3 # 문자열 반복
Out[3]: "αβγαβγαβγ"

In [4]: repeat("Δ=", 5) # 문자열 반복
Out[4]: "Δ=Δ=Δ=Δ=Δ="
```

문자열의 길이는 `length()` 함수를 사용하며 문자열에 접근할 때는 `str1[3]` 과 같이 인덱스를 사용합니다. Julia 에서는 처음 인덱스는 `0` 이 아닌 `1` 입니다. 

```txt
In [5]: str3="abcdefg";str3[2]
Out[5]: 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
```

</br>

#### 문자열 보간(Interpolation) {#sec-string_interpolation}

문자열에 `$` 기호를 통해 이미 정의된 변수를 사용하여 문자열을 구성 할 수 있습니다. 

```txt
In [6]: aa=1;bb=22.2;cc="C12";

In [7]: """aa=$aa, bb=$bb, cc=$cc"""
Out[7]: "aa=1, bb=22.2, cc=C12"
```

보간 이전에 값을 평가해야 할 경우에는 괄호(`( )`) 안에 식을 넣을 수 있습니다. 예를 들어 `"$sin(π)"` 는 문자열 `"sin(π)"` 지만 `"$(sin(π))"` 는 `sin(π)` 를 평가한 `0.0` 이 문자열로 입력됩니다. 

```txt
In [9]: "$sin(π)"
Out[9]: "sin(π)"

In [10]: "$(sin(π))"
Out[10]: "0.0"
```

</br>

#### 비교 

문자열을 사전순으로 비교 할 수 있습니다. 즉 `'a' < 'b'` 이며 `"aa" < "ab"` 입니다.

```txt
In [11]: "abracadabra" < "xylophone"
Out[11]: true

In [12]: "abracadabra" == "xylophone"
Out[12]: false

In [13]: "Hello, world." != "Goodbye, world."
Out[13]: true

In [14]: "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
Out[14]: true
```

</br>

#### 문자열 함수

`findfirst(a, str)` 은 문자열 `str` 에서 문자 혹은 문자열 `a` 가 나타는 첫번째 인덱스를 리턴합니다. `findlast(a, str)` 는 마지막 인덱스를 리턴합니다. `findprev(a, str, i)` 는 문자열 `str` 에서 문자 혹은 문자열 `a` 를 찾는데 인덱스 `i` 부터 앞으로 찾아가서 나오는 첫번째 인덱스를 반환합니다. `findnext(a, str, i)` 는 인덱스 `i` 부터 뒤로 찾아가서 나오는 첫번째 인덱스를 반환합니다. 네가지 경우 모두 찾지 못한다면 `nothing` 을 반환합니다. `a` 가 문자열일 경우는 `a` 와 일치하는 인덱스의 범위를 리턴합니다. `6:7` 은 인덱스 6에서 인덱스 7 까지란 의미입니다. `occursin(a, str)` 은 문자 혹은 문자열 `a` 가 문자열 `str` 에 포함되어 있는지만을 확인하여 `true` 나 `false` 를 리턴합니다.

```txt
In [15]: findfirst('a', "biography")
Out[15]: 6

In [16]: findfirst("ap", "biography")
Out[16]: 6:7

In [17]: occursin("gr", "biography")
Out[17]: true

In [18]: occursin("rp", "biography")
Out[18]: false
```

</br>

`repeat(a, n)` 은 문자열 `a` 를 `n` 번 반복한 문자열을 반환합니다. 여러 문자열을 결합할 때는 `join()` 함수를 사용합니다.

```txt
In [19]: repeat(".:Z:.", 10)
Out[19]: ".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

In [20]: join(["apples", "bananas", "pineapples"], ", ", " and ")
Out[20]: "apples, bananas and pineapples"
```

`join` 함수의 두번째 인자 `", "` 는 결합하는 문자열 사이에 `", "` 를 끼워 결합하라는 의미입니다. 세번째 인자 `" and "` 는 마지막 두 문자열을 결합할때는 `", "` 대신에 `" and "` 를 사용하라는 의미입니다. 자세한 것은 julia 의 공식 도움말을 참고하시기 바랍니다.


</br>

### 심볼 타입 {#sec-symbol_types}

심볼(Symbol) 타입은 문자열과 비슷하지만 다릅니다. 심볼(Symbol) 타입은 `:` 다음의 문자열, 혹은 `Symbol` 이라는 타입 이름을 함수로 사용하여 다음과 같이 선언할 수 있습니다.

```txt
In [21]: a=Symbol("bc") # `Symbol` 함수를 이용한 선언
Out[21]: :bc

In [22]: b=:bc # 콜론 `:` 을 이용한 선언
Out[22]: :bc

In [23]: a==b # 두 선언은 같다.
Out[23]: true
```
 
심볼 타입은 Julia 에서 소위 [메타 프로그래밍](https://docs.julialang.org/en/v1/manual/metaprogramming/) 개념의 핵심이지만 여기서는 자세히 다루지 않겠습니다. 심볼 타입이 많이 쓰이는 다른 경우는 함수에 인자로 전달할 때 입니다. 예를 들어 그래프를 빨간 색으로 그리고 싶을 때, 다른 언어라면 `"red"` 라는 문자열을 함수의 인자로 입력하는 경우가 많은데, Julia 에서는 이렇게 문자열을 쓸 수도 있지만 `:red` 라는 심볼 타입을 전달하는 경우가 많습니다. 이 경우 비교가 문자열보다 빠릅니다.

</br>

### 변수의 타입 지정과 타입 유니온 {#sec-type_union}

#### 변수의 타입 지정

예를 들어 변수 `a` 에 `UInt8` 타입의 `3` 을 할당한다고 해 봅시다. `a=UInt8(3)` 와 `a::UInt8=3` 과 같은 두가지 방법을 사용 할 수 있습니다. 그러나 두번째 경우에는 `a` 라는 변수가 `UInt8` 타입으로 지정되기 때문에 `UInt8` 타입 이외의 값으로 변경할 수 없습니다.

```txt
In [1]: a::UInt8=3
Out[1]: 3

In [2]: a=4
Out[2]: 4

In [3]: a=-1
ERROR: InexactError: trunc(UInt8, -1)
Stacktrace:
```

`In [2]` 에서는 4 가 `UInt8` 타입으로 `a` 에 저장됩니다. 그러나 `UInt8` 은 음수를 저장 할 수 없으므로 `In [3]` 의 입력은 에러를 냅니다. 그러나 `b=UInt8(3)` 과 같이 할당하면 `a` 변수에 대한 타입 제한은 없습니다.

```txt
In [4]: b=UInt8(3)
Out[4]: 0x03

In [5]: b=-1
Out[5]: -1
```

</br>

#### 타입 유니온

타입 유니온은 변수가 가질 수 있는 타입을 하나가 아닌 여러개중 하나로 할 때 사용되며 `Union{T1, T2}` 처럼 사용됩니다. `T1`, `T2` 는 변수가 가질 수 있는 타입이며 두개 이상일 경우에는 `,` 로 구분하여 나열합니다. 다음 보기를 봅시다.

```txt
In [1]: a::Union{Int, AbstractString}="a"
Out[1]: "a"

In [2]: b::Union{Int, AbstractString}=3
Out[2]: 3

In [3]: c::Union{Int, AbstractString, Nothing}=nothing

In [4]: (a, b, c)
Out[4]: ("a", 3, nothing)
```

`In [1]` 의 경우는 입력값이 문자열이므로 `a` 는 문자열 타입이 되고, `b` 는 입력값이 정수이므로 정수 타입이 되었습니다. `c` 는 세가지 타입중에 선택하도록 하는 것입니다. 이런 방법 역시 일반적인 변수에 값을 할당할 때 보다 함수의 인자의 타입을 제한 할 때 사용됩니다. 그리고 `nothing` 은 값이고 `Nothing` 은 `nothing` 에 대한 타입입니다.

</br>
