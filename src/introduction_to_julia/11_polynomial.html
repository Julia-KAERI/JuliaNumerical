<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.302">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Physics, Math &amp; Computing – polynomial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Physics, Math &amp; Computing</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/introduction_to_julia/index.html" rel="" target="">
 <span class="menu-text">Introduction to Julia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/numerical_analysis_using_julia/index.html" rel="" target="">
 <span class="menu-text">Numerical Analysis using Julia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/tools/tools.html" rel="" target="">
 <span class="menu-text">Tools</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#일변수-다항식의-julia-구현" id="toc-일변수-다항식의-julia-구현" class="nav-link active" data-scroll-target="#일변수-다항식의-julia-구현">일변수 다항식의 Julia 구현</a>
  <ul class="collapse">
  <li><a href="#익명함수를-이용한-간단한-구현" id="toc-익명함수를-이용한-간단한-구현" class="nav-link" data-scroll-target="#익명함수를-이용한-간단한-구현">익명함수를 이용한 간단한 구현</a></li>
  <li><a href="#객체를-이용한-다항식의-구현" id="toc-객체를-이용한-다항식의-구현" class="nav-link" data-scroll-target="#객체를-이용한-다항식의-구현">객체를 이용한 다항식의 구현</a></li>
  <li><a href="#근을-이용하여-다항식을-만들기" id="toc-근을-이용하여-다항식을-만들기" class="nav-link" data-scroll-target="#근을-이용하여-다항식을-만들기">근을 이용하여 다항식을 만들기</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="일변수-다항식의-julia-구현" class="level2">
<h2 class="anchored" data-anchor-id="일변수-다항식의-julia-구현">일변수 다항식의 Julia 구현</h2>
<p>이제 일변수 다항식 (<span class="math inline">\(x\)</span> 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 <a href="https://github.com/JuliaMath/Polynomials.jl">Polynomials.jl</a> 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.</p>
<p><br></p>
<section id="익명함수를-이용한-간단한-구현" class="level3">
<h3 class="anchored" data-anchor-id="익명함수를-이용한-간단한-구현">익명함수를 이용한 간단한 구현</h3>
<p>Julia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 <code>poly1</code> 함수는 다항식의 전체 계수 벡터 <code>coeff</code> 를 인자로 받아 <code>coeff[i]</code> 가 다항식의 <span class="math inline">\(i-1\)</span> 차 계수가 되는 함수를 리턴한다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">poly1</span>(coeff<span class="op">::</span><span class="dt">Vector{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Number</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">-&gt;</span> <span class="fu">sum</span>(coeff <span class="op">.*</span> (x <span class="op">.^</span> (<span class="fl">0</span><span class="op">:</span>(<span class="fu">length</span>(coeff)<span class="op">-</span><span class="fl">1</span>))))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>우리는 이 함수가 잘 작동함을 확인 할 수 있다.</p>
<pre class="none"><code>julia&gt; ff = poly1([1.0, -2.0, 1.0])
#1 (generic function with 1 method)

julia&gt; ff(1.0)
0.0</code></pre>
<p>함수 시그니쳐의 <code>poly1(coeff::Vector{T}) where T&lt;:Number</code> 에서 <code>poly1(coeff::Vector{T})</code> 는 <code>poly1</code> 함수가 <code>T</code> 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 <code>where T&lt;:Number</code> 는 <code>T</code> 가 <code>Number</code> 의 서브타입만을 허락한다는 의미이다. <code>Number</code> 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 <code>coeff</code> 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.</p>
<pre class="none"><code>julia&gt; poly1(3)
ERROR: MethodError: no method matching poly1(::Int64)

julia&gt; poly1([sin, 1])
ERROR: MethodError: no method matching poly1(::Vector{Any})</code></pre>
<p><code>coeff</code> 가 벡터가 아니거나, 수의 벡터가 아니면 에러가 발생함을 알 수 있다.</p>
<p><code>return</code> 뒤의 <code>return x::Number -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))</code> 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 <code>ff = poly1([1.0, -2.0, 1.0])</code> 라 하면 <code>ff(x)</code> 는 <span class="math inline">\(1-2x+x^2\)</span> 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 <code>coeff</code> 와 <code>x</code> 의 타입의 연산 규칙에 다라 결정된다.</p>
<p>때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.</p>
<p>익명 함수로는 이것이 힘들다. <code>structure</code> 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 <code>Polynomials.jl</code> 패키지가 있으므로 <code>SimplePolynomial</code> 이라는 객체를 만들도록 하자.</p>
<p><br></p>
</section>
<section id="객체를-이용한-다항식의-구현" class="level3">
<h3 class="anchored" data-anchor-id="객체를-이용한-다항식의-구현">객체를 이용한 다항식의 구현</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SimplePolynomial{T}</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    coeffs <span class="op">::</span><span class="dt"> Vector{T}</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">SimplePolynomial</span>(coeff<span class="op">::</span><span class="dt">AbstractVector{T}</span>) <span class="kw">where</span> T <span class="op">&lt;:</span><span class="dt"> Number</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="fu">length</span>(coeff) <span class="op">==</span> <span class="fl">0</span> </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">SimplePolynomial</span>(<span class="fu">zeros</span>(T, <span class="fl">1</span>))</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        last_nz <span class="op">=</span><span class="fu">findlast</span>(!iszero, coeff)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        coeff_last <span class="op">=</span> <span class="fu">max</span>(<span class="fl">1</span>, <span class="fu">isnothing</span>(last_nz) ? <span class="fl">0</span> <span class="op">:</span> last_nz)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">SimplePolynomial</span>(coeff[<span class="fl">1</span><span class="op">:</span>coeff_last])</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>SimplePolynomial</code> 은 immutable 한 객체로 구현되었다. 즉 <code>coeffs</code> 속성은 변경 될 수 없다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">julia</span><span class="op">&gt;</span> a = SimplePolynomial<span class="er">(</span><span class="ex">[1,</span> 3]<span class="kw">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">SimplePolynomial{Int64}</span><span class="er">(</span><span class="ex">[1,</span> 3]<span class="kw">)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ex">julia</span><span class="op">&gt;</span> a.coeffs = [3.0, 4.0]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ex">ERROR:</span> setfield!: immutable struct of type SimplePolynomial cannot be changed</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>struct</code> 구문 내부의 <code>function SimplePolynomial(coeff::AbstractVector{T}) where T &lt;: Number</code> 에서 시작하는 구문은 내부생성자 (inner constructor) 구문이다. 여기서 <code>T</code> 의 타입을 <code>Number</code> 의 subtype 으로 제한한다.</p>
<p>이제 <code>SimplePolynomial</code> 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (p<span class="op">::</span><span class="dt">SimplePolynomial</span>)(x<span class="op">::</span><span class="dt">Number</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">evalpoly</span>(x, p.coeffs)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (p<span class="op">::</span><span class="dt">SimplePolynomial</span>)(x<span class="op">::</span><span class="dt">T</span>) <span class="kw">where</span> T <span class="op">&lt;:</span><span class="dt"> Matrix{N} </span><span class="kw">where</span> N<span class="op">&lt;:</span><span class="dt">Number</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="fu">UniformScaling</span>(p.coeffs[<span class="fl">1</span>])</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@assert</span> <span class="fu">size</span>(x)[<span class="fl">1</span>] <span class="op">==</span> <span class="fu">size</span>(x)[<span class="fl">2</span>] <span class="co"># 정사각 행렬에 대해서만 가능하다.</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fu">length</span>(p.coeffs)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@inbounds</span> r <span class="op">+=</span>  p.coeffs[i]<span class="op">*</span>x<span class="op">^</span>(i<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> r</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>단위행렬의 상수배를 나타내는 연산자 <code>UniformScaling</code>을 위해 <code>LinearAlgebra</code> 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 <code>@assert size(x)[1] == size(x)[2]</code> 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">julia</span><span class="op">&gt;</span> a1 = SimplePolynomial<span class="er">(</span><span class="ex">[1.0,</span> 2.0, 3.0]<span class="kw">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">SimplePolynomial{Float64}</span><span class="er">(</span><span class="ex">[1.0,</span> 2.0, 3.0]<span class="kw">)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ex">julia</span><span class="op">&gt;</span> a1<span class="er">(</span><span class="ex">1.0</span><span class="kw">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ex">6.0</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ex">julia</span><span class="op">&gt;</span> a1<span class="er">(</span><span class="ex">[4</span> 3<span class="kw">;</span> <span class="ex">2</span> 4]<span class="kw">)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="ex">2×2</span> Matrix{Float64}:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">75.0</span>  78.0</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a> <span class="ex">52.0</span>  75.0</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="ex">julia</span><span class="op">&gt;</span> a1<span class="er">(</span><span class="ex">[4</span> 3 3<span class="kw">;</span> <span class="ex">2</span> 4 3]<span class="kw">)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="ex">ERROR:</span> AssertionError: <span class="er">(</span><span class="fu">size</span><span class="er">(</span><span class="ex">x</span><span class="kw">))</span><span class="ex">[1]</span> == <span class="er">(</span><span class="fu">size</span><span class="er">(</span><span class="ex">x</span><span class="kw">))</span><span class="ex">[2]</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 <code>length</code> 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. <code>Base.length</code> 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="op">:</span><span class="fu">length</span>(b<span class="op">::</span><span class="dt">P</span>) <span class="kw">where</span> {P<span class="op">&lt;:</span><span class="dt"> SimplePolynomial</span>}</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">length</span>(b.coeffs)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이제 <code>SimpllePolynomial</code> 객체 사이에 혹은 <code>SimplePolynomial</code> 객체와 상수간의 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 연산을 정의 할 수 있다. <code>/</code> 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 <code>polynomial.jl</code> 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 <code>include</code> 명령을 통해 사용 할 수 있다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">include</span><span class="er">(</span><span class="st">"path_to_polynomial.jl"</span><span class="kw">)</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>다항식 <span class="math inline">\(p(x) = a_0 + a_1 x + \cdots + a_n x^n\)</span> 일 때,</p>
<p><span class="math display">\[
\begin{aligned}
\dfrac{d}{dx}p(x) &amp;= a_1 + 2a_2 x + \cdots + na_n x^{n-1},\\
\int_x p(t)\, dt &amp;=a_0 x + \dfrac{a_1}{2}x^2 + \cdots + \dfrac{a_n}{n+1}x^{n+1} + \text{const.}
\end{aligned}
\]</span></p>
<p>임을 안다. 이것을 이용하여 다항식을 미분하는 함수 <code>differentiate(p::Polynomial{T})</code> 와 정적분 함수 <code>integrate(p::Polynomial{T}, c)</code> 함수를 구현하였다. 여기서 <code>c</code> 는 정적분의 상수항이다.</p>
<p><br></p>
</section>
<section id="근을-이용하여-다항식을-만들기" class="level3">
<h3 class="anchored" data-anchor-id="근을-이용하여-다항식을-만들기">근을 이용하여 다항식을 만들기</h3>
<p>다항식 <span class="math inline">\(p(x)\)</span> 의 전체 근이 <span class="math inline">\(x_1,\,x_2,\ldots,\,x_n\)</span> 라고 하면 이 다항식은 상수 <span class="math inline">\(c\)</span> 에 대해</p>
<p><span class="math display">\[
p(x) = c \prod_{i=1}^n (x-x_i)
\]</span></p>
<p>의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 <span class="math inline">\(c=1\)</span> 로 정해진 다항식을 리턴한다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">polynomial_from_roots</span>(xp<span class="op">::</span><span class="dt">Vector{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Number</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="fu">one</span>(T)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(xp) </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@inbounds</span> r <span class="op">=</span> r<span class="op">*</span> <span class="fu">SimplePolynomial</span>([<span class="op">-</span>xp[i],  <span class="fl">1</span>])</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> r</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>그렇다면,</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">julia</span><span class="op">&gt;</span> pp3 = polynomial_from_roots<span class="er">(</span><span class="ex">[1.0,</span> 1.0, 2.0]<span class="kw">)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">SimplePolynomial</span> :  + 1.0 x^3 <span class="at">-</span> 4.0 x^2 + 5.0 x^1 <span class="at">-</span> 2.0 </span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>의 결과가 나온다. <span class="math inline">\((x-1)^2(x-2)= x^3-4x^2+5x-2\)</span> 이므로 정확한 결과가 나왔다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>