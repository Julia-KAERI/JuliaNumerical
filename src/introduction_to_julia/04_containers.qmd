---
title: "컨테이너"

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

여러 개의 데이터를 저장하고 처리하기 위한 데이터 타입을 컨테이너(container)이라고 하며, 대표적으로 배열(`Array`), 튜플(`Tuple`), 사전(`Dict`), `StepRange`, 집합(`Set`) 등이 있습니다. 컨테이너은 기본적으로 `length` 함수를 통해 포함되어 있는 아이템의 갯수를 알 수 있으며, 아이템을 하나하나 순회할 수 있습니다. 순서가 있는 컨테이너일 경우 순서대로 1, 2, ... 의 인덱스를 가지며 포함하는 객체에 접근하여 값을 가져오거나 값을 변경할 때 정수 인덱스로 접근 할 수 있습니다. 순서가 중요하지 않은 컨테이너 일 경우 값마다 지정된 키(key) 인덱스를 통해 접근할 수 있습니다. 집합 타입의 컨테이너의 경우는 인덱스로도, 키로도 접근할 수 없습니다. 컨테이너에서 아이템을 더하거나 뺄 수 있는 컨테이너를 mutable 하다고 하며, 한번 생성된 컨테이너을 변경 할 수 없다면 immutable 하다고 합니다.


</br>

## 대표적인 컨테이너들 {#sec-collections}

Julia 에서는 많은 종류의 컨테이너를 기본적으로 제공하며, 이 가운데 가장 많이 사용되는 것들의 특징을 정리하였습니다.

| 이름 | 정수 인덱스로 접근 | 키 인덱스로 접근 | mutable | 
|:------:|:---:|:---:|:---:|
| 배열 (`Array`) | o | x | o |
| 튜플 (`Tuple`) | o | x | x | 
| 기명 튜플 (`NamedTuple`) | o | o | x |
| 사전 (`Dictionary`) | x | o | o | 
| StepRange (`StepRange`) | o | x | x | 
| 집합 (`Set`) | x | x | o | 
| 배열 (`Array`) | o | x | o | 

: 대표적인 컨테이너과 그 특징 {#tbl-properties_of_collections}

</br>

### 배열 (Array) {#sec-arrays_0}

배열은 정수 인덱스로 접근하는 같은 타입의 성분을 갖는 다차원 컨테이너로 mutable 입니다. 수치 해석에서 기본이 되는 벡터, 행렬과 이미지 등은 대부분 배열로 처리됩니다. 배열은 Julia 에서 특히 수치 해석에서 너무나 중요하기 때문에 이후 [배열](06_arrays.qmd#sec-array) 에서 자세히 다루고 여기서는 1차원 배열에 대해서만 간단히 다루도록 하겠습니다.

</br>

### 1차원 배열 (Vector) {#sec-vector}

1차원 배열은 `Vector` 라고 불리며 `[ ]` 안에 쉼표로 분리되어 나열된 아이템을 성분으로 갖는 컨테이너 입니다. 수를 비롯하여 모든 타입의 아이템을 포함할 수 있으며 삽입과 삭제가 자유로운 mutable 타입으로 정수 인덱스로 접근합니다. 다음과 같이 정의합니다.

```txt
In [1]: vec1 = [1, 2, "a", 3.4, "bbc"]
Out[1]: 5-element Vector{Any}:
 1
 2
  "a"
 3.4
  "bbc"

In [2]: vec2=[2,3,4,5]
Out[2]: 4-element Vector{Int64}:
 2
 3
 4
 5

```

이 때 `vec1[1]=1` 이며 `vec1[5]="bbc"` 입니다. `Vector` 옆의 `{Any}` 나 `{Int64}` 는 벡터의 성분(벡터에 포함된 아이템을 성분(entry, element) 라고 합니다) 의 타입입니다. `Any` 타입은 모든 타입을 포함하는 타입입니다. 베열이 생성될 때 정해지며, 일단 정해진 벡터의 타입은 변경 될 수 없습니다. 다만 타입을 변경한 새로운 벡터를 만들 수 있습니다. 배열은 mutable 이므로 성분을 인덱스로 접근하여 변경 할 수 있습니다.

```julia
In [5]: vec1[2]=2.2; vec1
Out[5]: 5-element Vector{Any}:
 1
 2.2
  "a"
 3.4
  "bbc"
```

</br>

::: {.callout-note icon="false"}

#### 명령문 끝의 `;`

위의 `In [5]` 에서와 같이 Julia REPL 에서 명령어 다음에 세미콜론 `;` 을 붙이면 명령을 수행하지만 그 결과는 출력하지 않습니다. Jupyter 나 vscode 환경에서도 마찬가지 입니다. 
:::

</br>

벡터에 성분을 마지막에 추가하고 싶으면 `append!(vec1, item1, item2, .. )` 처럼 사용합니다. 그렇게 되면 `vec1` 에 `item1`, `item2` 가 차례대로 추가됩니다. 만약 `item1`, `item2`... 들이 컨테이너이라면 `vec1` 에 `item1` 를 순서대로 합칩니다.

</br>

::: {.callout-note icon="false"}

#### 함수명 끝의 `!`

Julia 에서는 함수명을 붙일 때 함수의 어떤 인자를 변경하는 함수라면 관례적으로 그 이름 끝에 `!` 를 붙입니다. 다음부터 나올 `push!` 나 `pop!` 함수 이름에 `!` 가 붙은것은 이 함수가 직접 인자를 변경하기 때문입니다. 직접 변경하지 않을 때는 `!` 를 붙이지 않습니다.

:::

</br>


::: {#exm-vector_append}
`append!(vec1, [2, 4], ["k", "g"])` 를 수행해 보세요.
:::

</br>

어떤 정해진 인덱스에 삽입하려면 `insert!(vec1, index1, item1)` 처럼 사용합니다. 그렇게 되면 `vec1[index1] == item1` 이 되며 원래 `index1` 에 위치했던 아이템과 그 뒤의 아이템들의 인덱스가 하나씩 늘어나게 됩니다. `item` 이 컨테이너이라도 `append!` 처럼 컨테이너의 아이템이 순서대로 삽입되지 않고 컨테이너 자체로 삽입됩니다. (타입이 지정된 벡터이면 에러가 발생합니다.)


```txt
In [6]: vec1 = [1, 2, "a", 3.4, "bbc"];

In [7]: insert!(vec1, 3, "II")
Out[7]: 6-element Vector{Any}:
 1
 2
  "II"
  "a"
 3.4
  "bbc"

```

특정 인덱스의 아이템을 삭제하고 싶으면 `deleteat!` 함수를 사용합니다. 만약 `vec1[4]` 인 "a" 를 삭제하고 싶으면 `deleteat!(vec1, 4)` 처럼 사용합니다.

Julia 의 모든 타입은 `Any` 로부터 가지처럼 뻗어나가는 계층 구조를 가지고 있습니다. 여기에 대해서는 [타입의 계층구조](08_type_hierarchy.qmd#sec-type_hierarchy) 에서 좀 더 자세히 알아 볼 것입니다. 벡터를 정의할 때 `vec1` 처럼 여러 타입을 가진 아이템을 포함한다면 julia 가 알아서 적절한 타입으로 변환합니다. 정수와 부동소수만으로 이루어진 배열은 자동적으로 부동소수로 변환됩니다. `Any` 는 모든 타입을 포함 할 수 있는 타입이므로 임의의 타입을 위한 배열의 타입으로 사용됩니다. 당분간은 배열은 특정한 타입만을 포함 할 수 있으며, 임의의 타입을 포함하고 싶을때는 `Vector` 다음에 `{Any}` 를 명시적으로 붙인다고 알고 있겠습니다.


::: {.callout-note icon="false"}

#### Promotion

연산에서 같은 타입이 아닐 때 타입을 조정하는것을 *promotion* 이라고 합니다. 예를 들자면 `2+3.0` 이나 `3.3 + π` 을 계산하는 경우 둘의 타입이 다르기 때문에 julia 가 적절한 타입, 이 경우는 둘 다 부동소수로 타입으로 변환합니다.
:::


```txt
In [1]: vec2=Vector{Any}([1,2,3]);

In [2]: ec3=Vector([1,2,3]);
```

`vec2` 와 `vec3` 는 모두 세 정수로 이루어진 벡터이지만 `vec2` 는 `Any` 타입으로 지정되었습니다. 따라서 `insert!(vec2, 2, "A")` 는 동작하지만 `insert!(vec3, 2, "A")` 는 동작하지 않습니다.

`push!` 와 `pop!` 은 벡터의 미지막에 어떤 아이템을 추가하거나, 마지막 아이템을 제거하는 명령입니다. `push!(vec3, 5)` 나 `pop!(vec3)` 처럼 사용합니다. `pop!` 의 경우 제거된 아이템을 반환합니다.

```txt
In [3]: push!(vec3, 5)
Out[3]: 4-element Vector{Int64}:
 1
 2
 3
 5

In [4]: pop!(vec3)
Out[4]: 5

In [5]: vec3
Out[5]: 3-element Vector{Int64}:
 1
 2
 3
```

::: {#exr-functions_for_vector}
`pushfirst!`, `popfirst!`, `empty!` 함수를 알아보고 벡터를 변형시켜 봅시다.
:::


</br>

### StepRange {#sec-steprange}

일정한 간격으로 나열되는 수를 위한 immutable 컨테이너입니다. 대표적으로 `start:step:end` 형식이나 `start:end` 형식으로 할당하며, 후자의 경우 `start` 와 `end` 의 타입으로부터 `1` 혹은 `1.0` 의 간격을 갖도록 만들어집니다. 

- `range1 = start:step:end` 형식으로 만들 경우 1 부터 시작하는 인덱스 `i` 에 대해 `range1[i] == start + (i-1)*step` 값을 가지며 당연히 `end` 값을 넘지 않습니다. 그리고 `end` 값을 포함 할 수 있습니다. `1:1:5` 의 경우는 5번째 값은 `5` 입니다. [python 의 경우 `range(1, 5)` 나 `numpy.arange(1, 5)` 로 생성하는 배열은 `5` 를 포함하지 않습니다.]{.aside}

- `end > start` 일 경우는 `step` 값이 `0` 보다 작아야 합니다.

::: {#exr-range-1}
`start > end` 일 때, `step` 값을 양수로 정의해 보거나, `start < end` 일 때 `step` 값을 음수로 정의하고 인덱스를 통해 접근해 보기 바랍니다. 또한 `start == end` 일 때는 어떻게 되는지 확인해 보기 바랍니다.
:::

`range` 함수를 통해서도 생성 할 수 있습니다. `range(1, 10, step=1)` 은 `1:1:10` 과 같습니다. 또한 `range(start=0.0, stop=π, length=100)` 은 0 부터 $\pi$ 까지 100 개의 길이를 가진 Range 만듭니다. 자세한 것은 julia 의 기본 문서에서 `range` 를 검색해 보기 바랍니다.

많은 경우 StepRange 는 벡터처럼 동작하지만 immutable 이므로 수정 할 수 없습니다. 그리고 많은 경우 수학 함수에 적용되면 결과가 벡터로 변환됩니다. 

```txt
In [6]: sin.(0.0:0.1:π)
Out[6]: 32-element Vector{Float64}:
 0.0
 0.09983341664682815
 0.19866933079506122
 0.2955202066613396
 0.3894183423086505
 0.479425538604203
 0.5646424733950355
 0.6442176872376911
 ⋮
 0.5984721441039564
 0.5155013718214642
 0.4273798802338298
 0.33498815015590466
 0.23924932921398198
 0.1411200080598672
 0.04158066243329049
 ```

</br>

StepRange 값을 벡터로 변환할 때는 `collect` 함수를 사용합니다. `collect` 함수는 컨테이너를 인자로 받아 이것을 벡터로 바꾸어 주는 함수입니다.

```txt
In [6]: collect(1:2:11)
Out[6]: 6-element Vector{Int64}:
  1
  3
  5
  7
  9
 11
```
</br>

#### `range` 함수

`StepRange` 와 비슷한 기능을 하는 `range` 함수가 있습니다. REPL 에서 `?range` 로 알 수 있는 `range` 함수의 시그너쳐는 다음과 같습니다.

```julia
  range(start, stop, length)
  range(start, stop; length, step)
  range(start; length, stop, step)
  range(;start, length, stop, step)
```

`range(1, 10, 10)` 은 시작과 끝, 그리고 길이를 지정하는 첫번째 시그너쳐에 따라 생성합니다. `0.0:0.1:10.0` 에서는 간격이 주어지지만 `range` 는 간격 대신 길이를 지정 할 수 있습니다.

</br>

### 튜플 (Tuple) {#sec-tuple}

튜플은 벡터처럼 인덱스를 통해 포함하는 아이템에 접근 할 수 있지만 새로운 아이템을 추가할 수도 없고, 포함하는 아이템을 삭제할 수도 없습니다. 즉 immutable 입니다. 튜플은 `tuple1 = (1, 3.3, 'A', cos, (2, "a", sin))` 과 같이 `( )` 안에서 `,` 로 구분하여 선언합니다. 여기서 `A` 는 `Char` 타입, "a" 는 `String` 타입이며, `sin`, `cos` 는 함수입니다. (Julia 에서 함수는 `Function` 타입입니다.) 튜플에서는 `1` 부터 시작되는 인덱스를 이용하여 포함된 아이템에 접근 할 수 있습니다. 앞서의 `tuple1` 의 경우, `tuple1[1]==1` 이며, `typle1[3]=='A'` 입니다. `tuple[5]== (2, "a", sin)` 이므로 `tuple1[5][2]=="a"` 입니다. `tuple1[5][3]==sin` 인 함수이므로 다음과 같은 결과를 얻을 수 있습니다.

```txt
In [1]: tuple1 = (1, 3.3, 'A', cos, (2, "a", sin))
Out[1]: (1, 3.3, 'A', cos, (2, "a", sin))

In [2]: tuple1[5][3](π/2)
Out[2]: 1.0
```

tuple 은 immutable 한 컨테이너이므로 `tuple1[2]=4.4` 와 같은 방식으로 아이템을 변경 할 수 없으며, 성분을 추가하거나 삭제할 수도 없습니다.

</br>

::: {#exr-tuple_error1}
임의의 튜플을 만든 후 인덱스를 통해 아이템을 변경해 보고 그 에러를 확인해 보세요.
:::

</br>

튜플이 벡터와 구별되는 것 가운데 하나는 포함되는 아이템의 타입을 일치시키려 하지 않는 점 입니다. 앞서 보았듯이 `vec0 = [1, 2.0]` 를 수행하면 맨 처음의 `1` 은 벡터가 되면서 `2.0` 의 타입을 고려하여 `Float64` 타입인 `1.0` 으로 변경됩니다. 이것은 `vec0 = Vector{Any}([1, 2.0])` 를 해도 마찬가지 입니다. 그러나 튜플은 다릅니다.

```txt
In [1]: tup0 = (1, 2.0)
Out[1]: (1, 2.0)
```

와 같이 타입을 일치시키려 하지 않습니다. 

</br>

튜플이 가장 흔하게 사용되는 곳은 함수의 `return` 에서 입니다. 만약 함수가 아래와 같이 여러개의 값을 `,` 로 구분하여 반환한다면 이것은 이 값들을 순서대로 묶은 튜플을 반환하는 것입니다. 아래의 `return3()` 함수는 그냥 1, 2, 3 을 반환하는 함수인데, 리턴값은 이 값을 묶은 튜플입니다. 아래의 함수는 1, 2, 3 을 반환하는 함수입니다.

```julia
function return3()
    return 1, 2, 3
end
```
이 함수를 실행시키면 튜플 `(1, 2, 3)` 을 반환합니다.

```txt
In [3]: return3()
Out[3]: (1, 2, 3)
```

</br>

튜플을 사용하는 기법중의 하나가 두 변수의 값을 서로 바꿀 때 입니다. 예를 들어 다음 코드를 봅시다.

```txt
In [4]: a=1;b=2;a, b = b, a
Out[4]: (2, 1)

In [5]: println("a=$a, b= $b")
a=2, b= 1
```

우선 `a`, `b` 에 각각 1 과 2 를 할당했습니다. 그 다음의 `a, b = b, a` 를 봅시다. 우선 등호의 오른쪽 `b, a` 를 수행하여 `(b, a)` 인 튜플을 만듭니다. 그리고 `a, b=b, a` 를 통해 `a=(b, a)[1]` 과 `b=(b, a)[2]` 를 수행합니다. 즉 `(b, a)` 인 새로운 튜플을 만들고 그 값을 순서대로 `a`, `b` 에 할당하는 것이기 때문에 결과적으로 두 변수의 값을 서로 교환하게 된 것입니다.

</br>


### 기명 튜플 (NamedTuple) {#sec-named_tuple}

기명 튜플은 튜플과 유사하나 성분 하나마다 특별한 이름이 붙으며, 성분에 접근할 때 인덱스를 이용할 수도 있고, 그 이름을 이용할 수도 있습니다. 기명튜플도 immutable 이므로 값을 변경하거나, 성분을 추가하거나 삭제 할 수 없습니다.

```txt
In [6]: ntup1 = (b=1, a=2)
Out[6]: (b = 1, a = 2)

In [7]: ntup1.a
Out[7]: 2

In [8]: ntup1[1]
Out[8]: 1
```

</br>

### 사전 (Dictionary) {#sec-dictionary}

사전은 키(key)-값(value) 를 묶어서 여러 타입을 저장하는 컨테이너으로 성분의 값을 변경 할 수 있는 mutable 타입입니다. 아래와 같이 `Dict` 를 통해 선언하며 `[ ]` 를 통해 접근하거나 값을 변경 할 수 있습니다. 기명 튜플과는 달리 인덱스로는 접근 할 수 없습니다. 사전은 아래에서 보듯이 명시적으로 키와 와 값의 타입을 알려주지 않았더라도, 그 타입이 정의되며 만들어집니다. 아래의 `dict1` 은 키인 `"a"`, 와 `"b"` 가 모두 문자열이기 때문에 키는 문자열 타입으로, 값인 `1` 과 `2` 가 모두 `Int64` 타입이므로 값은 `Int64` 타입으로 정의되었습니다. 즉 `dict1` 을 만들었을 때의 출력 `Dict{String, Int64}` 는 키가 문자열(`String`) 타입이며 값이 64비트 정수(`Int64`) 타입으로 한정된 사전이라는 것을 의미합니다. 원래 사전은 mutable 타입이므로 새로운 키-값 을 추가 할 수 있지만, 이것은 처음 정의될 때의 사전의 키-값 타입이 허용하는 범위 안에 있을 때만 가능합니다.

```txt
In [10]: dict1=Dict("a"=>1, "b"=>2) # 사전 선언
Out[10]: Dict{String, Int64} with 2 entries:
  "b" => 2
  "a" => 1

In [11]: dict1["a"] # 사전의 성분 접근
Out[11]: 1

In [12]: dict1["a"]=3 # 사전의 값 변경
Out[12]: 3

In [13]: dict1
Out[13]: Dict{String, Int64} with 2 entries:
  "b" => 2
  "a" => 3

In [14]: dict1["c"]=-2 # 사전에 새로운 키-값 추가
Out[14]: -2

In [15]: dict1
Out[15]: Dict{String, Int64} with 3 entries:
  "c" => -2
  "b" => 2
  "a" => 3

In [16]: dict1["d"]=3.3 # 사전의 값의 타입 범위를 벗어나는 키-값 추가 시도는 실패한다.
ERROR: InexactError: Int64(3.3)
...
```

`keys()`, `values()` 함수를 통해 사전의 key 와 value 를 얻을 수 있으며, `haskey()` 함수를 통해 해당 key 가 사전에 존재하는지 확인 할 수 있습니다.

```txt
In [17]: keys(dict1)
Out[17]: KeySet for a Dict{String, Int64} with 3 entries. Keys:
  "c"
  "b"
  "a"

In [18]: values(dict1)
Out[18]: ValueIterator for a Dict{String, Int64} with 3 entries. Values:
  -2
  2
  3

In [19]: haskey(dict1, "a")
Out[19]: true

In [20]: haskey(dict1, "c")
Out[20]: true
```

사전에 key, value 를 추가할때는 `dict1["f"]=5` 와 같이 합니다. 사전의 값을 호출할때는 `dict1["a"]` 처럼 사용합니다. 


사전을 처음 선언 할 때 타입을 정할 수 있습니다. 또한 임의의 타입의 키-값을 갖는 사전도 정할 수 있습니다. 예를 들어 아래의 `In [21]` 과 같이 `Dict{Any, Any}` 로 시작하는 정의를 사용하면 모든 타입의 키와 값 을 가질 수 있습니다. `Any` 는 `Int64` 나 `Rational` 과 같은 타입 이름으로 모든 타입을 포함하는 최상위 타입입니다. 타입에 대해 자세한것은 [타입 계층 구조](08_type_hierarchy.qmd#sec-type_hierarchy)  에서 알아볼 것입니다.

```txt
In [21]: dict3=Dict{Any, Any}("a"=>1)
Out[21]: Dict{Any, Any} with 1 entry:
  "a" => 1

In [22]: dict3[4]="abcd"
Out[22]: "abcd"

In [24]: dict3["sinfunction"]=sin
Out[24]: sin (generic function with 14 methods)

In [25]: dict3["sinfunction"](π/2)
Out[25]: 1.0
```

이 때 `dict3[4]` 의 `4` 는 인덱스가 아닌 키 입니다. 정수 뿐 아니라, 부동소수나 복소수도 키가 될 수 있습니다. `In [24]` 는 사전의 값으로 함수가 오는 것을 보여줍니다. `In [25]` 에서 볼 수 있듯이 사전과 키를 이용하여 함수처럼 사용 할 수 있습니다.

</br>

### 문자열 (String) {#sec-collections_string}

앞서 타입에서 알아본 문자열(String) 도 개별적인 문자에 인덱스로 접근 할 수 있으며 `length()` 함수로 그 길이를 알 수 있다는 점에서 컨테이너입니다. 개별적인 문자에 인덱스로 접근 할 수 있지만 바꿀 수 없으므로 immutable 입니다.

</br>

### 집합 (Set) {#sec-set}

집합은 아이템의 추가나 삭제는 가능하지만 인덱스로도, 키로도 접근 할 수 없는 mutable collection 입니다. 수학적인 집합과 동일하게 같은 값을 두 개 이상 가질 수 없습니다. 예를 들어 `tuple1 = (1, 2, 3, 1)` 은 `1` 값을 두개 가지고 있지만 `set1 = Set([1, 2, 3, 1])` 은 `1` 이 중복되므로 아이템의 갯수는 3개 입니다. 아이템을 추가할때는 `push!` 함수를 사용하여 `push!(set1, 5)` 와 같이 하며, 아이템을 제거할때는 `pop!(set1, 3)` 처럼 사용합니다. 마치 수학의 집합처럼 합집합 `∪`(`\cup` + [tab]) 나 교집합 `∩`(`\cap` + [tab]) 연산자를 통해 합집합과 교집합을 계산 할 수 있습니다. 실제로 `∪` 나 `∩` 는 다른 컨테이너 타입에도 사용 할 수 있습니다.

```txt
In [11]: A=Set([1,2, 3]);B= Set([-1, 0, 1]);

In [12]: A ∪ B
Out[12]: Set{Int64} with 5 elements:
  0
  2
  -1
  3
  1

In [13]: A ∩ B
Out[13]: Set{Int64} with 1 element:
  1

In [14]: intersect(A, B)
Out[14]: Set{Int64} with 1 element:
  1

In [15]: union(A, B)
Out[15]: Set{Int64} with 5 elements:
  0
  2
  -1
  3
  1

In [16]: (1,2, 3) ∩ [ 3, 4, 5]
Out[16]: 1-element Vector{Int64}:
 3
```

</br>

## 일반적인 컨테이너에 대한 연산

### `∈`, `∉` {#sec-in_notin}

우선 `in` 혹은 `∈` (`\in`+[tab]) 은 어떤 아이템이 컨테이너에 속해있는지 여부를 `true`/`false` 로 반환합니다. 반대로 `∉`(`\notin`+[tab]) 은 아이템이 컨테이너에 포함되어 있지 않을 때 `true` 를 반환합니다. StepRange, 벡터, 집합에의 포함 여부는 다음과 같이 알 수 있습니다.

```txt
In [10]: 1 ∈ 1:10
Out[10]: true

In [11]: "a" ∈ (2, "5", "a")
Out[11]: true

In [12]: "a" ∉ (2, "5", "a")
Out[12]: false
```

</br>

Julia 는 키-값 쌍을 `Pair` 라는 객체로 처리합니다. 사전에 어떤 키가 포함되어있는지, 값이 포함되어 있는지는 `keys`, `values` 함수로 알 수 있습니다. 키-값 쌍이 있는지는 다음과 같이 확인 할 수 있습니다.

```txt
In [13]: Pair("a", 1) ∈ Dict("a"=>1, "b"=>2)
Out[13]: true
```

</br>

우리는 앞서 홑따옴표 `' '` 안에는 글자 하나만 포함 될 수 있으며 `Char` 타입이고 겹따옴표 `" "` 는 한줄 문자열, 세겹따옴표는 `""" """` 여러줄 문자열을 포함한다는 것을 알았습니다. 따라서 `∈` 나 `∉` 연산자로 포함 여부를 확인할 때 연산자의 왼쪽에는 `Char` 형식의 한 글자에 대해서만 가능합니다. 즉

```txt
In [19]: 'a' ∈ "abc"
Out[19]: true

In [20]: "a" ∈ "abc"
ERROR: use occursin(needle, haystack) for string containment
...
```

의 결과를 보입니다. `"a"` 는 하나의 성분을 갖는 컨테이너이므로 `∈` 나 `∉` 의 왼쪽에 올 수 없습니다.

</br>

### `length` {#sec-length}

`length` 함수는 컨테이너에 포함된 아이템의 갯수를 반환합니다.

```txt
In [1]: length(Dict("a"=>1, "b"=>2))
Out[1]: 2

In [2]: length([1, 2, (3, 4, 5)])
Out[2]: 3
```

</br>

### `eltype` {#sec-eltype}

`eltype` 은 컨테이너에 포함된 아이템의 타입을 반환합니다. 

```txt
In [1]: eltype([1.0, 2.0, 3.0])
Out[1]: Float64

In [2]: eltype(['a', 'b', 'c'])
Out[2]: Char
```

</br>

### `unique` {#sec-unique}

컨테이너에 포함된 아이템 가운데 중복되는 것을 제외한 아이템들을 벡터로 반환합니다.

```txt
julia> unique((1, 2, 3, 1, 2, 4))
4-element Vector{Int64}:
 1
 2
 3
 4
```

</br>

### `...` 연산자 {#sec-splat}

[`...` 연산자가 함수의 정의나 실행시에 사용되는 것에 대해서는 [Interude : '...' 연산자](04I_splat_operator.qmd) 에 대해 좀 더 자세히 다루었습니다.]{.aside} 

순서가 있는 컨테이너에서 앞부분의 몇개만 중요할 때 사용할 수 있습니다. 예를 들어

```txt
In [1]: a, b, c... = [4, 8, 15, 16, 23, 42]
Out[1]: 6-element Vector{Int64}:
  4
  8
 15
 16
 23
 42

In [2]: a
Out[2]: 4

In [3]: b
Out[3]: 8

In [4]: c
Out[4]: 4-element Vector{Int64}:
 15
 16
 23
 42
```

입니다. 즉 1차원 배열 `A` 에 대해 첫번째 두개만 중요할 경우 `a, b, c.. = arr1` 와 같이 사용하면 `a==A[1]`, `b==A[2]` 이며 `c==A[3:end]` 가 됩니다.


</br>

## 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산

여기서는 벡터나 StepRange 같은 인덱스로 접근 가능한 컨테이너에 대해 성분이 모두 수로 이루어졌을 때 사용할 수 있는 연산에 대해 다루도록 하겠습니다. 많은 경우 수가 아닌 경우에도 사용 할 수 있지만 여기서는 수로 이루어진 컨테이너에 대해서만 논의하기로 합니다.

</br>

### `.` 연산 (도트 연산) {#sec-dot_operation}

벡터나 튜플, StepRange 같은 컨테이너의 아이템 마다 함수나 연산자를 적용시킬 때 도트 연산자 `.` 를 사용할 수 있습니다. 함수 이름의 끝에 `.` 를 붙이거나, 연산자의 앞에 `.` 를 붙입니다. 이를 도트 연산이라고 합니다.

- 스칼라와 컨테이너의 연산에서는 컨테이너의 각 성분과 스칼라와의 연산 결과를 반환합니다.

- 순서가 있는 컨테이너과 컨에티너의 연산에서는 컨테이너의 각 순서별 성분끼리 연산합니다. 

- 순서가 없는 컨테이너(예를 들어 집합(`Set`)) 에 도트연산을 수행 할 수 있지만 그 순서가 유지되지 않으며, 어쨋든 계산이 되면 그 결과는 벡터가 됩니다.

아래의 코드를 봅시다.

```txt
# 스칼라와 컨테이너의 도트 연산
In [13]: 3 .* (1, 2, 3)
Out[13]: (3, 6, 9)

# 순서가 있는 컨테이너의 도트 연산
In [14]: [1, 2, 3] .* [-1, 0, 1]
Out[14]: 3-element Vector{Int64}:
 -1
  0
  3

# 함수에서의 도트 연산. 함수 이름 끝에 . 를 붙이기만 하면 됩니다.
In [15]: sin.([-π/2, 0.0, π/2])
Out[15]: 3-element Vector{Float64}:
 -1.0
  0.0
  1.0

# 순서가 없는 컨테이너에 대한 도트 연산. 순서가 유지되지 않음.
In [16]: 3.0 .* Set([1, 2, 3])
Out[16]: 3-element Vector{Float64}:
 6.0
 9.0
 3.0
```

</br>

함수나 연산자마다 `.` 을 붙여주는 것이 코드의 가독성을 해치거나 오류의 원인이 될 수 있습니다. 이때는 표현식 앞에 `@.` 를 붙여주면 julia 는 모든 연산자와 함수에 필요할 때 `.` 가 붙은 것처럼 작동하도록 합니다. `@` 로 시작하는 명령문은 매크로라고 하며 특정한 기능을 하는 함수로 julia 의 핵심적인 기능중의 하나입니다. 자세한 것은 [메타프로그래밍과 매크로](10_metaprogramming_and_macro.qmd) 에서 다루겠습니다. 일단 다음 코드를 봅시다.

```txt
In [1]: @. 3+[1,2,3,4]
Out[1]: 4-element Vector{Int64}:
 4
 5
 6
 7

In [2]: @. sin(0.0:0.1:π)
Out[2]: 32-element Vector{Float64}:
 0.0
 0.09983341664682815
 0.19866933079506122
 0.2955202066613396
 0.3894183423086505
 0.479425538604203
 ⋮
 0.4273798802338298
 0.33498815015590466
 0.23924932921398198
 0.1411200080598672
 0.04158066243329049

In [3]: a = @. 3 * [1,2,3]
Out[3]: 3-element Vector{Int64}:
 3
 6
 9

```

::: {.callout-warning icon="false"}

#### 도트연산자와 소숫점의 혼동

`3.*[1, 2, 3]` 수행하면 (`3` 과 `.*` 사이에 공백이 없는 경우 입니다) 에러가 발생합니다. Julia 에서는 정수 다음에 `.` 이 붙을 경우 부동소수로 간주합니다. 예를 들어 julia 는 `-1.` 을 `-1.0` 으로 해석합니다. 따라서 `3.*[1, 2, 3]` 는 `(3.0) * [1, 2, 3]` 로 해석 될 수도 있고 `(3) .* [1, 2, 3]` 으로 해석 될 수도 있습니다. `.*` 와 같이 도트를 앞에 붙여서 사용하는 연산의 경우는 `.` 앞에 공백을 앞에 두는 습관을 들이는 것이 좋습니다.
:::

1차원 컨테이너 끼리의 도트 연산을 위해서는 컨테이너의 크기가 같아야 합니다. 다차원 배열의 경우는 [배열](06_arrays.qmd#sec-array) 에서 다루겠습니다. 


</br>

### `minimum`, `maximum`, `extrema` {#sec-extrema}

이 함수들은 컨테이너에 포함되는 값 가운데의 최소값(`minimum`), 최대값(`maximum`), 그리고 둘 다(`extrema`)를 반환합니다. 단 이때는 컨테이너의 모든 아이템들이 서로 비교 가능해야 합니다. 예를 들어 정수와 부동소수는 비교가능 하지만 수와 문자열은 서로 크기를 비교 할 수 없습니다. 따라서 수와 문자열을 같이 포함하는 컨테이너에서는 위의 함수들을 사용 할 수 없습니다.

```txt
In [23]: extrema(1:5)
Out[23]: (1, 5)

In [24]: maximum([1, 2, "ab"])
ERROR: MethodError: no method matching isless(::String, ::Int64)
...
```

이 함수들은 어떤 컨테이너의 극값 뿐만 아니라 컨테이너에 함수를 적용했을 때의 최대값 최소값을 구하는 데도 사용 할 수 있습니다. 예를 들어, 

```txt
In [25]: extrema(cos, 0:π/1000:π)
Out[25]: (-1.0, 1.0)
```

는 `0:π/1000:π` 에 대한 각각의 `cos` 값의 최소값과 최대값을 반환합니다.


</br>

### `argmin`, `argmax`, `findmin`, `findmax` 

`argmin`, `argmax` 는 각각 컨테이너에서 최소값과 최대값의 인덱스를 반환하며, 그 값이 여러개일 경우 첫번째 인덱스를 반환합니다. `findmin`, `findmax` 는 각각 최대값, 최소값에 대해 값과 인덱스를 튜플로 반환합니다.


```txt
In [29]: argmin([2, 3, 1, 2, 3, 1, 4, 1, 6])
Out[29]: 3

In [30]: findmax([2, 3, 1, 2, 3, 1, 4, 1, 6])
Out[30]: (6, 9)
```

함수에 대한 결과값의 최대, 최소를 구할 수도 있습니다.

```txt
In [35]: findmax(cos, range(0.0, π, length=30))
Out[35]: (1.0, 1)
```


::: {.callout-warning icon="false"}

#### `argmin`, `argmax` 의 주의사항

`argmin`, `argmax` 도 함수를 입력하면 에러가 나지 않지만 우리가 기대하는 행동을 하지 않습니다. 예를 들어


```txt
In [37]: argmin(cos, range(0.0, π, length=30))
Out[37]: 3.141592653589793
```

의 경우 `range(0.0, π, length=30)` 에 `cos` 함수를 적용시켰을 때 최소값이 나오는 인덱스(이경우`30`) 이 나오길 기대할 수 있지만 `cos` 함수를 최소화하는 `range(0.0, π, length=30)` 에서의 값을 반환합니다. `argmax` 도 같은 방식으로 동작합니다. 혼란을 줄 수 있으므로 왠만하면 `argmin`, `argmax` 는 사용하지 말고 `findmin`, `findmax` 를 사용하시기를 권합니다.
:::


</br>

### `map`

함수 `f` 와 컨테이너 `c` 에 대해 `map(f, c)` 는 `c` 의 개별적인 성분에 `f` 를 적용한 값을 리턴합니다. 

```txt
In [1]: map(abs, [1, -1, 2, -2, 3, -5])
Out[1]: 6-element Vector{Int64}:
 1
 1
 2
 2
 3
 5
```

</br>

인자가 여러개인 함수에 대해서는 여러개의 컨테이너를 인자로 입력합니다.

```txt
In [4]: f(x, y) = x+y
Out[4]: f (generic function with 1 method)

In [5]: map(f, [1,2, 3], [3, 4,5])
Out[5]: 3-element Vector{Int64}:
 4
 6
 8
```

</br>

인자로 주어지는 컨테이너의 갯수가 다를 때는 길이가 최소인 컨테이너에 맞추며 나머지 컨테이너의 성분은 무시합니다.

```txt
In [6]: map(f, [1,2, 3], [3, 4,5, 6, 7])
Out[6]: 3-element Vector{Int64}:
 4
 6
 8
```

</br>

함수 뿐만 아니라 연산자가 올 수 도 있습니다.

```txt
In [8]: map(÷, [4, 7, 9], [2, 3, 5])
Out[8]: 3-element Vector{Int64}:
 2
 2
 1
```

</br>

#### 익명 함수의 사용 {#sec-anonymous_function_in_map}

`map` 뿐만 아니라 바로 뒤에 나올 `reduce`, `mapreduce`, `filter` 에 [익명 함수](03_functions_and_operators.qmd#sec-anonymous_function) 가 아주 유용하게 사용될 수 있습니다. 예를 들어 

```txt
In [3]: map(x->cos(x)+1, range(0, π, length=4))
Out[3]: 4-element Vector{Float64}:
 2.0
 1.5
 0.5000000000000002
 0.0
```

를 봅시다. `range(0, π, length=4)` 는 `0` 부터 `π` 까지 같은 간격을 가진 4개의 성분을 가진 배열을 만듭니다. 이 배열의 각각의 성분에 `cos` 함수를 취한후 `1` 을 더하는 익명함수 `x->cos(x)+1` 을 적용시킨 결과입니다. 도트 연산자르르 사용하면 똑같은 일을 할 수 있지만 아무래도 `map` 함수 쪽이 훨씬 읽기 편합니다.

```txt
In [3]: cos.(range(0, π, length=4)) .+ 1
```
</br>

#### `do ... end`, `begin ... end` 의 사용 {#sec_usage_of_do_end_begin_end}

`do ... end` 구문이나 `begin ... end` 구문 역시 일종의 익명 함수를 만드는 데 사용될 수 있습니다. 당연히 컨테이너에만 사용되는 것은 아니지만 컨테이에 대한 연산, 특히 `map` 이나 앞으로 나올 `reduce`, `filter` 등의 함수에 유용하게 사용 할 수 있습니다. 일단 `In [3]` 와 같은 결과를 내는 코드는 다음과 같습니다.$^\ast$ [$^\ast$ 함수의 정의에서 `return` 문이 없다면 `end` 바로전의 표현식의 결과를 반환한다는 것을 알았습니다. 아래 코드에서도 마찬가지로 `return cos(x)+1` 대신에 `cos(x)+1` 만 있어도 실행됩니다.]{.aside}

```txt
In [4]: map(range(0, π, length=4)) do x
        return cos(x)+1
        end

In [5]: map( x-> begin
        return cos(x) +1
        end
        , range(0, π, length=4))
```

우선 함수 `f1` 을 첫번째 인자로 받는 함수 `mfunc(f1, b...)` 에서 `f1` 의 정의를 `mfunc(b...) do x` 로 시작합니다. 이 때 `x` 는 `f1` 의 인자입니다. 그 이후 구문은 `end` 가 나올 때 까지 `f1` 을 정의하는 구문과 같습니다. `do ... end` 구문이나 `begin ... end` 구문에서는 변수를 선언하여 활용 할 수 있습니다. 

```julia
map(0.0:0.1:π) do x
    y = sqrt(x)
    z = x^2
    cos(y+z)
end
```

이 코드는 다음과 두 코드와 각각 같습니다.

```julia
function f1(x)
    y = sqrt(x)
    z = x^2
    cos(y+z)
end

map(f1, 0.0:0.1:π)
```

```julia
map(x->begin
    y = sqrt(x)
    z = x^2
    cos(y+z)
    end, 
    0.0:0.1:π)
```

</br>

### `reduce`

`map` 이 컨테이너의 각 성분에 연산을 수행한다면, 그래서 결과는 입력된 컨테이너의 길이와 같은 벡터가 된다면 `reduce` 는 컨테이너에 대해 각각의 성분에 대해 연산을 수행하여 하나의 값을 얻는데 사용합니다. 예를 들어

```julia
reduce(+, [1,2, 3, 4])
```

를 봅시다. `reduce` 는 우선 첫번째와 두번째 성분으로 주어진 연산자나 함수에 대해 계산한 후 결과값을 세번째성분과 계산하고 이것을 마지막 성분까지 계속합니다. 즉 위의 코드는 `(((1+2)+3)+4)` 와 같습니다. 그렇다면

```julia
reduce(-, [1,2, 3, 4])
```

는 `(((1-2)-3)-4)` 와 같습니다.


</br>

### `mapreduce`

`mapreduc` 는 `map` 과 `reduce` 를 합친 기능을 합니다. `mapreduce(f, op, iter)` 는 `reduce(op, map(f, iter))` 와 같은 역할을 합니다. 예를 들어 다음 두 명령어는 기능적으로 같습니다. `1` 에서 `10` 까지의 정수를 제곱한 배열을 만든 후 그 배열의 합을 구하는 것입니다. 

```julia
mapreduce(x->x^2, +, 1:10)
reduce(+, map(x->x^2, 1:10))
```

</br>

#### `filter`


`filter(f, c)` 에서 `f` 는 `true` 혹은 `false` 를 반환하는 함수나 연산자이어야 합니다. 컨테이너의 성분에 함수를 적용했을 때 참인 성분만을 골라 반환합니다. 예를 들어,

```txt
In [1]: filter(x->(x>3), [1,2,3,4,5])
Out[1]: 2-element Vector{Int64}:
 4
 5
```

를 봅시다. `x->(x>3)` 은 익명함수로 `x>3` 의 조건을 만족하면 `true`, 그렇지 않다면 `false` 를 리턴합니다. 따라서 이 조건을 만족하는 `[4, 5]` 만을 반환합니다.

참고로 3보다 큰 성분을 배열로 리턴하는 것이 아니라 3보다 크면 1, 3보다 작으면 0 을 리턴하도록 하려면 어떻게 하면 될까요? 아래를 보고 왜 이렇게 작동하는지 생각해 보시기 바랍니다.

```txt
In [2]: [1, 2, 3, 4, 5] .> 3
Out[2]: 5-element BitVector:
 0
 0
 0
 1
 1
```

</br>








