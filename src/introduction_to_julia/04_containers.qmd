---
title: "컨테이너"
language: ../_language-ko_custom.yml 

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

여러 개의 데이터를 저장하고 처리하기 위한 데이터 타입을 컨테이너(container)이라고 하며, 대표적으로 튜플(tuple), 사전(dictionary), `StepRange` 등이 있습니다. 컨테이너은 기본적으로 `length` 함수를 통해 포함되어 있는 아이템의 갯수를 알 수 있으며, iterator 이므로 포함되어 있는 아이템을 순회할 수 있습니다. 순서가 있는 컨테이너일 경우 순서대로 1, 2, ... 의 인덱스를 가지며 포함하는 객체에 접근하여 값을 가져오거나 값을 변경할 때 정수 인덱스로 접근 할 수 있습니다. 순서가 중요하지 않은 컨테이너 일 경우 값마다 지정된 키(key) 인덱스를 통해 접근할 수 있습니다. 집합 타입의 컨테이너의 경우는 인덱스로도, 키로도 접근할 수 없습니다.  컨테이너에서 아이템을 더하거나 뺄 수 있다면 이 컨테이너이 mutable 하다고 하며, 한번 생성된 컨테이너을 변경 할 수 없다면 immutable 하다고 합니다.


</br>

## 대표적인 컨테이너들 {#sec-collections}

Julia 에서는 많은 종류의 컨테이너을 기본적으로 제공하며, 이 가운데 가장 많이 사용되는 것들의 특징을 정리하였습니다.

| 이름 | 정수 인덱스로 접근 | 키 인덱스로 접근 | mutable | 
|:------:|:---:|:---:|:---:|
| 튜플 (`Tuple`) | o | x | x | 
| 기명 튜플 (`NamedTuple`) | o | o | x |
| 사전 (`Dictionary`) | x | o | o | 
| StepRange (`StepRange`) | o | x | x | 
| 집합 (`Set`) | x | x | o | 
| 배열 (`Array`) | o | x | o | 

: 대표적인 컨테이너과 그 특징 {#tbl-properties_of_collections}

</br>

### 배열 (Array) {#sec-arrays_0}

배열은 정수 인덱스로 접근하는 같은 타입의 성분을 갖는 다차원 컨테이너으로 mutable 입니다. 수치 해석에서 기본이 되는 벡터, 행렬과 이미지 등은 대부분 배열로 처리되며, 너무나 중요하기 때문에 이후 [배열](06_arrays.qmd#sec-array) 에서 자세히 다루고 여기서는 1차원 배열에 대해서만 간단히 다루도록 하겠습니다.

</br>

### 1차원 배열 (Vector) {#sec-vector}

1차원 배열은 `Vector` 라고 불리며 `[ ]` 안에 쉼표로 분리되어 나열된 아이템을 성분으로 갖는 컨테이너 입니다. 수를 비롯하여 모든 타입의 아이템을 포함할 수 있으며 삽입과 삭제가 자유로운 mutable 타입으로 정수 인덱스로 접근합니다. 

```julia
In [4]: vec1 = [1, 2, "a", 3.4, "bbc"]
Out[4]: 5-element Vector{Any}:
 1
 2
  "a"
 3.4
  "bbc"
```

와 같이 정의합니다. 이 때 `vec1[1]=1` 이며 `vec1[5]="bbc"` 입니다. `Vector` 옆의 `{Any}` 는 벡터의 성분(벡터에 포함된 아이템을 성분(entry, element) 라고 합니다.) 의 타입입니다. 배열은 mutable 이므로 성분을 인덱스로 접근하여 변경 할 수 있습니다.

::: {.callout-note icon="false"}

#### 명령문 끝의 `;`

Julia REPL 에서 명령어 다음에 세미콜론 `;` 을 붙이면 명령을 수행하지만 그 결과는 출력하지 않습니다. Jupyter 나 vscode 환경에서도 마찬가지 입니다. 

```julia
In [5]: vec1[2]=2.2; vec1
Out[5]: 5-element Vector{Any}:
 1
 2.2
  "a"
 3.4
  "bbc"
```
:::

</br>

::: {.callout-note icon="false"}

#### 함수명 끝의 `!`

Julia 에서는 함수명을 붙일 때 관례적으로 함수의 어떤 인자를 변경하는 함수라면 그 이름 끝에 `!` 를 붙입니다. 다음부터 나올 `push!` 나 `pop!` 함수 이름에 `!` 가 붙은것은 이 함수가 직접 `vec1` 을 변경하기 때문입니다. 직접 변경하지 않을 때는 `!` 를 붙이지 않습니다.

:::



벡터에 성분을 마지막에 추가하고 싶으면 `append!(vec1, item1, item2, .. )` 처럼 사용합니다. 그렇게 되면 `vec1` 에 `item1`, `item2` 가 차례대로 추가됩니다. 만약 `item1`, `item2`... 들이 컨테이너이라면 `vec1` 에 `item1` 를 순서대로 합칩니다.

::: {#exr-vector_append}
`append!(vec1, [2, 4], ["k", "g"])` 를 수행해 보세요.
:::


어떤 정해진 인덱스에 삽입하려면 `insert!(vec1, index1, item1)` 처럼 사용합니다. 그렇게 되면 `vec1[index1] == item1` 이 되며 원래 `index1` 에 위치했던 아이템과 그 뒤의 아이템들의 인덱스가 하나씩 늘어나게 됩니다. `item` 이 컨테이너이라도 `append!` 처럼 컨테이너의 아이템이 순서대로 삽입되지 않고 컨테이너 자체로 삽입됩니다. (타입이 지정된 벡터이면 에러가 발생합니다.)


```julia
In [6]: vec1 = [1, 2, "a", 3.4, "bbc"];

In [7]: insert!(vec1, 3, "II")
Out[7]: 6-element Vector{Any}:
 1
 2
  "II"
  "a"
 3.4
  "bbc"

```

특정 인덱스의 아이템을 삭제하고 싶으면 `deleteat!` 함수를 사용합니다. 만약 `vec1[4]` 인 "a" 를 삭제하고 싶으면 `deleteat!(vec1, 4)` 처럼 사용합니다.

Julia 의 모든 타입은 `Any` 로부터 가지처럼 뻗어나가는 계층 구조를 가지고 있습니다. 여기에 대해서는 [타입의 계층구조](08_type_hierarchy.qmd#sec-type_hierarchy) 에서 좀 더 자세히 알아 볼 것입니다. 벡터를 정의할 때 `vec1` 처럼 여러 타입을 가진 아이템을 포함한다면 julia 가 알아서 적절한 타입으로 변환합니다. 정수와 부동소수만으로 이루어진 배열은 자동적으로 부동소수로 변환됩니다. `Any` 는 모든 타입을 포함 할 수 있는 타입이므로 임의의 타입을 위한 배열의 타입으로 사용됩니다. 당분간은 배열은 특정한 타입만을 포함 할 수 있으며, 임의의 타입을 포함하고 싶을때는 `Vector` 다음에 `{Any}` 를 명시적으로 붙인다고 알고 있겠습니다.


::: {.callout-note icon="false"}

#### Promotion

연산에서 같은 타입이 아닐 때 타입을 조정하는것을 *promotion* 이라고 합니다. 예를 들자면 `2+3.0` 이나 `3.3 + π` 을 계산하는 경우 둘의 타입이 다르기 때문에 julia 가 적절한 타입, 이 경우는 둘 다 부동소수로 타입으로 변환합니다.
:::


```julia
In [1]: vec2=Vector{Any}([1,2,3]);

In [2]: ec3=Vector([1,2,3]);
```

`vec2` 와 `vec3` 는 모두 세 정수로 이루어진 벡터이지만 `vec2` 는 `Any` 타입으로 지정되었습니다. 따라서 `insert!(vec2, 2, "A")` 는 동작하지만 `insert!(vec3, 2, "A")` 는 동작하지 않습니다.

`push!` 와 `pop!` 은 벡터의 미지막에 어떤 아이템을 추가하거나, 마지막 아이템을 제거하는 명령입니다. `push!(vec3, 5)` 나 `pop!(vec3)` 처럼 사용합니다. `pop!` 의 경우 제거된 아이템을 반환합니다.

```julia
In [3]: push!(vec3, 5)
Out[3]: 4-element Vector{Int64}:
 1
 2
 3
 5

In [4]: pop!(vec3)
Out[4]: 5

In [5]: vec3
Out[5]: 3-element Vector{Int64}:
 1
 2
 3
```

::: {#exr-functions_for_vector}
`pushfirst!`, `popfirst!`, `empty!` 함수를 알아보고 벡터를 변형시켜 봅시다.
:::


</br>

### StepRange {#sec-steprange}

일정한 간격으로 나열되는 수를 위한 immutable 컨테이너입니다. 대표적으로 `start:step:end` 형식이나 `start:end` 형식으로 할당하며, 후자의 경우 `start` 와 `end` 의 타입으로부터 `1` 혹은 `1.0` 의 간격을 갖도록 만들어집니다. 

- `range1 = start:step:end` 형식으로 만들 경우 1 부터 시작하는 인덱스 `i` 에 대해 `range1[i] == start + (i-1)*step` 값을 가지며 당연히 `end` 값을 넘지 않습니다. 그리고 `end` 값을 포함 할 수 있습니다. `1:1:5` 의 경우는 5번째 값은 `5` 입니다. [python 의 경우 `range(1, 5)` 나 `numpy.arange(1, 5)` 로 생성하는 배열은 `5` 를 포함하지 않습니다.]{.aside}

- `end > start` 일 경우는 `step` 값이 `0` 보다 작아야 합니다.

::: {#exr-range-1}
`start > end` 일 때, `step` 값을 양수로 정의해 보거나, `start < end` 일 때 `step` 값을 음수로 정의하고 인덱스를 통해 접근해 보기 바랍니다. 또한 `start == end` 일 때는 어떻게 되는지 확인해 보기 바랍니다.
:::

`range` 함수를 통해서도 생성 할 수 있습니다. `range(1, 10, step=1)` 은 `1:1:10` 과 같습니다. 또한 `range(start=0.0, stop=π, length=100)` 은 0 부터 $\pi$ 까지 100 개의 길이를 가진 Range 만듭니다. 자세한 것은 julia 의 기본 문서에서 `range` 를 검색해 보기 바랍니다.

많은 경우 StepRange 는 벡터처럼 동작하지만 immutable 이므로 수정 할 수 없습니다. 그리고 많은 경우 수학 함수에 적용되면 결과가 벡터로 변환됩니다. 

```julia
In [6]: sin.(0.0:0.1:π)
Out[6]: 32-element Vector{Float64}:
 0.0
 0.09983341664682815
 0.19866933079506122
 0.2955202066613396
 0.3894183423086505
 0.479425538604203
 0.5646424733950355
 0.6442176872376911
 ⋮
 0.5984721441039564
 0.5155013718214642
 0.4273798802338298
 0.33498815015590466
 0.23924932921398198
 0.1411200080598672
 0.04158066243329049
 ```


</br>

### 튜플 (Tuple) {#sec-tuple}

튜플은 벡터처럼 인덱스를 통해 포함하는 아이템에 접근 할 수 있지만 새로운 아이템을 추가할 수도 없고, 포함하는 아이템을 삭제할 수도 없습니다. 즉 immutable 입니다. 튜플은 `tuple1 = (1, 3.3, 'A', cos, (2, "a", sin))` 과 같이 `( )` 안에서 `,` 로 구분하여 선언합니다. 여기서 `A` 는 `Char` 타입, "a" 는 `String` 타입이며, `sin`, `cos` 는 함수입니다. (Julia 에서 함수는 `Function` 타입입니다.) 튜플에서는 `1` 부터 시작되는 인덱스를 이용하여 포함된 아이템에 접근 할 수 있습니다. 앞서의 `tuple1` 의 경우, `tuple1[1]==1` 이며, `typle1[3]=='A'` 입니다. `tuple[5]== (2, "a", sin)` 이므로 `tuple1[5][2]=="a"` 입니다. `tuple1[5][3]==sin` 인 함수이므로 다음과 같은 결과를 얻을 수 있습니다.

```julia
In [1]: tuple1 = (1, 3.3, 'A', cos, (2, "a", sin))
Out[1]: (1, 3.3, 'A', cos, (2, "a", sin))

In [2]: tuple1[5][3](π/2)
Out[2]: 1.0
```

tuple 은 immutable 한 컨테이너이므로 `tuple1[2]=4.4` 와 같은 방식으로 아이템을 변경 할 수 없으며, 성분을 추가하거나 삭제할 수도 없습니다.

</br>

::: {#exr-tuple_error1}
임의의 튜플을 만든 후 인덱스를 통해 아이템을 변경해 보고 그 에러를 확인해 보세요.
:::

</br>

튜플이 벡터와 구별되는 것 가운데 하나는 포함되는 아이템의 타입을 일치시키려 하지 않는 점 입니다. 앞서 보았듯이 `vec0 = [1, 2.0]` 를 수행하면 맨 처음의 `1` 은 벡터가 되면서 `2.0` 의 타입을 고려하여 `Float64` 타입인 `1.0` 으로 변경됩니다. 이것은 `vec0 = Vector{Any}([1, 2.0])` 를 해도 마찬가지 입니다. 그러나 튜플은 다릅니다.

```julia
julia> tup0 = (1, 2.0)
(1, 2.0)
```

와 같이 타입을 일치시키려 하지 않습니다. 

</br>

튜플이 가장 흔하게 사용되는 곳은 함수의 `return` 에서 입니다. 만약 함수가 아래와 같이 여러개의 값을 `,` 로 구분하여 반환한다면 이것은 이 값들을 순서대로 묶은 튜플을 반환하는 것입니다. 아래의 `return3()` 함수는 그냥 1, 2, 3 을 반환하는 함수인데, 리턴값은 이 값을 묶은 튜플입니다. 아래의 함수는 1, 2, 3 을 반환하는 함수입니다.

```julia
function return3()
    return 1, 2, 3
end
```
이 함수를 실행시키면 튜플 `(1, 2, 3)` 을 반환합니다.

```julia
In [3]: return3()
Out[3]: (1, 2, 3)
```

</br>

튜플을 사용하는 기법중의 하나가 두 변수의 값을 서로 바꿀 때 입니다. 예를 들어 다음 코드를 봅시다.

```julia
In [4]: a=1;b=2;a, b = b, a
Out[4]: (2, 1)

In [5]: println("a=$a, b= $b")
a=2, b= 1
```

우선 `a`, `b` 에 각각 1 과 2 를 할당했습니다. 그 다음의 `a, b = b, a` 를 봅시다. 우선 등호의 오른쪽 `b, a` 를 수행하여 `(b, a)` 인 튜플을 만듭니다. 그리고 `a, b=b, a` 를 통해 `a=(b, a)[1]` 과 `b=(b, a)[2]` 를 수행합니다. 즉 `(b, a)` 인 새로운 튜플을 만들고 그 값을 순서대로 `a`, `b` 에 할당하는 것이기 때문에 결과적으로 두 변수의 값을 서로 교환하게 된 것입니다.

</br>


### 기명 튜플 (NamedTuple) {#sec-named_tuple}

기명 튜플은 튜플과 유사하나 성분 하나마다 특별한 이름이 붙으며, 성분에 접근할 때 인덱스를 이용할 수도 있고, 그 이름을 이용할 수도 있습니다. 기명튜플도 immutable 이므로 값을 변경하거나, 성분을 추가하거나 삭제 할 수 없습니다.

```julia
In [6]: ntup1 = (b=1, a=2)
Out[6]: (b = 1, a = 2)

In [7]: ntup1.a
Out[7]: 2

In [8]: ntup1[1]
Out[8]: 1
```

</br>

### 사전 (Dictionary) {#sec-dictionary}

사전은 키(key)-값(value) 를 묶어서 여러 타입을 저장하는 컨테이너으로 성분의 값을 변경 할 수 있는 mutable 타입입니다. 아래와 같이 `Dict` 를 통해 선언하며 `[ ]` 를 통해 접근하거나 값을 변경 할 수 있습니다. 기명 튜플과는 달리 인덱스로는 접근 할 수 없습니다. 사전은 아래에서 보듯이 명시적으로 키와 와 값의 타입을 알려주지 않았더라도, 그 타입이 정의되며 만들어집니다. 아래의 `dict1` 은 키인 `"a"`, 와 `"b"` 가 모두 문자열이기 때문에 키는 문자열 타입으로, 값인 `1` 과 `2` 가 모두 `Int64` 타입이므로 값은 `Int64` 타입으로 정의되었습니다. 즉 `dict1` 을 만들었을 때의 출력 `Dict{String, Int64}` 는 키가 문자열(`String`) 타입이며 값이 64비트 정수(`Int64`) 타입으로 한정된 사전이라는 것을 의미합니다. 원래 사전은 mutable 타입이므로 새로운 키-값 을 추가 할 수 있지만, 이것은 처음 정의될 때의 사전의 키-값 타입이 허용하는 범위 안에 있을 때만 가능합니다.

```julia
In [10]: dict1=Dict("a"=>1, "b"=>2) # 사전 선언
Out[10]: Dict{String, Int64} with 2 entries:
  "b" => 2
  "a" => 1

In [11]: dict1["a"] # 사전의 성분 접근
Out[11]: 1

In [12]: dict1["a"]=3 # 사전의 값 변경
Out[12]: 3

In [13]: dict1
Out[13]: Dict{String, Int64} with 2 entries:
  "b" => 2
  "a" => 3

In [14]: dict1["c"]=-2 # 사전에 새로운 키-값 추가
Out[14]: -2

In [15]: dict1
Out[15]: Dict{String, Int64} with 3 entries:
  "c" => -2
  "b" => 2
  "a" => 3

In [16]: dict1["d"]=3.3 # 사전의 값의 타입 범위를 벗어나는 키-값 추가 시도는 실패한다.
ERROR: InexactError: Int64(3.3)
...
```

`keys()`, `values()` 함수를 통해 사전의 key 와 value 를 얻을 수 있으며, `haskey()` 함수를 통해 해당 key 가 사전에 존재하는지 확인 할 수 있습니다.

```julia
In [17]: keys(dict1)
Out[17]: KeySet for a Dict{String, Int64} with 3 entries. Keys:
  "c"
  "b"
  "a"

In [18]: values(dict1)
Out[18]: ValueIterator for a Dict{String, Int64} with 3 entries. Values:
  -2
  2
  3

In [19]: haskey(dict1, "a")
Out[19]: true

In [20]: haskey(dict1, "c")
Out[20]: true
```

사전에 key, value 를 추가할때는 `dict1["f"]=5` 와 같이 합니다. 사전의 값을 호출할때는 `dict1["a"]` 처럼 사용합니다. 


사전을 처음 선언 할 때 타입을 정할 수 있습니다. 또한 임의의 타입의 키-값을 갖는 사전도 정할 수 있습니다. 예를 들어 `Dict{Any, Any}(...)` 를 사용하여 정의하면 모든 타입의 키와 값 을 가질 수 있습니다. `Any` 는 `Int64` 나 `Rational` 과 같은 타입 이름으로 모든 타입을 포함하는 최상위 타입입니다. 타입에 대해 자세한것은 [타입 계층 구조](08_type_hierarchy.qmd#sec-type_hierarchy)  에서 알아볼 것입니다.

```sh
In [21]: dict3=Dict{Any, Any}("a"=>1)
Out[21]: Dict{Any, Any} with 1 entry:
  "a" => 1

In [22]: dict3[4]="abcd"
Out[22]: "abcd"

In [24]: dict3["sinfunction"]=sin
Out[24]: sin (generic function with 14 methods)

In [25]: dict3["sinfunction"](π/2)
Out[25]: 1.0
```

이 때 `dict3[4]` 의 `4` 는 인덱스가 아닌 키 입니다. 정수 뿐 아니라, 부동소수나 복소수도 키가 될 수 있습니다. `In [24]` 는 사전의 값으로 함수가 오는 것을 보여줍니다. `In [25]` 에서 볼 수 있듯이 사전과 키를 이용하여 함수처럼 사용 할 수 있습니다.

</br>

### 문자열 (String) {#sec-collections_string}

앞서 타입에서 알아본 문자열(String) 도 개별적인 문자에 인덱스로 접근 할 수 있으며 `length()` 함수로 그 길이를 알 수 있다는 점에서 컨테이너입니다. 개별적인 문자에 인덱스로 접근 할 수 있지만 바꿀 수 없으므로 immutable 입니다.

</br>

### 집합 (Set) {#sec-set}

집합은 아이템의 추가나 삭제는 가능하지만 인덱스로도, 키로도 접근 할 수 없는 mutable collection 입니다. 수학적인 집합과 동일하게 같은 값을 두 개 이상 가질 수 없습니다. 예를 들어 `tuple1 = (1, 2, 3, 1)` 은 `1` 값을 두개 가지고 있지만 `set1 = Set([1, 2, 3, 1])` 은 `1` 이 중복되므로 아이템의 갯수는 3개 입니다. 아이템을 추가할때는 `push!` 함수를 사용하여 `push!(set1, 5)` 와 같이 하며, 아이템을 제거할때는 `pop!(set1, 3)` 처럼 사용합니다.

</br>

{{< include 04_containers2.qmd >}}
