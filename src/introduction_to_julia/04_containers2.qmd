## 일반적인 컨테이너에 대한 연산

### `∈`, `∉` {#sec-in_notin}

우선 `in` 혹은 `∈` (`\in`+tab) 은 어떤 아이템이 컨테이너에 속해있는지 여부를 `true`/`false` 로 반환합니다. 반대로 `∉`(`\notin`+tab) 은 아이템이 컨테이너에 포함되어 있지 않을 때 `true` 를 반환합니다. StepRange, 벡터, 집합에의 포함 여부는 다음과 같이 알 수 있습니다.

```julia
In [10]: 1 ∈ 1:10
Out[10]: true

In [11]: 1 ∈ 1:10
Out[11]: true

In [11]: "a" ∈ (2, "5", "a")
Out[11]: true

In [12]: "a" ∉ (2, "5", "a")
Out[12]: false
```

</br>

Julia 는 키-값 쌍을 `Pair` 라는 객체로 처리합니다. 사전에 어떤 키가 포함되어있는지, 값이 포함되어 있는지는 `keys`, `values` 함수로 알 수 있습니다. 키-값 쌍이 있는지는 다음과 같이 확인 할 수 있습니다.

```julia
In [13]: Pair("a", 1) ∈ Dict("a"=>1, "b"=>2)
Out[13]: true
```

</br>

우리는 앞서 홑따옴표 `' '` 안에는 글자 하나만 포함 될 수 있으며 `Char` 타입이고 겹따옴표 `" "` 는 한줄 문자열, 세겹따옴표는 `""" """` 여러줄 문자열을 포함한다는 것을 알았습니다. 따라서 `∈` 나 `∉` 연산자로 포함 여부를 확인할 때 연산자의 왼쪽에는 `Char` 형식의 한 글자에 대해서만 가능합니다. 즉

```julia
In [19]: 'a' ∈ "abc"
Out[19]: true

In [20]: "a" ∈ "abc"
ERROR: use occursin(needle, haystack) for string containment
...
```

의 결과를 보입니다. "a" 는 하나의 성분을 갖는 컨테이너이므로 `∈` 나 `∉` 의 왼쪽에 올 수 없습니다.

</br>

### `length` {#sec-length}

`length` 함수는 컨테이너에 포함된 아이템의 갯수를 리턴합니다.

```sh
In [1]: length(Dict("a"=>1, "b"=>2))
Out[1]: 2

In [2]: length([1, 2, (3, 4, 5)])
Out[2]: 3
```

</br>

### `eltype` {#sec-eltype}

`eltype` 은 컨테이너에 포함된 아이템의 타입을 반환합니다. 

```sh
julia> eltype([1.0, 2.0, 3.0])
Float64

julia> eltype(['a', 'b', 'c'])
Char
```

</br>

### `unique` {#sec-unique}

컨테이너에 포함된 아이템 가운데 중복되는 것을 제외한 아이템들을 벡터로 반환합니다.

```julia
julia> unique((1, 2, 3, 1, 2, 4))
4-element Vector{Int64}:
 1
 2
 3
 4
```

</br>

### `...` 연산자 {#sec-splat}

[`...` 연산자가 함수의 정의나 실행시에 사용되는 것에 대해서는 [Interude : Splat 연산자](04_I_splat_operator.qmd) 에 대해 좀 더 자세히 다루었습니다.]{.aside} 

순서가 있는 컨테이너에서 앞부분의 몇개만 중요할 때 사용할 수 있습니다. 예를 들어

```julia
In [1]: a, b, c... = [4, 8, 15, 16, 23, 42]
Out[1]: 6-element Vector{Int64}:
  4
  8
 15
 16
 23
 42

In [2]: a
Out[2]: 4

In [3]: b
Out[3]: 8

In [4]: c
Out[4]: 4-element Vector{Int64}:
 15
 16
 23
 42
```

입니다. 즉 1차원 배열 `A` 에 대해 첫번째 두개만 중요할 경우 `a, b, c.. = arr1` 와 같이 사용하면 `a==A[1]`, `b==A[2]` 이며 `c==A[3:end]` 가 됩니다.





</br>

## 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산

여기서는 벡터나 StepRange 같은 인덱스로 접근 가능한 컨테이너에 대해 성분이 모두 수로 이루어졌을 때 사용할 수 있는 연산에 대해 다루도록 하겠습니다. 많은 경우 수가 아닌 경우에도 사용 할 수 있지만 여기서는 수로 이루어진 컨테이너에 대해서만 논의하기로 합니다.

</br>

### `.` 연산 (도트 연산) {#sec-dot_operation}

벡터나 튜플, StepRange 같은 컨테이너의 아이템 마다 함수나 연산자를 적용시킬 때 도트 연산자 `.` 를 사용할 수 있습니다. 함수 이름의 끝에 `.` 를 붙이거나, 연산자의 앞에 `.` 를 붙입니다. 이를 도트 연산이라고 합니다.

- 스칼라와 컨테이너의 연산에서는 컨테이너의 각 성분과 스칼라와의 연산 결과를 반환합니다.

- 순서가 있는 컨테이너과 컨에티너의 연산에서는 컨테이너의 각 순서별 성분끼리 연산합니다. 

- 순서가 없는 컨테이너(예를 들어 집합(`Set`)) 에 도트연산을 수행 할 수 있지만 그 순서가 유지되지 않으며, 어쨋든 계산이 되면 그 결과는 벡터가 됩니다.

아래의 코드를 봅시다.

```julia
# 스칼라와 컨테이너의 도트 연산
In [13]: 3 .* (1, 2, 3)
Out[13]: (3, 6, 9)

# 순서가 있는 컨테이너의 도트 연산
In [14]: [1, 2, 3] .* [-1, 0, 1]
Out[14]: 3-element Vector{Int64}:
 -1
  0
  3

# 함수에서의 도트 연산. 함수 이름 끝에 . 를 붙이기만 하면 됩니다.
In [15]: sin.([-π/2, 0.0, π/2])
Out[15]: 3-element Vector{Float64}:
 -1.0
  0.0
  1.0

# 순서가 없는 컨테이너에 대한 도트 연산. 순서가 유지되지 않음.
In [16]: 3.0 .* Set([1, 2, 3])
Out[16]: 3-element Vector{Float64}:
 6.0
 9.0
 3.0
```

</br>

함수나 연산자마다 `.` 을 붙여주는 것이 코드의 가독성을 해치거나 오류의 원인이 될 수 있습니다. 이때는 표현식 앞에 `@.` 를 붙여주면 julia 는 모든 연산자와 함수에 필요할 때 `.` 가 붙은 것처럼 작동하도록 합니다. `@` 로 시작하는 명령문은 매크로라고 하며 특정한 기능을 하는 함수로 julia 의 핵심적인 기능중의 하나입니다. 자세한 것은 [메타프로그래밍과 매크로](10_metaprogramming_and_macro.qmd) 에서 다루겠습니다. 일단 다음 코드를 봅시다.

```julia
In [1]: @. 3+[1,2,3,4]
Out[1]: 4-element Vector{Int64}:
 4
 5
 6
 7

In [2]: @. sin(0.0:0.1:π)
Out[2]: 32-element Vector{Float64}:
 0.0
 0.09983341664682815
 0.19866933079506122
 0.2955202066613396
 0.3894183423086505
 0.479425538604203
 ⋮
 0.4273798802338298
 0.33498815015590466
 0.23924932921398198
 0.1411200080598672
 0.04158066243329049
```

::: {.callout-warning icon="false"}

#### 도트연산자와 소숫점의 혼동

`3.*[1, 2, 3]` 수행하면 (`3` 과 `.*` 사이에 공백이 없는 경우 입니다) 에러가 발생합니다. Julia 에서는 정수 다음에 `.` 이 붙을 경우 부동소수로 간주합니다. 예를 들어 julia 는 `-1.` 을 `-1.0` 으로 해석합니다. 따라서 `3.*[1, 2, 3]` 는 `3.0 * [1, 2, 3]` 로 해석 될 수도 있고 `3 .* [1, 2, 3]` 으로 해석 될 수도 있습니다. `.*` 와 같이 도트를 앞에 붙여서 사용하는 연산의 경우는 `.` 앞에 공백을 앞에 두는 습관을 들이는 것이 좋습니다.
:::

1차원 컨테이너 끼리의 도트 연산을 위해서는 컨테이너의 크기가 같아야 합니다. 다차원 배열의 경우는 [배열](06_arrays.qmd#sec-array) 에서 다루겠습니다. 


</br>

많은 경우 StepRange 에 연산을 하면 Julia 가 판단을 해서 필요한 경우 벡터로 바꿔줍니다. 예를 들어, 

```julia
In [17]: 2*(1:10)
Out[17]: 2:2:20

In [18]: (1:3).^2
Out[18]: 3-element Vector{Int64}:
 1
 4
 9
```

처럼 변합니다.

</br>


### `minimum`, `maximum`, `extrema` {#sec-extrema}

이 함수들은 컨테이너에 포함되는 값 가운데의 최소값(`minimum`), 최대값(`maximum`), 그리고 둘 다(`extrema`)를 반환합니다. 단 이때는 컨테이너의 모든 아이템들이 서로 비교 가능해야 합니다. 예를 들어 정수와 부동소수는 비교가능 하지만 수와 문자열은 서로 크기를 비교 할 수 없습니다. 따라서 수와 문자열을 같이 포함하는 컨테이너에서는 위의 함수들을 사용 할 수 없습니다.

```julia
In [23]: extrema(1:5)
Out[23]: (1, 5)

In [24]: maximum([1, 2, "ab"])
ERROR: MethodError: no method matching isless(::String, ::Int64)
...
```

이 함수들은 어떤 컨테이너의 극값 뿐만 아니라 컨테이너에 함수를 적용했을 때의 최대값 최소값을 구하는 데도 사용 할 수 있습니다. 예를 들어, 

```julia
In [25]: extrema(cos, 0:π/1000:π)
Out[25]: (-1.0, 1.0)
```

는 `0:π/1000:π` 에 대한 각각의 `cos` 값의 최소값과 최대값을 반환합니다.


</br>

### `argmin`, `argmax`, `findmin`, `findmax` 

`argmin`, `argmax` 는 각각 컨테이너에서 최소값과 최대값의 인덱스를 반환하며, 그 값이 여러개일 경우 첫번째 인덱스를 반환합니다. `findmin`, `findmax` 는 각각 최대값, 최소값에 대해 값과 인덱스를 튜플로 반환합니다.


```julia
In [29]: argmin([2, 3, 1, 2, 3, 1, 4, 1, 6])
Out[29]: 3

In [30]: findmax([2, 3, 1, 2, 3, 1, 4, 1, 6])
Out[30]: (6, 9)
```

함수에 대한 결과값의 최대, 최소를 구할 수도 있습니다.

```julia
In [35]: findmax(cos, range(0.0, π, length=30))
Out[35]: (1.0, 1)
```


::: {.callout-warning icon="false"}

#### `argmin`, `argmax` 의 주의사항

`argmin`, `argmax` 도 함수를 입력하면 에러가 나지 않지만 우리가 기대하는 행동을 하지 않습니다. 예를 들어


```julia
In [37]: argmin(cos, range(0.0, π, length=30))
Out[37]: 3.141592653589793
```

의 경우 `range(0.0, π, length=30)` 에 `cos` 함수를 적용시켰을 때 최소값이 나오는 인덱스(이경우`30`) 이 나오길 기대할 수 있지만 `cos` 함수를 최소화하는 `range(0.0, π, length=30)` 에서의 값을 반환합니다. `argmax` 도 같은 방식으로 동작합니다. 혼란을 줄 수 있으므로 왠만하면 `argmin`, `argmax` 는 사용하지 말고 `findmin`, `findmax` 를 사용하시기를 권합니다.
:::


</br>

### `map`

함수 `f` 와 컨테이너 `c` 에 대해 `map(f, c)` 는 `c` 의 개별적인 성분에 `f` 를 적용한 값을 리턴합니다. 

```julia
In [1]: map(abs, [1, -1, 2, -2, 3, -5])
Out[1]: 6-element Vector{Int64}:
 1
 1
 2
 2
 3
 5
```

인자가 여러개인 함수에 대해서는 여러개의 컨테이너를 인자로 입력합니다.

```julia
In [4]: f(x, y) = x+y
Out[4]: f (generic function with 1 method)

In [5]: map(f, [1,2, 3], [3, 4,5])
Out[5]: 3-element Vector{Int64}:
 4
 6
 8
```

인자로 주어지는 컨테이너의 갯수가 다를 때는 길이가 최소인 컨테이너에 맞추며 나머지 컨테이너의 성분은 무시합니다.

```julia
In [6]: map(f, [1,2, 3], [3, 4,5, 6, 7])
Out[6]: 3-element Vector{Int64}:
 4
 6
 8
```

함수 뿐만 아니라 연산자가 올 수 도 있습니다.

```julia
In [8]: map(÷, [4, 7, 9], [2, 3, 5])
Out[8]: 3-element Vector{Int64}:
 2
 2
 1
```

</br>

#### 익명 함수의 사용 {#sec-anonymous_function_in_map}

`map` 뿐만 아니라 바로 뒤에 나올 `reduce`, `mapreduce`, `filter` 에 [익명 함수](03_functions_and_operators.qmd#sec-anonymous_function) 가 아주 유용하게 사용될 수 있습니다. 예를 들어 

```julia
In [3]: map(x->cos(x)+1, range(0, π, length=4))
Out[3]: 4-element Vector{Float64}:
 2.0
 1.5
 0.5000000000000002
 0.0
```

를 봅시다. `range(0, π, length=4)` 는 `0` 부터 `π` 까지 같은 간격을 가진 4개의 성분을 가진 배열을 만듭니다. 이 배열의 각각의 성분에 `cos` 함수를 취한후 `1` 을 더하는 익명함수 `x->cos(x)+1` 을 적용시킨 결과입니다.

</br>

#### `do ... end`, `begin ... end` 의 사용 {#sec_usage_of_do_end_begin_end}

`do ... end` 구문이나 `begin ... end` 구문 역시 일종의 익명 함수를 만드는 데 사용될 수 있습니다. 당연히 컨테이너에만 사용되는 것은 아니지만 컨테이에 대한 연산, 특히 `map` 이나 앞으로 나올 `reduce`, `filter` 등의 함수에 유용하게 사용 할 수 있습니다. 일단 `In [3]` 와 같은 결과를 내는 코드는 다음과 같습니다.$^\ast$ [$^\ast$ 함수의 정의에서 `return` 문이 없다면 `end` 바로전의 표현식의 결과를 반환한다는 것을 알았습니다. 아래 코드에서도 마찬가지로 `return cos(x)+1` 대신에 `cos(x)+1` 만 있어도 실행됩니다.]{.aside}

```julia
In [4]: map(range(0, π, length=4)) do x
        return cos(x)+1
        end

In [5]: map( x-> begin
        return cos(x) +1
        end
        , range(0, π, length=4))
```

우선 함수 `f1` 을 첫번째 인자로 받는 함수 `mfunc(f1, b...)` 에서 `f1` 의 정의를 `mfunc(b...) do x` 로 시작합니다. 이 때 `x` 는 `f1` 의 인자입니다. 그 이후 구문은 `end` 가 나올 때 까지 `f1` 을 정의하는 구문과 같습니다. `do ... end` 구문이나 `begin ... end` 구문에서는 변수를 선언하여 활용 할 수 있습니다. 

```julia
map(0.0:0.1:π) do x
    y = sqrt(x)
    z = x^2
    cos(y+z)
end
```

이 코드는 다음과 두 코드와 각각 같습니다.

```julia
function f1(x)
    y = sqrt(x)
    z = x^2
    cos(y+z)
end

map(f1, 0.0:0.1:π)
```

```julia
map(x->begin
    y = sqrt(x)
    z = x^2
    cos(y+z)
    end, 
    0.0:0.1:π)
```

</br>

### `reduce`

`map` 이 컨테이너의 각 성분에 연산을 수행한다면, 그래서 결과는 입력된 컨테이너의 길이와 같은 벡터가 된다면 `reduce` 는 컨테이너에 대해 각각의 성분에 대해 연산을 수행하여 하나의 값을 얻는데 사용합니다. 예를 들어

```julia
reduce(+, [1,2, 3, 4])
```

를 봅시다. `reduce` 는 우선 첫번째와 두번째 성분으로 주어진 연산자나 함수에 대해 계산한 후 결과값을 세번째성분과 계산하고 이것을 마지막 성분까지 계속합니다. 즉 위의 코드는 `(((1+2)+3)+4)` 와 같습니다. 그렇다면

```julia
reduce(-, [1,2, 3, 4])
```

는 `(((1-2)-3)-4)` 과 같습니다.


</br>

### `mapreduce`

`mapreduc` 는 `map` 과 `reduce` 를 합친 기능을 합니다. `mapreduce(f, op, iter)` 는 `reduce(op, map(f, iter))` 와 같은 역할을 합니다. 예를 들어 다음 두 명령어는 기능적으로 같습니다. `1` 에서 `10` 까지의 정수를 제곱한 배열을 만든 후 그 배열의 합을 구하는 것입니다. 

```julia
mapreduce(x->x^2, +, 1:10)
reduce(+, map(x->x^2, 1:10))
```

</br>

#### `filter`


`filter(f, c)` 에서 `f` 는 `true` 혹은 `false` 를 반환하는 함수나 연산자이어야 합니다. 컨테이너의 성분에 함수를 적용했을 때 참인 성분만을 골라 반환합니다. 예를 들어,

```julia
In [1]: filter(x->(x>3), [1,2,3,4,5])
Out[1]: 2-element Vector{Int64}:
 4
 5
```

를 봅시다. `x->(x>3)` 은 익명함수로 `x>3` 의 조건을 만족하면 `true`, 그렇지 않다면 `false` 를 리턴합니다. 따라서 이 조건을 만족하는 `[4, 5]` 만을 반환합니다.

참고로 3보다 큰 성분을 배열로 리턴하는 것이 아니라 3보다 크면 1, 3보다 작으면 0 을 리턴하도록 하려면 어떻게 하면 될까요? 아래를 보고 왜 이렇게 작동하는지 생각해 보시기 바랍니다.

```julia
In [2]: [1, 2, 3, 4, 5] .> 3
Out[2]: 5-element BitVector:
 0
 0
 0
 1
 1
```

</br>









