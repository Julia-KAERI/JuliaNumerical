[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Physics, Math & Computing",
    "section": "",
    "text": "이 웹사이트는 현재 제가 공부한것들을 정리하는 곳입니다. 많은 오류가 있을 수 있으며, 지속적으로 수정될 것입니다. 어떤 것도 보장하지 않습니다."
  },
  {
    "objectID": "src/applications_of_julia/fileio.html",
    "href": "src/applications_of_julia/fileio.html",
    "title": "파일시스템과 파일입출력",
    "section": "",
    "text": "Julia 스크립트가 실행 될 때 몇가지 파일과 경로에 대한 정보를 가지고 실행됩니다. 예를 들어 다음의 julia 스크립트 파일로 저장하고 실행시켜봅시다\n#! /usr/bin/env julia\n\nprintln(homedir())\nprintln(pwd())\nprintln(@__DIR__)\nprintln(@__FILE__)\nJulia 스크립트는 보통 확장자로 jl 을 사용합니다. 위의 코드를 pathes.jl 로 저장해 봅시다. 맨 앞줄의 #! /usr/bin/env julia 는 Shebang 이라고 하며 스크립트의 실행 정보를 담고 있지만 여기서는 무시하도록 합니다. Linux 나 맥 OSX 같은 유닉스 계열의 OS 라면 터미널에서\njulia pathes.jl\n명령어로서 실행합니다. 실행이 제대로 된다면 4줄을 출력할 것입니다.\n\nhomedir() 은 사용자의 홈 디렉토리의 경로를 문자열로 반환하는 함수입니다.\npwd() 는 스크립트가 어떤 작업을 할 때의 기준 디렉토리 즉 작업디렉토리를 문자열로 반환하는 함수입니다.\n@__DIR__ 은 매크로로 이 매크로를 호출한 파일의 디렉토리를 반환합니다.\n@__FILE__ 역시 매크로로 이 매크로를 호출한 파일의 파일명을 포함하는 전체 경로를 반환합니다.\n\n\n\n\n\n여기서는 함수 이름만 나열합니다. 자세한 사용법은 Julia 의 도움말을 확인하기 바랍니다.\n\n\n\n기능\n함수\n\n\n\n\nhome directory\nhomedir()\n\n\nworking directory 확인\npwd()\n\n\nworking directory 변경\ncd()\n\n\nworking directory를 home directory로 변경\ncd()\n\n\ndirectory내 파일 및 폴더 리스트 확인\nreaddir()\n\n\ndirectory 만들기\nmkpath()\n\n\n파일/폴더 이동\nmv()\n\n\n파일/폴더 삭제\nrm()\n\n\n폴더인지 확인\nisdir()\n\n\n파일인지 확인\nisfile()\n\n\n유효한 경로인지 확인\nispath()\n\n\n절대경로 확인\nabspath()\n\n\n절대경로인지 확인\nisabspath()\n\n\n경로 합성\njoinpath()\n\n\n디렉토리 이름과 파일 이름으로 분할\nsplitdir()\n\n\n경로를 세부 단위로 분할\nsplitpath()\n\n\n파일크기 확인\nfilesize()\n\n\n파일의 세부 정보 얻기\nstat()"
  },
  {
    "objectID": "src/applications_of_julia/fileio.html#파일-시스템",
    "href": "src/applications_of_julia/fileio.html#파일-시스템",
    "title": "파일시스템과 파일입출력",
    "section": "",
    "text": "Julia 스크립트가 실행 될 때 몇가지 파일과 경로에 대한 정보를 가지고 실행됩니다. 예를 들어 다음의 julia 스크립트 파일로 저장하고 실행시켜봅시다\n#! /usr/bin/env julia\n\nprintln(homedir())\nprintln(pwd())\nprintln(@__DIR__)\nprintln(@__FILE__)\nJulia 스크립트는 보통 확장자로 jl 을 사용합니다. 위의 코드를 pathes.jl 로 저장해 봅시다. 맨 앞줄의 #! /usr/bin/env julia 는 Shebang 이라고 하며 스크립트의 실행 정보를 담고 있지만 여기서는 무시하도록 합니다. Linux 나 맥 OSX 같은 유닉스 계열의 OS 라면 터미널에서\njulia pathes.jl\n명령어로서 실행합니다. 실행이 제대로 된다면 4줄을 출력할 것입니다.\n\nhomedir() 은 사용자의 홈 디렉토리의 경로를 문자열로 반환하는 함수입니다.\npwd() 는 스크립트가 어떤 작업을 할 때의 기준 디렉토리 즉 작업디렉토리를 문자열로 반환하는 함수입니다.\n@__DIR__ 은 매크로로 이 매크로를 호출한 파일의 디렉토리를 반환합니다.\n@__FILE__ 역시 매크로로 이 매크로를 호출한 파일의 파일명을 포함하는 전체 경로를 반환합니다.\n\n\n\n\n\n여기서는 함수 이름만 나열합니다. 자세한 사용법은 Julia 의 도움말을 확인하기 바랍니다.\n\n\n\n기능\n함수\n\n\n\n\nhome directory\nhomedir()\n\n\nworking directory 확인\npwd()\n\n\nworking directory 변경\ncd()\n\n\nworking directory를 home directory로 변경\ncd()\n\n\ndirectory내 파일 및 폴더 리스트 확인\nreaddir()\n\n\ndirectory 만들기\nmkpath()\n\n\n파일/폴더 이동\nmv()\n\n\n파일/폴더 삭제\nrm()\n\n\n폴더인지 확인\nisdir()\n\n\n파일인지 확인\nisfile()\n\n\n유효한 경로인지 확인\nispath()\n\n\n절대경로 확인\nabspath()\n\n\n절대경로인지 확인\nisabspath()\n\n\n경로 합성\njoinpath()\n\n\n디렉토리 이름과 파일 이름으로 분할\nsplitdir()\n\n\n경로를 세부 단위로 분할\nsplitpath()\n\n\n파일크기 확인\nfilesize()\n\n\n파일의 세부 정보 얻기\nstat()"
  },
  {
    "objectID": "src/applications_of_julia/fileio.html#저수준-파일-입출력",
    "href": "src/applications_of_julia/fileio.html#저수준-파일-입출력",
    "title": "파일시스템과 파일입출력",
    "section": "2 저수준 파일 입출력",
    "text": "2 저수준 파일 입출력\n\n파일 열고 닫기\n일반적인 프로그래밍 언어에서 기본적으로 파일을 다루는 것은 파일을 열고(open), 읽거나(read) 쓰고(write), 닫는(close) 절차로 이루어집니다. 파일을 연다는 것은 특정 파일을 지정하여 그 파일에 접근할 수 있는 통로의 문을 여는 것으로 이해 할 수 있습니다. 워드나 편집기 프로그램과 다른것은 파일을 연다는 것이 여기서는 파일의 내용을 읽는것이 아니라는 것입니다. 파일을 닫는것은 이제 그 파일에 접근할 필요가 없으므로 그 통로를 닫는다는 것으로 이해 할 수 있습니다. 파일을 지우거나 고치거나 하지 않습니다.\nJulia 에서 파일을 열고 닫는 방법은 보통 두가지가 많이 쓰입니다. 하나는 open() 함수로 명시적으로 열고 close() 함수로 명시적으로 닫는 것입니다. 예를 들어 앞의 pathes.jl 파일의 절대경로가 /Users/juliano/pathes.jl 라고 하면 다음과 같이 합니다. 현재 디렉토리(pwd() 명령어로 확인할 수 있습니다) 에 대한 상대경로를 사용할 수도 있습니다.\nf = open(\"/Users/juliano/pathes.jl\")\n    # f 를 이용하여 일을 한다.\nclose(f)\n나머지 하나는 do 블럭을 이용하는 것입니다. 이 방법은 close() 함수를 명시적으로 호출할 필요가 없습니다.\nopen(\"/Users/juliano/pathes.jl\") do f\n    # f 를 이용하여 일을 한다.\nend\n\n\n\n파일 접근 모드\n파일을 열 때는 몇가지 모드가 있으며 open 함수의 두번째 인자로 전달되거나 키워드 인자로 전달됩니다. 어떤 모드도 지정되지 않았다면 \"r\" 모드입니다. 아래의 표는 가능한 모드들입니다. 아래의 표에서 [truncate] 는 기존의 파일이 있다면 그 파일의 내용을 지우고 빈 파일로 만든다는 의미입니다. 따라서 파일이 지워져서는 안되는 파일이라면 미리 확인해야 합니다.(ispath(), 나 isfile() 함수로 확인 할 수 있습니다.) [새로 만들기] 는 지정된 경로에 파일이 없다면 파일을 새로 만든다는 뜻입니다. [새로 만들기] 모드가 없고 지정된 경로에 파일이 없다면 에러가 발생합니다. [덧붙이기] 는 기존의 파일을 유지하면서 기존 파일의 끝부터 내용을 쓴다는 의미입니다.\n\n\n표 1: 파일 접근 모드\n\n\n\n\n\n\n\n모드\n키워드 인자\n설명\n\n\n\n\n\"r\"\n\n읽기\n\n\n\"w\"\nwrite = true\n쓰기, 새로 만들기, truncate\n\n\n\"a\"\nappend = true\n쓰기, 새로 만들기, 덧붙이기\n\n\n\"r+\"\nread = true, write = true\n읽기, 쓰기\n\n\n\"w+\"\ntruncate = true, read = true\n읽기, 쓰기, 새로 만들기, truncate\n\n\n\"a+\"\nappend = true, read = true\n읽기, 쓰기, 새로 만들기, 덧붙이기\n\n\n\n\n\n다음의 명령어는 동일합니다.\nopen(\"/Users/juliano/pathes.jl\")\nopen(\"/Users/juliano/pathes.jl\", \"r\")\n아래의 두 명령어도 동일합니다.\nopen(\"/Users/juliano/pathes/jl\", \"w\")\nopen(\"/Users/juliano/pathes/jl\"; write = true)\n\n\n\n파일 읽기\n앞에서 open 파일은 실제로 파일에서 내용을 읽지 않는다고 언급했습니다. 파일을 열게 되면 IOStream 객체가 생성 됩니다. 이 객체에 대한 정보는 stat() 함수를 통해 얻을 수 있습니다. IOStream 객체는 바이트별로 데이터를 처리할 수 있으며 현재의 위치를 기억합니다. 현재의 위치는 position() 함수를 통해 알 수 있으며, 파일을 읽거나 쓰면 그만큼 현재의 위치가 이동합니다. 위치는 사용자가 바이트 단위로 옮길 수가 있는데 0 이 시작위치이며 끝 위치는 filesize() 함수로 얻을 수 있습니다.\nIn [1]: f1=open(\"pathes.jl\")\nOut[1]: IOStream(&lt;file pathes.jl&gt;)\n\nIn [2]: stat(f1)\nOut[2]: StatStruct for RawFD(20)\n   size: 93 bytes\n device: 16777220\n  inode: 49833799\n   mode: 0o100755 (-rwxr-xr-x)\n  nlink: 1\n    uid: 501 (jiyong)\n    gid: 20 (staff)\n   rdev: 0\n  blksz: 4096\n blocks: 8\n  mtime: 2023-12-04T18:11:59+0900 (19 hours ago)\n  ctime: 2023-12-04T18:11:59+0900 (19 hours ago)\n\nIn [3]: position(f1)\nOut[3]: 0\n\nIn [4]: read(f1, 3)\nOut[4]: 3-element Vector{UInt8}:\n 0x23\n 0x21\n 0x20\n\nIn [5]: position(f1)\nOut[5]: 3\n\nIn [6]: seek(f1, 0)\nOut[6]: IOStream(&lt;file pathes.jl&gt;)\n\nIn [7]: position(f1)\nOut[7]: 0\n파일에서 내용을 읽는 것은 read(), readline(), readlines() 함수를 이용합니다. read() 함수는 현재의 위치부터 인자로 전달되는 바이트 수 만큼을 읽고 Vector{UInt8} 로 반환합니다. 인자가 없다면 현재의 위치부터 끝까지 읽습니다. readline() 함수는 현재의 위치부터 다음 개행문자까지 읽고 문자열로 반환합니다. readlines() 함수는 현재의 위치부터 끝까지 읽고, 개행문자로 분할하여 문자열의 1차원 배열로 반환합니다. 개행문자는 일반 아스키나 유니코드 텍스트 파일에서 줄바꿈을 나타내는 문자이며 운영체제마다 다르지만 지금 사용하는 함수에서는 알아서 구분하여 분할해 줍니다.\n\n그런데 위의 세 함수 read, readline, readlines 는 open 함수를 통해 파일에 접근하는 IOStream 객체를 만들지 않고 직접 파일 이름을 첫번째 인자로 입력하여 똑같은 일을 할 수 있습니다. 차이가 있다면 IOStream 을 통해 접근하면 파일에서의 현재위치(position 함수로 알 수 있는)가 유지되는 반면에 read 함수 등으로 직접 접근하면 함수를 호출할 때마다 파일의 현재위치가 초기화 된다는 것입니다.\n\n\n텍스트 파일 읽고 쓰기\n이제 실제로 읽고 써 봅시다. 다음의 내용을 담은 파일을 기록한다고 해 봅시다.\n# 실험자 : 홍길동\n# 실험 일시 : 2023년 12월 10일\n# 데이터\n\n10\n4\n7\n6\n33\n5\n2\n하나의 문자열로 만든 다음에 통째로 data1.txt 파일로 적겠습니다. 현재 디렉토리가 파일로 저장하고자 하는 디렉토리라고 하고 상대경로를 사용하겠습니다.\nIn [1]: p=\"\"\"\n        # 실험자 : 홍길동\n        # 실험 일시 : 2023년 12월 10일\n        # 데이터\n\n        10\n        4\n        7\n        6\n        33\n        5\n        2\"\"\"\nOut[1]: \"# 실험자 : 홍길동\\n# 실험 일시 : 2023년 12월 10일\\n# 데이터\\n\\n10\\n4\\n7\\n6\\n33\\n5\\n2\"\n\nIn [2]: open(\"data1.txt\", \"w\") do f\n        f.write(p)\n        end\n이제 data1.txt 에 위의 내용이 기록되어 있음을 확인 할 수 있을 것입니다. 이제 이 파일을 읽고 처리하도록 하겠습니다. 가장 쉬운 방법은 readlines()로 통째로 줄 단위로 읽는 것입니다. 파일 전체를 읽을 것이므로 readlines() 함수를 통해 읽겠습니다.\nIn [1]: p = readlines(\"data1.txt\")\nOut[1]: 11-element Vector{String}:\n \"# 실험자 : 홍길동\"\n \"# 실험 일시 : 2023년 12월 10일\"\n \"# 데이터\"\n \"\"\n \"10\"\n \"4\"\n \"7\"\n \"6\"\n \"33\"\n \"5\"\n \"2\"\n문자열의 베열을 얻었으며, 빈 줄 역시 \"\" 로 표현됩니다. 네번째 줄부터 데이터이므로 이것을 정수의 배열로 바꾸겠습니다. parse(T, x) 는 값 x 를 타입 T 로 변경해주는 함수입니다.\nIn [11]: data = [parse(Int64, x) for x in p[5:end]]\nOut[11]: 7-element Vector{Int64}:\n 10\n  4\n  7\n  6\n 33\n  5\n  2\n\n\n\n이진 파일 읽고 쓰기\n텍스트 파일과 이진 파일은 파일 자체로는 본질적으로 차이가 없고 읽을 때 개행문자를 어떻게 처리하는지의 차이가 있을 뿐입니다. 예를 들어 UInt8 타입의 정수 12개를 기록한다고 해 봅시다. 정수 하나가 1바이트이므로 총 8바이트를 기록하게 됩니다.\nIn [1]: p = collect(UInt8, 1:1:8)\nOut[1]: 8-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n\nIn [2]: write(\"data2.bin\", p)\nOut[2]: 8\n\nIn [3]: read(\"data2.bin\")\nOut[3]: 8-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n\n여기까지는 큰 문제가 없습니다. 만약 Float64 타입의 실수 4개를 기록한다고 합시다.\nIn [4]: nb = collect(Float64, 0.0:1.0:3.0)\nOut[4]: 4-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\n\nIn [6]: write(\"data3.bin\", nb)\nOut[6]: 32\n\nIn [7]: read(\"data3.bin\")\nOut[7]: 32-element Vector{UInt8}:\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n...\nFloat64 부동소수는 8바이트이므로 4개의 Float64 부동소수는 32 바이트를 차지합니다. 따라서 우리는 32 개의 UInt8 정수를 얻었으며 이것을 다시 Float64 로 변환해야 합니다. 대신에 데이터가 저장될 배열을 생성하고 read! 함수를 사용해 봅시다.\nIn [12]: v=Vector{Float64}(undef, 4);\n\nIn [13]: read!(\"data3.bin\", v)\nOut[13]: 4-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\nv 는 읽어들일 데이터가 저장될 배열입니다. 데이터를 읽고 배열을 변경하기 때문에 julia 의 관례에 따라 함수 이름 끝에 ! 가 붙었습니다.\n\n지금까지 텍스트 파일과 이진 파일의 저수준 입출력에 관해 간단히 알아보았습니다. 텍스트 파일은 메모장이나 텍스트 편집기로 파일 내용을 읽고 쓸수 있다는 큰 장점이 있습니다. 이진파일은 그 내용을 보더라도 의미를 알기 힘듭니다. 그러나 큰 데이터를 저장할 때 텍스트 파일은 이진 파일보다 몇배의 공간을 차지하기 때문에 큰 데이터를 저장하는데 적합하지 않습니다.\n또하나 생각해야 할 것은 파일에 데이터 뿐만 아니라 데이터에 대한 다양한 정보(이를 메타데이터라고 합니다)까지 같이 저장하는 경우 어디서부터가 어떤 형식의 데이터인지를 정확히 알아야 하며 그것에 맞추어 코딩을 해야 하는데 이것이 쉬운 일은 아닙니다. 하지만 이미 존재하는 많은 파일 형식들과 그것을 쉽게 읽고 쓸 수 있도록 해주는 많은 라이브러리들이 있습니다. 이제 이것을 알아봅시다."
  },
  {
    "objectID": "src/applications_of_julia/fileio.html#포맷이-정해진-파일의-입출력",
    "href": "src/applications_of_julia/fileio.html#포맷이-정해진-파일의-입출력",
    "title": "파일시스템과 파일입출력",
    "section": "3 포맷이 정해진 파일의 입출력",
    "text": "3 포맷이 정해진 파일의 입출력\nJulia 에서 파일 입출력을 지원하는 FileIO.jl 패키지가 있습니다. 많은 파일 형식에 관한 입출력 함수는 이 패키지의 load 함수와 save 함수를 메소드 디스패치하여 지원됩니다. 예를 들어 아래에 설명될 CSV 파일을 읽기 위해서는 CSV.jl 패키지가 필요한데, 이 CSV.jl 패키지에서 파일 입출력은 FileIO.jl 패키지를 이용하여 구현되었다는 의미입니다. Registry table 에는 FileIO.jl 의 load/save 를 이용하여 읽고 쓸 수 있는 포맷들이 나열되어 있습니다.\n\nCSV\n마이크로소프트사의 엑셀을 포함하여 아주 많이 사용되는 포멧입니다. 텍스트 포멧이며 모든 값은 “,” 로 구분됩니다. CSV 의 이름 자체가 comma-separated values, 즉 콤마로 구분되는 값들 이라는 의미입니다. 보통은 주 데이터 뿐만 아니라 주 데이터에 대한 설명을 포함합니다. 가장 간단한 방법은 CSV.jl 패키지를 사용하는 것입니다.\n\n\n\nHDF5"
  },
  {
    "objectID": "src/applications_of_julia/leastsquarefit.html",
    "href": "src/applications_of_julia/leastsquarefit.html",
    "title": "비선형 최소제곱 피팅",
    "section": "",
    "text": "어떤 실험 결과가 \\(m\\) 개의 독립 변수에 대해 \\(n\\) 차원 벡터로 발생한다고 하자. 이에 대해 모델 함수 \\(\\boldsymbol{F}:\\mathbb{R}^m \\to \\mathbb{R}^n\\)"
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html",
    "href": "src/introduction_to_julia/01_julia_language.html",
    "title": "설치와 환경 구성",
    "section": "",
    "text": "다운로드 페이지 에서 다운받을 수도 있고, homebrew 나 apt 같은 운영체제별 패키지 관리자를 이용하여 설치할 수도 있습니다. 당신이 julia 언어에 막 입문했거나, 특별히 선택해야할 버젼이 없다면 다운로드 패이지에서 최신버젼을 다운받는것을 추천드립니다. 설치가 완료된 후 터미널에서 julia 명령을 수행하면 다음과 같은 화면을 볼 수 있을 것입니다.\n\n\n\nJulia REPL screenshot\n\n\n위의 화면이 보인다면 julia 가 정상적으로 설치 된 것입니다.\n\n\n위의 스크린샷과 같이 julia&gt; 옆에 무언가를 치면 그대로 입력됩니다. 예를 들어 3+3 을 계산하고 싶으면 3+3 을 치고 엔터키를 누르면 그 결과가 출력됩니다.\njulia&gt; 3+3\n6\n이렇게 입력을 기다리다가 입력이 되면 읽어서(Read), 그 값을 평가하고(Evaluation), 그 결과를 출력하는(Printing) 것을 계속 반복하게(Loop) 하게 됩니다. 이것을 영어 단어의 첫글자만 따서 REPL 이라고 합니다. julia 언어의 기본적인 상호작용은 터미널에서 REPL 을 수행하는 것입니다. 별도의 다른 프로그램이 필요하지 않고, 간단한 계산을 할 때 가장 빠르다는 장점이 있지만 긴 코드를 짤 때 불편하며, 그래프를 출력하는데 많은 제한이 있습니다. 그래서 보통은 다른 환경에서 julia 를 수행합니다.\n\n\n\n\n기본적으로 julia REPL 의 프롬프트는 julia&gt; 이지만 개인적으로\nIn [1]: 5 + 3\nOut[1]: 8\n와 같은 방식을 선호하기 때문에 위와 같은 방식을 사용합니다. Julia 공식 메뉴얼의 Numbered Prompt 대로 고치면 이렇게 사용 할 수 있습니다."
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#julia-설치",
    "href": "src/introduction_to_julia/01_julia_language.html#julia-설치",
    "title": "설치와 환경 구성",
    "section": "",
    "text": "다운로드 페이지 에서 다운받을 수도 있고, homebrew 나 apt 같은 운영체제별 패키지 관리자를 이용하여 설치할 수도 있습니다. 당신이 julia 언어에 막 입문했거나, 특별히 선택해야할 버젼이 없다면 다운로드 패이지에서 최신버젼을 다운받는것을 추천드립니다. 설치가 완료된 후 터미널에서 julia 명령을 수행하면 다음과 같은 화면을 볼 수 있을 것입니다.\n\n\n\nJulia REPL screenshot\n\n\n위의 화면이 보인다면 julia 가 정상적으로 설치 된 것입니다.\n\n\n위의 스크린샷과 같이 julia&gt; 옆에 무언가를 치면 그대로 입력됩니다. 예를 들어 3+3 을 계산하고 싶으면 3+3 을 치고 엔터키를 누르면 그 결과가 출력됩니다.\njulia&gt; 3+3\n6\n이렇게 입력을 기다리다가 입력이 되면 읽어서(Read), 그 값을 평가하고(Evaluation), 그 결과를 출력하는(Printing) 것을 계속 반복하게(Loop) 하게 됩니다. 이것을 영어 단어의 첫글자만 따서 REPL 이라고 합니다. julia 언어의 기본적인 상호작용은 터미널에서 REPL 을 수행하는 것입니다. 별도의 다른 프로그램이 필요하지 않고, 간단한 계산을 할 때 가장 빠르다는 장점이 있지만 긴 코드를 짤 때 불편하며, 그래프를 출력하는데 많은 제한이 있습니다. 그래서 보통은 다른 환경에서 julia 를 수행합니다.\n\n\n\n\n기본적으로 julia REPL 의 프롬프트는 julia&gt; 이지만 개인적으로\nIn [1]: 5 + 3\nOut[1]: 8\n와 같은 방식을 선호하기 때문에 위와 같은 방식을 사용합니다. Julia 공식 메뉴얼의 Numbered Prompt 대로 고치면 이렇게 사용 할 수 있습니다."
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#개발환경-설정에-관해",
    "href": "src/introduction_to_julia/01_julia_language.html#개발환경-설정에-관해",
    "title": "설치와 환경 구성",
    "section": "2 개발환경 설정에 관해",
    "text": "2 개발환경 설정에 관해\nJulia 의 개발 환경은 많은 선택지가 있습니다. Python 에서 많이 사용하는 jupyter notebook 을 사용할 수도 있으며, emacs, vim, atom, vscode 와 같은 다양한 편집기를 사용할 수도 있습니다. 개인적으로 Microsoft 사에서 제공하는 텍스트 편집기 겸 통합개발환경인 Visual Studio code (vscode) 를 사용하는 개발환경을 추천합니다. vscode 에서의 julia 지원 페이지 대로 따라 하면 julia 개발 환경을 구성 할 수 있습니다.\n저는 짧은 코드를 계속 입력하면서 결과를 확인하는 작업을 많이 할때는 vscode 의 jupyter 환경을 주로 사용하며, 긴 코드를 사용할 때는 vscode 와 Julia 언어 지원을 사용합니다. Jupyter 에 익숙하지 않다면 단순히 julia 지원만을 사용하는 것도 좋은 방법입니다. 여기에서도 줄단위, 블럭단위, 파일단위로 실행시켜 볼 수 있습니다. 그 이외에도 저는 사용해 본 적이 없지만 Pluto.jl 도 있습니다. 검색창에서 julia 개발 환경 을 검색하면 많은 내용이 나옵니다. 그 중에 여러분의 입맞에 맡는 것을 선택하면 됩니다. 여기에서는 짧은 코드는 Julia REPL 을 바탕으로 설명하겠지만 다른 개발 환경에서도 거의 그대로 결과가 나올 것입니다."
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#기본-제공-문서",
    "href": "src/introduction_to_julia/01_julia_language.html#기본-제공-문서",
    "title": "설치와 환경 구성",
    "section": "3 기본 제공 문서",
    "text": "3 기본 제공 문서\n비록 영어로 되어 있긴 하지만 Julia 에 내장된 기본 도움말은 매우 훌륭합니다. Julia REPL 에서는 julia&gt; 프롬프트에 ? 를 치면 help&gt;로 변경되는 것을 볼 수 있을 것입니다. 여기에 함수 이름이라든가, 타입 이름 같은 것을 치면 그에 대한 도움말을 제공합니다. Jupyter 에서는 입력 셀에 ?sin 과 같이 ? 를 맨 앞에 두고 입력한후 실행하면 문서를 찾아 제공합니다. vscode 에서는 자동적으로 팝업 윈도우로 제공합니다만 2023년 12월 현재로서는 완전하지 않습니다. 이렇게 제공되는 문서는 당신이 사용하는 Julia 와 페키지에 대한 공식 문서이므로, 가장 믿을만하고 우선적으로 참고해야하는 문서가 되겠습니다.\nJulia 언어에 기본적으로 포함되어있는 함수, 모듈들 이외에 많은 모듈을 설치하게 될텐데 그 모듈들도 대부분 똑같은 형식의 도움말을 제공합니다."
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#sec-unicode_support",
    "href": "src/introduction_to_julia/01_julia_language.html#sec-unicode_support",
    "title": "설치와 환경 구성",
    "section": "4 유니코드 및 수학 기호 지원",
    "text": "4 유니코드 및 수학 기호 지원\nJulia 에서는 REPL 에서도 수학 기호를 포함한 다양한 문자를 입력하고 사용 할 수 있습니다. \\ 로 시작되는 구문을 입력한 후에 공백 없이 탭 키를 누르면 자동적으로 기호로 변환된됩니다. 예를 들어 Julia REPL(Julia 에서 지원하는 interactive command line 환경), jupyter notebook, vscode 에서 \\alpha 를 치고 곧바로 탭(tab) 키를 누르면 α 로 변환됩니다. 정확히 말하면 \\alp 정도 까지만 입력한 후 탭키를 눌러도 자동완성 기능으로 인해 \\alpha 가 다 입력된 후 α 로 변환된 것입니다. 이렇게 입력된 α 는 일반 알파벳과 같이 변수명으로도 사용 될 수 있습니다. 이 때 입력되는 구문은 LaTeX 와 같거나 유사한 경우가 많습니다. 주의할 것은 π(\\pi+[tab]) 와 ℯ(\\euler + [tab]) 는 특정 값이 지정되어 있는 대표적인 수학 기호입니다. pi 역시 원주율 입니다.\njulia&gt; π\nπ = 3.1415926535897...\n\njulia&gt; ℯ\nℯ = 2.7182818284590...\n\njulia&gt; pi\nπ = 3.1415926535897...\nJulia 에서 사용할 수 있는 유니코드 기호와 \\로 시작하여 탭 키를 눌러 완성되는 문자들은 julia 공식 문서의 Unicode Input 을 참고하시기 바랍니다."
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html",
    "href": "src/introduction_to_julia/02_variables_basic_types.html",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=2\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 4\n\nIn [3]: abs(a)\nOut[3]: 2\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 삼각함수 값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476"
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=2\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 4\n\nIn [3]: abs(a)\nOut[3]: 2\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 삼각함수 값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476"
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "title": "변수와 기본 타입",
    "section": "2 기본적인 수 타입",
    "text": "2 기본적인 수 타입\n수(number) 를 포함하는 julia 에서 사용하는 모든 값(value) 은 타입(type) 을 갖습니다. 여기서는 julia 언어 자체에서 정의된 기본 타입 가운데 수(number) 에 관련된 타입은 아래와 같습니다.\n\n\n\n\n\n\n\n타입 종류\n타입들\n\n\n\n\n부호 없는 정수 타입\nUInt8, UInt16, UInt32, UInt64, UInt128\n\n\n정수 타입\nInt8, Int16, Int32, Int64, Int128, BigInt\n\n\n유리수 타입\nRational\n\n\n부동소수 타입\nFloat16, Float32, Float64, BigFloat\n\n\n무리수 타입\nIrrational\n\n\n복소수 타입\nComplex\n\n\n불 타입\nBool\n\n\n\n\n부호 없는 정수는 0 과 양의 정수를 말합니다.\n앞서 언급한 π (\\(\\pi\\), 원주율) 나 ℯ (\\(e\\), 자연로그의 밑) 는 무리수 타입으로, 연산할 때 가장 적절한 타입으로 변환되어 계산됩니다.\n타입 이름은 다른 타입의 값을 타입으로 변환시키는 함수이기도 합니다. Float64(1) 은 1 을 Float64 타입으로 변환시킵니다.\n실제 Julia 의 타입 구조는 이보다 훨씬 복잡합니다. 이후 타입 계층 구조 에서 좀 더 자세히 설명하도록 하겠습니다.\n\n\n어떤 변수나 값의 타입을 알기 위해서는 typeof() 함수를 사용 할 수 있습니다.\nIn [4]: typeof(UInt8(2))\nOut[4]: UInt8\n\n\n정수형 타입\n우선 부호 없는 정수타입, 정수타입, 부동소수 타입의 이름의 끝부분에 붙는 8, 16, 32, 64, 128 은 각 타입의 값이 차지하는 비트(bit) 수 입니다. 비트는 on/off 혹은 0/1 로 구분되는 정보 단위입니다. 예를 들어 UInt8 의 경우는 8개의 비트로 수를 표현합니다. 2진수로 00000000 은 0 이며 2진수 11111111 은 255 입니다. UInt8 은 이렇게 0 부터 255 까지의 값을 표현 할 수 있습니다. UInt64 는 64 개의 비트로 숫자를 저장하며, 따라서 0부터 264-1 까지의 숫자를 표현 할 수 있습니다.\nInt8 의 경우는 8비트로 정수를 저장하지만 한 비트는 음수/양수 를 구분하기 위해 사용됩니다. -128 부터 127 까지의 정수를 표현 할 수 있습니다. Int64 는 -232 부터 232-1 까지의 숫자를 표현 할 수 있습니다.\n\n\n\n타입\n부호\n비트수\n최소값\n최대값\n\n\n\n\nInt8\no\n8\n-27\n27 - 1\n\n\nUInt8\nx\n8\n0\n28 - 1\n\n\nInt16\no\n16\n-215\n215 - 1\n\n\nUInt16\nx\n16\n0\n216 - 1\n\n\nInt32\no\n32\n-231\n231 - 1\n\n\nUInt32\nx\n32\n0\n232 - 1\n\n\nInt64\no\n64\n-263\n263 - 1\n\n\nUInt64\nx\n64\n0\n264 - 1\n\n\nInt128\no\n128\n-2127\n2127 - 1\n\n\nUInt128\nx\n128\n0\n2128 - 1\n\n\nBool\nN/A\n8\nfalse (0)\ntrue (1)\n\n\n\n\nmyint=3 처럼 변수를 할당하면 시스템 마다 지정된 기본 타입으로 처리됩니다. 보통의 경우는 Int64 이며 시스템에 따라 Int32 나 다른 타입일 수 있습니다. 보통 Int 가 기본 정수형과 같은 의미로 사용되므로 다음과 같은 입력을 통해 기본 정수형을 알 수 있습니다.\nIn [1]: Int\nOut[1]: Int64\n긴 숫자를 표현할 때 혼란을 줄이는 방법으로 밑줄 _ 을 사용할 수 있습니다. 예를 들어 a=123_4567_89_12 는 밑줄을 없엔 a=12345678912 와 같습니다.\nIn [2]: a=123_4567_89_12\nOut[2]: 12345678912\n\n\nOverflow\n타입이 허용하는 범위의 값을 넘어서는 값을 할당하려 할 때에는 에러가 발생합니다.\nIn [1]: a::UInt8 = 300\nERROR: InexactError: trunc(UInt8, 300)\n...\na::UInt8 = 300 은 UInt8 타입의 변수 a 에 값 300 을 할당하는 명령어입니다. 만얄 a::UInt8=2 라면 2 는 UInt8 범위 내의 수이기 때문에 문제가 발생하지 않지만 300 은 UInt8 의 범위를 벗어나기 떼문에 에러가 발생합니다. 아래의 경우는 에러가 발생되지 않고 틀린 결과가 나옵니다.\nIn [2]: b = UInt8(200)+UInt8(56)\nOut[2]: 0x00\n200 과 56 은 모두 UInt8 의 범위 안이지만 그 합 256 은 범위를 벗어납니다. 이렇게 정수 타입에서 범위를 넘어서는 값이 할당되거나 계산될 때 실제 계산되어야 할 값과는 다른 값이 나오는 것을 overflow 라고 합니다. 해결책은 ? 연산을 잘 조작하여 타입의 범위 내에서 원하는 결과를 얻을 수 있게 하거나, 당신의 변수가 가질 수 있을 가능성이 있는 값을 모두 포함하는 타입을 쓰는 것 밖에는 없습니다. Overflow 시 결과가 어떻게 나오는 지 알고 싶다면 공식 매뉴얼의 Overflow behavior 를 참고하시기 바랍니다.\n\n\n\n\n부동소수 타입\n부동소수는 일반적인 실수 (real number) 를 표현하기 위한 타입으로 가장 많이 사용하며, 부동소수의 기본타입인 Float64 타입의 경우 fn1 = 3.33 나 fn2=2.3e-4 처럼 사용합니다. 후자의 경우는 2.3 × 10-4 와 같습니다. 그리고 e 대신 E 를 사용해도 됩니다. e 나 E 대신 f 를 사용하면 Float32 타입으로 지정됩니다. 2.3f0 의 경우는 Float32 타입의 2.3 을 의미하며 2.3f2 와 2.3f-2 의 경우는 각각 Float32 타입의 2.3 × 102 와 2.3 × 10-2 를 의미합니다. 부동정수형과 마찬가지로 숫자 사이에 밑줄을 넣어서 사용 할 수 있습니다. 혹은 정수에서와 같이 a::Float32=3.3 처럼 변수에 타입을 지정할 수 있습니다. 이 경우 할당되는 값이 지정된 타입(여기서는 Float32)으로 변환됩니다.\nIn [1]: 3.14_1592\nOut[1]: 3.141592\n\nIn [2]: c::Float32=3.3\nOut[2]: 3.3\n\nIn [3]: typeof(c)\nOut[3]: Float32\n\nIn [4]: c\nOut[4]: 3.3f0\n\n\n\n유리수 타입 (Rational) 과 복소수 타입 (Complex)\n유리수 타입은 두개의 정수 타입을 이용하여 하나는 분모, 하나는 분자로 사용하여 유리수를 표현합니다. 복소수 타입은 두개의 실수를 이용하여 하나는 실수부, 하나는 허수부로 사용하여 복소수를 표현합니다.\nRational 타입의 경우 // 연산자를 이용하거나 Rational(3, 4) 와 같이 할당합니다.. a=1//3 는 Rational(1, 3) 과 같고, a 라는 변수에 \\(\\frac{1}{3}\\) 을 저장합니다. 유리수값끼리의 혹은 유리수값과 정수의 사칙연산은 유리수가 되며, 자동적으로 약분하여 가장 간단한 값으로 처리됩니다.\nIn [1]: 6//5 + 1 # 유리수와 정수의 연산\nOut[1]: 11//5\n\nIn [2]: 1//2 + 1.0 # 유리수와 실수의 연산\nOut[2]: 1.5\n\nIn [3]: 27//12   # 유리수 입력은 자동으로 약분된다.\nOut[3]: 9//4\n\nIn [4]: 1//12 + 2//12 # 유리수 연산 후 약분된다.\nOut[4]: 1//4\n\nComplex 타입의 경우는 2.0 + 3.0im 혹은 Complex(2.0, 3.0) 과 같이 할당합니다. Julia 에서 im 은 \\(\\sqrt{-1}\\) 로 정의되었으며 i 나 j 와 같은 문자를 사용하지 않습니다. conj() 함수는 켤레복수수를 반환합니다.\nIn [7]: (1.0+1.0im)*(1.0-1.0im)\nOut[7]: 2.0 + 0.0im\n\nIn [8]: conj(Complex(1.0, 1.0))\nOut[8]: 1.0 - 1.0im\n\n\n\n불 타입\n불 타입은 단지 참을 나타내는 true 와 거짓을 나타내는 false 의 두 값만을 표현하는 정수형 타입입니다. 수로 변환하면 true 는 1 이며 false 는 0 입니다. 거꾸로 수를 불 타입으로 변환하는 경우 1 혹은 1 과 같다고 평가되는 1.0f0 와 같은 수는 true 로 0 혹은 0 과 같다고 평가되는 0.0 은 false 로 변환됩니다. Python 과 같은 언어에서는 0 혹은 0 과 같다고 평가되는 수만 False 이고 나머지 수는 모두 True 로 평가됩니다.\nIn [1]: Bool(-3)\nERROR: InexactError: Bool(-3)\n...\n\nIn [2]: Bool(1.0)\nOut[2]: true\n\nIn [3]: Bool(1.0f0)\nOut[3]: true\n\nIn [4]: Bool(3//3)\nOut[4]: true\n\nIn [5]: Bool(0//1)\nOut[5]: false\n\n\n\n타입 확인\n변수의 값이 특정 타입인지를 비교해야 할 때 가장 간단하게 사용할 수 있는 함수는 isa 입니다. isa 는 함수이기도 하지만 연산자이기도 합니다.\nIn [1]: isa(3.3f0, Float32)   # isa 를 함수처럼 사용할 경우\nOut[1]: true\n\nIn [2]: 3.3f0 isa Float64     # isa 를 연산자처럼 사용할 경우\nOut[2]: false\n\n\n\n타입 변환\n앞서 언급했듯이 타입 이름은 그 타입으로 변환시키는 함수의 이름이기도 합니다.\nIn [5]: Float32(3.32)\nOut[5]: 3.32f0\n많은 언어에서는 실수를 정수로 변환할 때 억지로라도 변환시켜주지만 julia 에서는 실수가 정수와 같지 않으면 에러가 발생합니다.\nIn [6]: Int64(2.0)\nOut[6]: 2\n\nIn [7]: Int64(2.001)\nERROR: InexactError: Int64(2.001)\n...\n이때는 반올림 (round), 내림(floor), 올림(ceil) 함수를 사용 할 수 있습니다. 이 함수들은 입력값의 타입으로 반올림한 값을 반환합니다. round(3.3) 처럼 사용해도 되지만 특정 정수 타입으로 변환할때는 ceil(UInt16, 4.2) 처럼 타입을 명시하여 변환해야 합니다.\nIn [8]: round(2.3)\nOut[8]: 2.0\n\nIn [9]: floor(4.3f0)\nOut[9]: 4.0f0\n\nIn [10]: ceil(UInt16, 4.2)\nOut[10]: 0x0005"
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "title": "변수와 기본 타입",
    "section": "3 문자와 문자열, 기호 타입",
    "text": "3 문자와 문자열, 기호 타입\n\nChar 와 String 타입\nChar 는 ascii 나 유니코드 하나의 문자에 대한 타입이며 String 은 하나 이상의 문자에 대한 타입입니다. Char 타입은 a 와 같이 따옴표 ' 로 감싸서 선언합니다. 한줄 문자열은 겹따옴표(\") 로 감싸고 여러줄 문자열은 겹따옴표 세개(\"\"\")로 감쌉니다. 문자열을 출력할때는 println 함수를 사용합니다. println 함수의 경우 인자를 , 로 분리하여 계속 써 주면 각각의 인자를 문자열로 변환하여 연결시켜 하나의 문자열을 출력합니다.\nIn [11]: char1='가'\nOut[11]: '가': Unicode U+AC00 (category Lo: Letter, other)\n\nIn [12]: str1 = \"Hello, world.\\n\"\nOut[12]: \"Hello, world.\\n\"\n\nIn [13]: str2 = \"\"\"Julia is\n                a good programing\n                language\"\"\"\nOut[13]: \"Julia is\\na good programing\\nlanguage\"\n\nIn [14]: println(str2)\nJulia is\na good programing\nlanguage\n\nIn [15]: println(1, \"ab\", \" c_d \", 3.3)\n1ab c_d 3.3\nasciii 는 컴퓨터 자판에서 보이는 숫자, 영어 알파벳과 기호를 포함하며 각 문자가 1바이트를 차지합니다. ascii 문자로 이루어진 문자열은 1부터 시작하는 인덱스로 접근 할 수 있습니다.\nIn [16]: str3 = \"I love Julia language !!!\"\nOut[16]: \"I love Julia language !!!\"\n\nIn [17]: str3[1], str3[end], str3[end-4]\nOut[17]: ('I', '!', 'e')\n인덱스에서 end 는 맨 마지막 인덱스를 의미하며 end-4 은 마지막에서 다섯번째 글자를 의미합니다. end-2 는 마지막에서 세번째입니다. 정확히 말하면 str3[3] 은 문자열 str3 에서 세번째 글자가 아니라 세번째 바이트에서 시작하는 문자를 의미합니다. ascii 에서는 각 문자가 1 바이트를 차지하기 때문에 세번째 바이트에서 시작하는 문자와 세번째 문자가 같지만 2 바이트 이상을 차지하는 문자에서는 다른 의미가 됩니다.\n\n\n\n유니코드(Unicode)\n유니코드(unicode) 는 전 세계의 모든 문자를 다룰 수 있도록 제정된 표준 문자 처리 방식입니다. 유니코드를 표기할때는 U+0A03 처럼 U+ 와 16진수의 결합으로 표현합니다. 앞서 언급한 Unicode Input 에 julia 에서 표현 할 수 있는 문자들이 나열되어있습니다.\n유니코드를 문자열로 표현할 때는 탭으로 완성되는 문자를 사용 할 수도 있고 다음처럼 \\u 혹은 \\U 로 시작되는 문자로 표현 할 수도 있습니다. \\u 다음에는 4개까지의 16진수 문자가 올 수 있으며 \\U 다음에는 8개까지의 16진수 문자가 올 수 있고 \\u 를 포함하여 더 많은 문자를 표현 할 수 있습니다. \\u 나 \\U 다음에 오는 숫자 가운데 자릿수를 차지하는 0 은 생략 할 수 있습니다. 예를 들어 \\u0033 은 \\u33 과 같습니다. 그리고 \\U000000 부터 \\U00FFFF 까지는 \\u0000 과 \\uffff 까지와 같습니다. 유니코드는 다음과 같이 사용합니다.\nIn [18]: unistr = \"\\u2200 x \\u2203 y\"\nOut[18]: \"∀ x ∃ y\"\nJulia 에서 유니코드는 UTF-8 로 인코딩 되어 있습니다. UTF-8 에서는 각 문자당 차지하는 바이트수가 다르기 때문에 ascii 와 같은 인덱스를 사용 할 수 없습니다. 앞서 설명했듯이 unistr[2] 는 문자열 unistr 의 2번째 바이트에서 시작하는 문자를 의미하는데 \\u2200 은 3 바이트 문자이므로 2번째 바이트에서 시작하는 문자가 없으므로 에러가 발생합니다.\nIn [19]: unistr[1]\nOut[19]: '∀': Unicode U+2200 (category Sm: Symbol, math)\n\nIn [20]: unistr[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;'∀', [4]=&gt;' '\n...\n\nIn [21]: unistr[4]\nOut[21]: ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\n\n\n\n\n\n유니코드 문자열의 인덱스\n\n\n\n유니코드 문자열을 다룰 때 인덱스의 의미는 언어마다 다릅니다. 예를 들어 Python 에서는 인덱스 가 i 일 때 i 번째 문자를 의미합니다. 아래는 Python shell 에서 같은 일을 한 결과입니다. 참고로 julia 는 인덱스가 1부터 시작하지만 python 은 0 부터 시작하기 때문에 인덱스가 차이가 납니다.\n&gt;&gt;&gt; unistr = \"\\u2200 x \\u2203 y\"\n&gt;&gt;&gt; unistr\n'∀ x ∃ y'\n&gt;&gt;&gt; unistr[0]\n'∀'\n&gt;&gt;&gt; unistr[1]\n' '\n&gt;&gt;&gt; unistr[2]\n'x'\n\n\n\n\n\n문자열 연산과 함수\n\n결합과 반복\n문자열을 합칠 때는 * 연산자를 이용하거나 string() 함수를 이용하며, 여러번 반복할때는 ^ 연산자 나 repeat() 함수를 이용합니다. 실제로 string() 함수는 인자를 차례대로 문자열로 바꾸어 주는 함수입니다.\nIn [1]: \"가나다라\"*\"마바사\" # 문자열 합치기\nOut[1]: \"가나다라마바사\"\n\nIn [2]: string(\"가나다라\", \"abc\", 'π', 5) # 문자열 합치기\nOut[2]: \"가나다라abcπ5\"\n\nIn [3]: \"αβγ\"^3 # 문자열 반복\nOut[3]: \"αβγαβγαβγ\"\n\nIn [4]: repeat(\"Δ=\", 5) # 문자열 반복\nOut[4]: \"Δ=Δ=Δ=Δ=Δ=\"\n문자열의 길이는 length() 함수를 사용하며 문자열에 접근할 때는 str1[3] 과 같이 인덱스를 사용합니다. Julia 에서는 처음 인덱스는 0 이 아닌 1 입니다.\nIn [5]: str3=\"abcdefg\";str3[2]\nOut[5]: 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\n\n\n\n문자열 보간\n문자열에 $ 기호를 통해 이미 정의된 변수를 사용하여 문자열을 구성 할 수 있습니다.\nIn [6]: aa=1;bb=22.2;cc=\"C12\";\n\nIn [7]: \"\"\"aa=$aa, bb=$bb, cc=$cc\"\"\"\nOut[7]: \"aa=1, bb=22.2, cc=C12\"\n보간 이전에 값을 평가해야 할 경우에는 괄호(( )) 안에 식을 넣을 수 있습니다. 예를 들어 \"$sin(π)\" 는 문자열 \"sin(π)\" 지만 \"$(sin(π))\" 는 sin(π) 를 평가한 0.0 이 문자열로 입력됩니다.\nIn [9]: \"$sin(π)\"\nOut[9]: \"sin(π)\"\n\nIn [10]: \"$(sin(π))\"\nOut[10]: \"0.0\"\n\n\n비교\n문자열을 사전순으로 비교 할 수 있습니다. 즉 a &lt; b 이며 aa &lt; ab 입니다.\nIn [11]: \"abracadabra\" &lt; \"xylophone\"\nOut[11]: true\n\nIn [12]: \"abracadabra\" == \"xylophone\"\nOut[12]: false\n\nIn [13]: \"Hello, world.\" != \"Goodbye, world.\"\nOut[13]: true\n\nIn [14]: \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\nOut[14]: true\n\n\n\n문자열 함수\nfindfirst(a, str) 은 문자열 str 에서 문자 혹은 문자열 a 가 나타는 첫번째 인덱스를 리턴합니다. findlast(a, str) 는 마지막 인덱스를 리턴합니다. findprev(a, str, i) 는 문자열 str 에서 문자 혹은 문자열 a 를 찾는데 인덱스 i 부터 앞으로 찾아가서 나오는 첫번째 인덱스를 반환합니다. findnext(a, str, i) 는 인덱스 i 부터 뒤로 찾아가서 나오는 첫번째 인덱스를 반환합니다. 네가지 경우 모두 찾지 못한다면 nothing 을 반환합니다. a 가 문자열일 경우는 a 와 일치하는 인덱스의 범위를 리턴합니다. 6:7 은 인덱스 6에서 인덱스 7 까지란 의미입니다. occursin(a, str) 은 문자 혹은 문자열 a 가 문자열 str 에 포함되어 있는지만을 확인하여 true 나 false 를 리턴합니다.\nIn [15]: findfirst('a', \"biography\")\nOut[15]: 6\n\nIn [16]: findfirst(\"ap\", \"biography\")\nOut[16]: 6:7\n\nIn [17]: occursin(\"gr\", \"biography\")\nOut[17]: true\n\nIn [18]: occursin(\"rp\", \"biography\")\nOut[18]: false\n\nrepeat(a, n) 은 문자열 a 를 n 번 반복한 문자열을 반환합니다. 여러 문자열을 결합할 때는 join() 함수를 사용합니다.\nIn [19]: repeat(\".:Z:.\", 10)\nOut[19]: \".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\nIn [20]: join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\nOut[20]: \"apples, bananas and pineapples\"\njoin 함수의 두번째 인자 \", \" 는 결합하는 문자열 사이에 \", \" 를 끼워 결합하라는 의미입니다. 세번째 인자 \" and \" 는 마지막 두 문자열을 결합할때는 \", \" 대신에 \" and \" 를 사용하라는 의미입니다. 자세한 것은 julia 의 공식 도움말을 참고하시기 바랍니다.\n\n\n\n\n심볼 타입\n심볼(Symbol) 타입은 문자열과 비슷하지만 다릅니다. 심볼(Symbol) 타입은 : 다음의 문자열, 혹은 Symbol 이라는 타입 이름을 함수로 사용하여 다음과 같이 선언할 수 있습니다.\nIn [21]: a=Symbol(\"bc\") # `Symbol` 함수를 이용한 선언\nOut[21]: :bc\n\nIn [22]: b=:bc # 콜론 `:` 을 이용한 선언\nOut[22]: :bc\n\nIn [23]: a==b # 두 선언은 같다.\nOut[23]: true\n심볼 타입은 Julia 에서 소위 메타 프로그래밍 개념의 핵심이지만 여기서는 자세히 다루지 않겠습니다. 심볼 타입이 많이 쓰이는 다른 경우는 함수에 인자로 전달할 때 입니다. 예를 들어 그래프를 빨간 색으로 그리고 싶을 때, 다른 언어라면 \"red\" 라는 문자열을 함수의 인자로 입력하는 경우가 많은데, Julia 에서는 이렇게 문자열을 쓸 수도 있지만 :red 라는 심볼 타입을 전달하는 경우가 많습니다. 이 경우 비교가 문자열보다 빠릅니다.\n\n\n\n변수의 타입 지정과 타입 유니온\n예를 들어 변수 a 에 UInt8 타입의 3 을 할당한다고 해 봅시다. a=UInt8(3) 처럼 해도 되지만\nIn [1]: a::UInt8 = 3\nOut[1]: 3\n\nIn [2]: a\nOut[2]: 0x03\n처럼 해도 됩니다. 실제로 이 방법은 변수 할당보다는 함수의 인자에 많이 사용되는 방법이긴 합니다.\n타입 유니온은 변수가 가질 수 있는 타입을 하나가 아닌 여러개중 하나로 할 때 사용되며 Union{T1, T2} 처럼 사용됩니다. T1, T2 는 변수가 가질 수 있는 타입이며 두개 이상일 경우에는 , 로 구분하여 나열합니다. 다음 보기를 봅시다.\nIn [1]: a::Union{Int, AbstractString}=\"a\"\nOut[1]: \"a\"\n\nIn [2]: b::Union{Int, AbstractString}=3\nOut[2]: 3\n\nIn [3]: c::Union{Int, AbstractString, Nothing}=nothing\n\nIn [4]: (a, b, c)\nOut[4]: (\"a\", 3, nothing)\nIn [1] 의 경우는 입력값이 문자열이므로 a 는 문자열 타입이 되고, b 는 입력값이 정수이므로 정수 타입이 되었습니다. c 는 세가지 타입중에 선택하도록 하는 것입니다. 이런 방법 역시 일반적인 변수에 값을 할당할 때 보다 함수의 인자의 타입을 제한 할 때 사용됩니다. 그리고 nothing 은 값이고 Nothing 은 nothing 에 대한 타입입니다."
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html",
    "href": "src/introduction_to_julia/03_functions_and_operators.html",
    "title": "연산자와 함수",
    "section": "",
    "text": "연산자는 add(a, b) 와 같은 함수 형식을 따르지 않고 부호로 표현되는 함수를 말합니다.\n\n\n많은 다른 프로그래밍 언어에서와 같이 x = y 는 y 의 값을 x 에 할당한다는 표현식이며 == 와 === 는 이 기호의 왼편과 오른편의 변수나 값이 같은지 아닌지를 판단하여 같으면 true 다르면 false 를 반환하는 연산자입니다. === 는 == 보다 더 엄격하게 판단합니다. 예를 들어,\nIn [1]: 2==2.0\nOut[1]: true\n\nIn [2]: 2===2.0\nOut[2]: false\n를 보면 2==2.0 은 true 이지만 2===2.0 은 false 입니다. === 는 타입의 종류까지 같아야 true 를 반환합니다. 그런데 == 는 좀 혼란스럽습니다. 다음 경우를 봅시다.\nIn [3]: 1.0 == 1.0f0\nOut[3]: true\n\nIn [4]: 2.0 == 2.0f0\nOut[4]: true\n\nIn [5]: 1.2 == 1.2f0\nOut[5]: false\n\nIn [6]: Float32(1.2) == 1.2f0\nOut[6]: true\n1.0 등 왼쪽의 값들은 모두 Float64 타입이며 오른쪽의 값들은 Float32 의 값입니다. 1.0 == 1.0f0 는 true 인데 1.2 == 1.2f0 는 false 입니다. 이런 행동을 내부적인 코드 수준에서 이해하는 것은 힘든 일입니다. 다만 다른 타입의 값을 비교할 때, 특히 같은지 여부를 판단할 때는 매우 조심해야 한다는 것을 알아야 합니다.\n\n\n\n\n기본적인 값에 대한 연산에는 다음과 같은 것들이 있습니다.\n\n\n\n표현\n정의\n\n\n\n\n+x\n항등 연산\n\n\n-x\n덧셈에 대한 역원\n\n\nx + y\n덧셈\n\n\nx - y\n뺄셈\n\n\nx * y\n곱셈\n\n\nx / y\n나눗셈\n\n\nx ÷ y\n나눗셈의 정수 몫, div(x, y) 와 같다.\n\n\nx \\ y\n역 나눗셈. y / x 와 같다.\n\n\nx ^ y\n거듭제곱. x 의 y 승\n\n\nx % y\n나머지. rem(x, y) 와 같다.\n\n\nx//y\nx, y 가 정수일 때 유리수 타입의 \\(x/y\\)\n\n\n\n\n÷ 는 \\div+ [tab] 키 로 입력 할 수 있습니다.\nx / y 에서 x 와 y 가 모두 정수일 때는 실수로 타입이 변환됩니다. 즉 5/2 는 2.5 입니다. ㅋ\nx//y 는 x, y 가 정수일 때 Julia 의 Rational 타입의 값을 반환합니다. 앞서 말했듯이 Julia 에서 유리수는 Int64 나 Float64 와 같은 고유한 타입입니다.\nx ÷ y 는 x 와 y 가 모두 정수 타입이라면 정수몫을 리턴하지만 x 나 y 가 정수가 아닌 부동수일 경우에는 정수몫을 부동소수로 반환합니다. 아래의 예를 참고하세요.\n\nIn [7]: 173 ÷ 2\nOut[7]: 86\n\nIn [8]: 173 ÷ 2.0\nOut[8]: 86.0\n\nIn [9]: 173.0 ÷ 2\nOut[9]: 86.0\n\nIn [10]: -173 ÷ 2\nOut[10]: -86\n\n\n\n실수 \\(a\\) 를 실수 \\(d\\) 로 나눌 때 \\(a=k\\cdot d + r\\) 을 만족하는 정수 \\(k\\)를 몫이라고 하고 \\(r\\) 을 나머지라고 합니다. \\(a,\\,d\\) 가 양수라면 \\(0\\le r &lt; d\\) 를 만족하는 \\(r\\) 을 찾으면 됩니다. 그런데 \\(a,\\,d\\) 둘 가운데 하나라도 음수 일 경우를 생각해 봅시다. 예를 들어 \\(13.0\\) 을 \\(-3.0\\) 으로 나누는 경우,\n\\[\n\\begin{aligned}\n13.0 &= (-4.0) \\times (-3.0) -1.0, \\\\\n13.0 &= (-5.0) \\times (-3.0) + 2.0,\n\\end{aligned}\n\\]\n과 같이 몫 나머지를 각각 (-4.0, -1.0) 이나 (-5.0, 2.0) 으로 생각 할 수 있습니다. \\(a=kd + r\\) 할 때 나머지 \\(r\\) 의 부호를 \\(a\\) 를 따르도록 하는 경우와 \\(d\\) 의 부호를 따르도록 하는 경우가 있는데 julia 의 나머지 a % r 은 a 의 부호를 따릅니다. 모든 경우에 대해 \\(0 \\le |r| &lt; |d|\\) 입니다.\nIn [11]: -13.0 % 3.0\nOut[11]: -1.0\n\nIn [12]: 13.0 % -3.0\nOut[12]: 1.0\n\nIn [13]: -13.0 % -3.0\nOut[13]: -1.0\n\n\n\n\n\n\n부동소수 나머지 연산에서의 Round-off 에러\n\n\n\n원칙적으로는 a == (a ÷ d) * d + (a % d) 이어야 하지만, a 나 d 가 부동소수일 경우 round-off 에러로 인해 차이가 있을 수 있습니다.\nIn [14]: (-13.3 ÷ 3.0) * 3.0 + (-13.3 % 3.0)\nOut[14]: -13.3\n\nIn [15]: (17.24 ÷ 3.42) * 3.42 + (17.24 % 3.42)\nOut[15]: 17.240000000000002\n\n\n\n\n\n\n\n불(Bool) 타입에 대한 연산은 다음과 같은 것이 있습니다.\n\n\n\n표현\n설명\n\n\n\n\n!x\n부정(negation)\n\n\nx && y\nshort-circuiting and\n\n\nx || y\nshort-circuiting or\n\n\n\n\n!(true) 는 false 이고 !(false) 는 true 입니다.\n아래에 나오는 비트별 연산자 & 와 | 도 불 연산에 and 연산과 or 연산으로 사용될 수 있습니다.\n\n\n\n\n\nx && y 에서 x 가 불(Bool) 값이고 y 가 어떤 명령문일때, x 가 true 이면 y 를 실행시키고 x 가 false 이면 false 를 리턴합니다. x || y 일 때는 반대로 x 가 true 이면 true 를 리턴하고 x 가 거짓이면 y 를 실행시킵니다. 불 연산을 사용하여 조건에 따라 실행시키는 것을 short-circuiting 연산이라고 하며, julia 에서 상당히 많이 사용되는 테크닉 입니다.\nIn [19]: x=3\nOut[19]: 3\n\nIn [20]: x&gt;0 && println(\"true and short-circuiting and\")\ntrue and short-circuiting and\n\nIn [21]: x&lt;0 && println(\"false and short-circuiting and\")\nOut[21]: false\n\nIn [22]: x&gt;0 || println(\"true and short-circuiting or\")\nOut[22]: true\n\nIn [23]: x&lt;0 || println(\"false and short-circuiting or\")\nfalse and short-circuiting or\n\n\n\n\n비트는 true 혹은 false 값을 갖는 정보 단위입니다. 아래의 표는 비트에 대한 연산자를 설명합니다.\n\n\n\n표현\nName\n\n\n\n\n~x\nbitwise not\n\n\nx & y\nbitwise and\n\n\nx | y\nbitwise or\n\n\nx ⊻ y\nbitwise xor (exclusive or)\n\n\nx ⊼ y\nbitwise nand (not and)\n\n\nx ⊽ y\nbitwise nor (not or)\n\n\nx &gt;&gt;&gt; y\nlogical shift right\n\n\nx &gt;&gt; y\narithmetic shift right\n\n\nx &lt;&lt; y\nlogical/arithmetic shift left\n\n\n\n\n⊻ 는 \\xor + 탭키, ⊼ 는 \\nand + 탭키, ⊽ 는 \\nor + 탭키 로 입력합니다. &gt;&gt;&gt; 나 &lt;&lt; 는 단순한 키보드 입력입니다.\n한국어 위키백과-비트연산 과 영어 위키백과-비트연산 을 참고하시기 바랍니다\nx&gt;&gt;y 의 경우는 정수 x 를 \\(2^y\\) 로 나눈 몫을 계산하는데 자주 사용됩니다. 예를 들어\n\nIn [24]: 15&gt;&gt;1 # 15 나누기 2^1=2 의 몫\nOut[24]: 7\n\nIn [25]: 427&gt;&gt;2 #427 나누기 2^2=4 의 몫\nOut[25]: 106\n입니다.. 비트연산에 대해 편리한 함수로 입력값을 비트 문자열로 바꾸어주는 bitstring() 함수가 있습니다.\nIn [26]: bitstring(1)\nOut[26]: \"0000000000000000000000000000000000000000000000000000000000000001\"\n\nIn [27]: bitstring(3.23)\nOut[27]: \"0100000000001001110101110000101000111101011100001010001111010111\"\n\n\n\n\n비교 연산은 표현을 평가하여 true 혹은 false 를 반환합니다.\n\n\n\n표현\ntrue 인 경우\n\n\n\n\nx == y\nx 와 y 가 같을 때\n\n\nx != y, x ≠ y\nx 와 y 가 다를 때\n\n\nx &lt; y\nx 가 y 보다 작을 때\n\n\nx &lt;= y, x ≤ y\nx 가 y 보다 작거나 같을 때\n\n\nx &gt; y\nx 가 y 보다 클 때\n\n\nx &gt;= y , x ≥ y\nx 가 y 보다 크거나 같을 때\n\n\n\n\n≠ 는 \\ne+탭 키, ≤ 는 \\le+ 탭 키, ≥ 는 \\ge + 탭 키 를 통해 입력합니다.\n비교 연산을 1 &lt; 2 &lt;= 3 &lt; 5 != 10 &lt; 12 같이 이어서 쓸 수 있습니다. 모든 비교 항목이 true 일 때만 true 를 리턴합니다.\n\n특히 부동소수가 포함된 계산의 결과를 비교할때는 조심해야 합니다. Round-off 에러로 인해 생각하는 것과 실제가 다를 수 있습니다.\nIn [28]: 0 == 0.0\nOut[28]: true\n\nIn [29]: 4 == 4.0\nOut[29]: true\n\nIn [30]: 8.3-1.0 == 7.3\nOut[30]: false"
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html#기본-연산자",
    "href": "src/introduction_to_julia/03_functions_and_operators.html#기본-연산자",
    "title": "연산자와 함수",
    "section": "",
    "text": "연산자는 add(a, b) 와 같은 함수 형식을 따르지 않고 부호로 표현되는 함수를 말합니다.\n\n\n많은 다른 프로그래밍 언어에서와 같이 x = y 는 y 의 값을 x 에 할당한다는 표현식이며 == 와 === 는 이 기호의 왼편과 오른편의 변수나 값이 같은지 아닌지를 판단하여 같으면 true 다르면 false 를 반환하는 연산자입니다. === 는 == 보다 더 엄격하게 판단합니다. 예를 들어,\nIn [1]: 2==2.0\nOut[1]: true\n\nIn [2]: 2===2.0\nOut[2]: false\n를 보면 2==2.0 은 true 이지만 2===2.0 은 false 입니다. === 는 타입의 종류까지 같아야 true 를 반환합니다. 그런데 == 는 좀 혼란스럽습니다. 다음 경우를 봅시다.\nIn [3]: 1.0 == 1.0f0\nOut[3]: true\n\nIn [4]: 2.0 == 2.0f0\nOut[4]: true\n\nIn [5]: 1.2 == 1.2f0\nOut[5]: false\n\nIn [6]: Float32(1.2) == 1.2f0\nOut[6]: true\n1.0 등 왼쪽의 값들은 모두 Float64 타입이며 오른쪽의 값들은 Float32 의 값입니다. 1.0 == 1.0f0 는 true 인데 1.2 == 1.2f0 는 false 입니다. 이런 행동을 내부적인 코드 수준에서 이해하는 것은 힘든 일입니다. 다만 다른 타입의 값을 비교할 때, 특히 같은지 여부를 판단할 때는 매우 조심해야 한다는 것을 알아야 합니다.\n\n\n\n\n기본적인 값에 대한 연산에는 다음과 같은 것들이 있습니다.\n\n\n\n표현\n정의\n\n\n\n\n+x\n항등 연산\n\n\n-x\n덧셈에 대한 역원\n\n\nx + y\n덧셈\n\n\nx - y\n뺄셈\n\n\nx * y\n곱셈\n\n\nx / y\n나눗셈\n\n\nx ÷ y\n나눗셈의 정수 몫, div(x, y) 와 같다.\n\n\nx \\ y\n역 나눗셈. y / x 와 같다.\n\n\nx ^ y\n거듭제곱. x 의 y 승\n\n\nx % y\n나머지. rem(x, y) 와 같다.\n\n\nx//y\nx, y 가 정수일 때 유리수 타입의 \\(x/y\\)\n\n\n\n\n÷ 는 \\div+ [tab] 키 로 입력 할 수 있습니다.\nx / y 에서 x 와 y 가 모두 정수일 때는 실수로 타입이 변환됩니다. 즉 5/2 는 2.5 입니다. ㅋ\nx//y 는 x, y 가 정수일 때 Julia 의 Rational 타입의 값을 반환합니다. 앞서 말했듯이 Julia 에서 유리수는 Int64 나 Float64 와 같은 고유한 타입입니다.\nx ÷ y 는 x 와 y 가 모두 정수 타입이라면 정수몫을 리턴하지만 x 나 y 가 정수가 아닌 부동수일 경우에는 정수몫을 부동소수로 반환합니다. 아래의 예를 참고하세요.\n\nIn [7]: 173 ÷ 2\nOut[7]: 86\n\nIn [8]: 173 ÷ 2.0\nOut[8]: 86.0\n\nIn [9]: 173.0 ÷ 2\nOut[9]: 86.0\n\nIn [10]: -173 ÷ 2\nOut[10]: -86\n\n\n\n실수 \\(a\\) 를 실수 \\(d\\) 로 나눌 때 \\(a=k\\cdot d + r\\) 을 만족하는 정수 \\(k\\)를 몫이라고 하고 \\(r\\) 을 나머지라고 합니다. \\(a,\\,d\\) 가 양수라면 \\(0\\le r &lt; d\\) 를 만족하는 \\(r\\) 을 찾으면 됩니다. 그런데 \\(a,\\,d\\) 둘 가운데 하나라도 음수 일 경우를 생각해 봅시다. 예를 들어 \\(13.0\\) 을 \\(-3.0\\) 으로 나누는 경우,\n\\[\n\\begin{aligned}\n13.0 &= (-4.0) \\times (-3.0) -1.0, \\\\\n13.0 &= (-5.0) \\times (-3.0) + 2.0,\n\\end{aligned}\n\\]\n과 같이 몫 나머지를 각각 (-4.0, -1.0) 이나 (-5.0, 2.0) 으로 생각 할 수 있습니다. \\(a=kd + r\\) 할 때 나머지 \\(r\\) 의 부호를 \\(a\\) 를 따르도록 하는 경우와 \\(d\\) 의 부호를 따르도록 하는 경우가 있는데 julia 의 나머지 a % r 은 a 의 부호를 따릅니다. 모든 경우에 대해 \\(0 \\le |r| &lt; |d|\\) 입니다.\nIn [11]: -13.0 % 3.0\nOut[11]: -1.0\n\nIn [12]: 13.0 % -3.0\nOut[12]: 1.0\n\nIn [13]: -13.0 % -3.0\nOut[13]: -1.0\n\n\n\n\n\n\n부동소수 나머지 연산에서의 Round-off 에러\n\n\n\n원칙적으로는 a == (a ÷ d) * d + (a % d) 이어야 하지만, a 나 d 가 부동소수일 경우 round-off 에러로 인해 차이가 있을 수 있습니다.\nIn [14]: (-13.3 ÷ 3.0) * 3.0 + (-13.3 % 3.0)\nOut[14]: -13.3\n\nIn [15]: (17.24 ÷ 3.42) * 3.42 + (17.24 % 3.42)\nOut[15]: 17.240000000000002\n\n\n\n\n\n\n\n불(Bool) 타입에 대한 연산은 다음과 같은 것이 있습니다.\n\n\n\n표현\n설명\n\n\n\n\n!x\n부정(negation)\n\n\nx && y\nshort-circuiting and\n\n\nx || y\nshort-circuiting or\n\n\n\n\n!(true) 는 false 이고 !(false) 는 true 입니다.\n아래에 나오는 비트별 연산자 & 와 | 도 불 연산에 and 연산과 or 연산으로 사용될 수 있습니다.\n\n\n\n\n\nx && y 에서 x 가 불(Bool) 값이고 y 가 어떤 명령문일때, x 가 true 이면 y 를 실행시키고 x 가 false 이면 false 를 리턴합니다. x || y 일 때는 반대로 x 가 true 이면 true 를 리턴하고 x 가 거짓이면 y 를 실행시킵니다. 불 연산을 사용하여 조건에 따라 실행시키는 것을 short-circuiting 연산이라고 하며, julia 에서 상당히 많이 사용되는 테크닉 입니다.\nIn [19]: x=3\nOut[19]: 3\n\nIn [20]: x&gt;0 && println(\"true and short-circuiting and\")\ntrue and short-circuiting and\n\nIn [21]: x&lt;0 && println(\"false and short-circuiting and\")\nOut[21]: false\n\nIn [22]: x&gt;0 || println(\"true and short-circuiting or\")\nOut[22]: true\n\nIn [23]: x&lt;0 || println(\"false and short-circuiting or\")\nfalse and short-circuiting or\n\n\n\n\n비트는 true 혹은 false 값을 갖는 정보 단위입니다. 아래의 표는 비트에 대한 연산자를 설명합니다.\n\n\n\n표현\nName\n\n\n\n\n~x\nbitwise not\n\n\nx & y\nbitwise and\n\n\nx | y\nbitwise or\n\n\nx ⊻ y\nbitwise xor (exclusive or)\n\n\nx ⊼ y\nbitwise nand (not and)\n\n\nx ⊽ y\nbitwise nor (not or)\n\n\nx &gt;&gt;&gt; y\nlogical shift right\n\n\nx &gt;&gt; y\narithmetic shift right\n\n\nx &lt;&lt; y\nlogical/arithmetic shift left\n\n\n\n\n⊻ 는 \\xor + 탭키, ⊼ 는 \\nand + 탭키, ⊽ 는 \\nor + 탭키 로 입력합니다. &gt;&gt;&gt; 나 &lt;&lt; 는 단순한 키보드 입력입니다.\n한국어 위키백과-비트연산 과 영어 위키백과-비트연산 을 참고하시기 바랍니다\nx&gt;&gt;y 의 경우는 정수 x 를 \\(2^y\\) 로 나눈 몫을 계산하는데 자주 사용됩니다. 예를 들어\n\nIn [24]: 15&gt;&gt;1 # 15 나누기 2^1=2 의 몫\nOut[24]: 7\n\nIn [25]: 427&gt;&gt;2 #427 나누기 2^2=4 의 몫\nOut[25]: 106\n입니다.. 비트연산에 대해 편리한 함수로 입력값을 비트 문자열로 바꾸어주는 bitstring() 함수가 있습니다.\nIn [26]: bitstring(1)\nOut[26]: \"0000000000000000000000000000000000000000000000000000000000000001\"\n\nIn [27]: bitstring(3.23)\nOut[27]: \"0100000000001001110101110000101000111101011100001010001111010111\"\n\n\n\n\n비교 연산은 표현을 평가하여 true 혹은 false 를 반환합니다.\n\n\n\n표현\ntrue 인 경우\n\n\n\n\nx == y\nx 와 y 가 같을 때\n\n\nx != y, x ≠ y\nx 와 y 가 다를 때\n\n\nx &lt; y\nx 가 y 보다 작을 때\n\n\nx &lt;= y, x ≤ y\nx 가 y 보다 작거나 같을 때\n\n\nx &gt; y\nx 가 y 보다 클 때\n\n\nx &gt;= y , x ≥ y\nx 가 y 보다 크거나 같을 때\n\n\n\n\n≠ 는 \\ne+탭 키, ≤ 는 \\le+ 탭 키, ≥ 는 \\ge + 탭 키 를 통해 입력합니다.\n비교 연산을 1 &lt; 2 &lt;= 3 &lt; 5 != 10 &lt; 12 같이 이어서 쓸 수 있습니다. 모든 비교 항목이 true 일 때만 true 를 리턴합니다.\n\n특히 부동소수가 포함된 계산의 결과를 비교할때는 조심해야 합니다. Round-off 에러로 인해 생각하는 것과 실제가 다를 수 있습니다.\nIn [28]: 0 == 0.0\nOut[28]: true\n\nIn [29]: 4 == 4.0\nOut[29]: true\n\nIn [30]: 8.3-1.0 == 7.3\nOut[30]: false"
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html#함수",
    "href": "src/introduction_to_julia/03_functions_and_operators.html#함수",
    "title": "연산자와 함수",
    "section": "2 함수",
    "text": "2 함수\nJulia 에서의 함수는 많은 다른 언어들과 마찬가지로 함수명 뒤의 괄호 ( ) 안에 필요한 값들을 입력하여 함수를 실행시킵니다. 변수 a 에 대한 sin 함수값을 알고싶다면 sin(a) 로 입력합니다. 이 때 sin 이 함수 이름이며 함수에 입력되는 값 a 를 인자(argument) 라고 합니다. 인자는 값일수도 있고 문자열 혹은 다른 것일 수 있으며, 하나일 수도 있고 여러개일 수도 있습니다.\n\n수학 함수\nJulia 에서 제공 하는 함수 가운데 기본적인 함수를 소개합니다. 이 함수들의 정의와 사용법에 대해서는 관련 문서 를 참고하기 바랍니다.\n\n\n\n\n\n\n\n설명\n함수\n\n\n\n\n최대공약수, 최소공배수\ngcd, lcm\n\n\n절대값과 부호\nabs, abs2, sign, signbit, copysign, flipsign\n\n\n제곱근, 지수, 로그 관련\nsqrt, cbrt , hypot, exp, expm1, ldexp, log, log2, ,log10, exponent\n\n\n반올림, 올림, 내림 관련\nround, floor, ceil, trunc\n\n\n삼각함수\nsin, cos, tan, cot, sec, csc\n\n\n역 삼각함수\nasin, acos, atan, acot, asec, acsc\n\n\n쌍곡선 함수\nsinh, cosh, tanh, coth, sech, csch\n\n\n역 쌍곡선 함수\nasinh, acosh, atanh, acoth, asech, acsch\n\n\n기타\nsinc, cosc\n\n\n\n\n\n\n사용자 정의 함수\n예를 들어 두 값 x 와 y 를 입력 받아 두 값의 합을 반환하는 함수는 다음과 같이 정의합니다.\nfunction myadd(x, y)\n    return x+y\nend\n혹은 간단하게\nmyadd2(x, y) = x+y\n와 같이 정의할 수도 있습니다. 위의 myadd 와 myadd2 는 기능상 동일합니다.\n함수 정의는 function 으로 시작하여 함수 이름이 나오고 ( ) 안에 인자를 받는 변수와 그 정보를 나열합니다. 결과를 반환해야 할 경우 return 후에 반환해야 할 값이나 변수를 써 주고, end 로 끝납니다. return 이 나오면, 그 이후는 평가하지 않고 종료합니다.\nfunction myadd3(x)\n    return x+1\n    println(x+2)\nend\n에 대해 myadd3(3) 을 실행시키면 3+1=4 를 반환하고 종료하며 return 의 다음 명령인 println(x+2) 명령은 수행하지 않습니다.\n만약 함수 정의 안에 return 이 없다면 end 바로 앞의 표현식의 결과를 리턴합니다.\nfunction aa(a)\n    a+1\nend\n에 대해 b=aa(3) 을 수행하면 end 바로 앞의 a+1 을 리턴하므로 b==4 입니다. 만약 아무 것도 리턴하고 싶지 않다면 명시적으로 return nothing 이라고 해 주는 것이 좋습니다.\n\n\n\n익명함수 (람다함수)\n인자 -&gt; 반환하는 함수의 표현식 꼴로 선언되는 이름 없는 함수를 익명함수(anonymous function) 혹은람다 함수(lambda function) 이라고 합니다. 우선은 함수를 간단하게 정의하는 데도 사용합니다.\nIn [1]: sq = (x-&gt;x^2)\nOut[1]: #11 (generic function with 1 method)\n\nIn [2]: sq(3)\nOut[2]: 9\n\nIn [3]: sq(\"ab\")\nOut[3]: \"abab\"\nsq = (x-&gt;x^2) 를 봅시다. 오른쪽의 (x-&gt;x^2) 는 입력 x 에 대해 x^2 를 반환하는 익명 함수를 의미하며 sq = (x-&gt;x^2) 는 이 함수 객체를 sq 변수에 할당했습니다. 따라서 sq 는 함수이며 sq(3) 는 3^2 인 9 를 반환하고 sq(\"ab\") 는 \"ab\"^2==\"abab\" 를 반환합니다.\n익명 함수는 여려개의 인자를 가질 수도 있습니다.\nIn [4]: madd = (x, y) -&gt; x+y\nOut[4]: #13 (generic function with 1 method)\n\nIn [5]: madd(3, -2)\nOut[5]: 1\n익명함수를 위와 같이 사용하는 것은 다음과 같은 경우에 비해 이점이 없습니다.\nIn [10]: madd2(x,y) = x+y\nOut[10]: madd2 (generic function with 1 method)\n\nIn [11]: madd2(3, -2)\nOut[11]: 1\n익명함수가 실제로 널리 사용되는 부분은 map 함수에서의 익명함수의 사용 에서 볼 수 있듯이 map, reduce, 등에서 유용하게 사용됩니다. 또한 배열 comprehension 에서도 널리 사용됩니다.\n\n\n\n익명 함수 : do ... end, begin ... end\n람다 함수 이외에 익명함수를 정의하는 방법은 do ... end 블럭과 begin ... end 블럭이 있습니다. 이것은 do ... end, begin ... end 의 사용 에서 좀 더 다루도록 하겠습니다.\n\n\n\n선택적 인자\n인자를 입력하지 않아도 되는 인자를 선택적 인자(optional arguments) 라고 합니다.\n\n기본값이 있는 선택적 인자\n함수의 특정 인자에 대한 기본값을 정할 수 있으며 함수를 실행 할 때 이 인자에 값을 입력하지 않으면 기본값이 사용됩니다. 영어로는 Optional argument 라고 합니다. 예를 들어,\nmyadd3(x, y=1) = x+y\n와 같이 정의하면 y 를 입력하지 않았을 경우 즉 myadd(3) 으로 함수를 실행시켰을 경우 y=1 로 수행 됩니다. 즉 myadd(3)==4 입니다.\n\n\n\n기본값이 없는 선택적 인자\n실제로 코드상에서 기본값이 없는 선택적 인자는 없습니다. 일반적으로 기본값이 없는 선택적 인자는 인자의 값이 주어졌느냐 안주어졌느냐가 중요 할 때 사용합니다. 예를 들어 위의 myadd3 에서 myadd(2, 1) 과 myadd(2) 는 구별 할 수 없습니다. 인자가 선택되지 않았을 때 어떤 기능을 하고싶다면 어떻게 할까요? 특별히 인자가 특정 타입을 받는 경우라면? 이때는 보통 nothing 을 기본 인자로 놓습니다. 이 선택적 인자에 값을 입력한다면 정수여야 한다면 타입 유니온을 사용할 수 있습니다.\nfunction optional_arg(x, y::Union{Nothing, Integer} = nothing)\n    if y === nothing\n        return x^2\n    else\n        return x+y\n    end\nend\n이 경우 optional_arg(3) 은 y=nothing 으로 입력이 되기 때무문에 \\(9\\) 를 반환하지만 optional_arg(3, 4) 는 y=4 로 입력이 되므로 3+4 인 7 이 반환됩니다.\nIn [10]: function optional_arg(x, y::Union{Nothing, Integer} = nothing)\n             if y === nothing\n                 return x^2\n             else\n                 return x+y\n             end\n         end\nOut[10]: optional_arg (generic function with 2 methods)\n\nIn [11]: optional_arg(3)\nOut[11]: 9\n\nIn [12]: optional_arg(3, 4)\nOut[12]: 7\n\n\n\n\n키워드 인자\n인자에 특정한 키워드를 반드시 사용하도록 정할 수도 있습니다. 함수의 정의에서 ; 으로 구분하여 ; 앞에는 순서대로 정해진 인자가, ; 에는 키워드로 정해진 인자가 오도록 합니다.\nIn [1]: function myfunc(x, y; color=\"red\")\n            println(\"color = $color, x=$x, y=$y\")\n        end\nOut[1]: myfunc (generic function with 1 method)\n\nIn [2]: myfunc(1, color=2, 3)  # 키워드로 정해진 인자는 인자 입력의 순서를 무시한다.\ncolor = 2, x=1, y=3\n\nIn [3]: myfunc(1, 2)\ncolor = red, x=1, y=2\n함수 호출에서 키워드로 정해진 인자는 인자의 입력 순서를 무시하며, 키워드가 없는 인자끼리의 순서대로 인자가 입력된다는 것을 알 수 있습니다.\n\n\n인자와 반환값의 타입 지정\n함수를 정의 할 때 인자나 반환값의 타입을 :: 연산자를 통해 지정 할 수 있습니다. 예를 들어,\nfunction mfunc(x::Int64)::Int64\n    return x+1\nend\n는 인자 x 의 타입을 Int64 로 지정하였으며, x 에 Int64 타입이 아닌 인자가 할당될 경우 에러가 발생합니다. 리턴값의 타입을 지정하는 경우는 약간 다른데 julia 는 리턴 값을 지정된 타입으로 변환시키려고 하며, 변환될 경우는 변환된 값을, 변환되지 않을 경우는 에러를 출력합니다. 예를 들어,\nfunction mfunc2(x)::Int64\n    return x/2\nend\n에서 mfunc2(1) 은 1/2 가 정수로 변환되지 않으므로 에러를 출력하지만 myfunc(2.0) 은 2.0/2 가 정수로 변환되므로 변환된 Int64 타입의 값 1 을 리턴합니다.\nIn [1]: function myfunc2(x)::Int64\n        return x/2\n        end\nOut[1]: myfunc2 (generic function with 1 method)\n\nIn [2]: myfunc2(1)\nERROR: InexactError: Int64(0.5)\n...\n\nIn [3]: myfunc2(2.0)\nOut[3]: 1\n\n\n\n\n함수의 시그너쳐와 메서드\n함수 이름과 인자의 갯수, 각 인자의 타입의 정보를 함수의 시그너쳐(signature)라고 합니다. Julia 에서는 하나의 함수 이름으로 인자의 타입과 갯수에 따라 각각 다른 기능을 하게 할 수 있는데 이를 메서드(method)라고 합니다. 자세한 것은 메서드 다중 디스패치 에서 다루도록 하겠습니다."
  },
  {
    "objectID": "src/introduction_to_julia/04_I_splat_operator.html",
    "href": "src/introduction_to_julia/04_I_splat_operator.html",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "… 연산자 에서 튜플이나 배열의 첫번째 몇개만 취할 때 ... 연산자를 사용 할 수 있다는 것을 알아보았습니다. Julia 에서 ... 연산자는 두가지 용법으로 사용됩니다.\n\n\n\n튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")  \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6\n\n\n\n\n다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)\n\n\n\n\n함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/04_I_splat_operator.html#sec-splat_operator_for_containers",
    "href": "src/introduction_to_julia/04_I_splat_operator.html#sec-splat_operator_for_containers",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")  \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6"
  },
  {
    "objectID": "src/introduction_to_julia/04_I_splat_operator.html#sec-splat_operator_in_function_definition",
    "href": "src/introduction_to_julia/04_I_splat_operator.html#sec-splat_operator_in_function_definition",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)"
  },
  {
    "objectID": "src/introduction_to_julia/04_I_splat_operator.html#sec-splat_operator_in_function_argument",
    "href": "src/introduction_to_julia/04_I_splat_operator.html#sec-splat_operator_in_function_argument",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html",
    "href": "src/introduction_to_julia/04_containers.html",
    "title": "컨테이너",
    "section": "",
    "text": "여러 개의 데이터를 저장하고 처리하기 위한 데이터 타입을 컨테이너(container)이라고 하며, 대표적으로 배열(Array), 튜플(Tuple), 사전(Dict), StepRange 등이 있습니다. 컨테이너은 기본적으로 length 함수를 통해 포함되어 있는 아이템의 갯수를 알 수 있으며, iterator 이므로 포함되어 있는 아이템을 순회할 수 있습니다. 순서가 있는 컨테이너일 경우 순서대로 1, 2, … 의 인덱스를 가지며 포함하는 객체에 접근하여 값을 가져오거나 값을 변경할 때 정수 인덱스로 접근 할 수 있습니다. 순서가 중요하지 않은 컨테이너 일 경우 값마다 지정된 키(key) 인덱스를 통해 접근할 수 있습니다. 집합 타입의 컨테이너의 경우는 인덱스로도, 키로도 접근할 수 없습니다. 컨테이너에서 아이템을 더하거나 뺄 수 있다면 이 컨테이너이 mutable 하다고 하며, 한번 생성된 컨테이너을 변경 할 수 없다면 immutable 하다고 합니다."
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#sec-collections",
    "href": "src/introduction_to_julia/04_containers.html#sec-collections",
    "title": "컨테이너",
    "section": "1 대표적인 컨테이너들",
    "text": "1 대표적인 컨테이너들\nJulia 에서는 많은 종류의 컨테이너을 기본적으로 제공하며, 이 가운데 가장 많이 사용되는 것들의 특징을 정리하였습니다.\n\n\n표 1: 대표적인 컨테이너과 그 특징\n\n\n이름\n정수 인덱스로 접근\n키 인덱스로 접근\nmutable\n\n\n\n\n배열 (Array)\no\nx\no\n\n\n튜플 (Tuple)\no\nx\nx\n\n\n기명 튜플 (NamedTuple)\no\no\nx\n\n\n사전 (Dictionary)\nx\no\no\n\n\nStepRange (StepRange)\no\nx\nx\n\n\n집합 (Set)\nx\nx\no\n\n\n배열 (Array)\no\nx\no\n\n\n\n\n\n\n배열 (Array)\n배열은 정수 인덱스로 접근하는 같은 타입의 성분을 갖는 다차원 컨테이너으로 mutable 입니다. 수치 해석에서 기본이 되는 벡터, 행렬과 이미지 등은 대부분 배열로 처리되며, 너무나 중요하기 때문에 이후 배열 에서 자세히 다루고 여기서는 1차원 배열에 대해서만 간단히 다루도록 하겠습니다.\n\n\n\n1차원 배열 (Vector)\n1차원 배열은 Vector 라고 불리며 [ ] 안에 쉼표로 분리되어 나열된 아이템을 성분으로 갖는 컨테이너 입니다. 수를 비롯하여 모든 타입의 아이템을 포함할 수 있으며 삽입과 삭제가 자유로운 mutable 타입으로 정수 인덱스로 접근합니다. 다음과 같이 정의합니다.\nIn [4]: vec1 = [1, 2, \"a\", 3.4, \"bbc\"]\nOut[4]: 5-element Vector{Any}:\n 1\n 2\n  \"a\"\n 3.4\n  \"bbc\"\n이 때 vec1[1]=1 이며 vec1[5]=\"bbc\" 입니다. Vector 옆의 {Any} 는 벡터의 성분(벡터에 포함된 아이템을 성분(entry, element) 라고 합니다.) 의 타입입니다. 배열은 mutable 이므로 성분을 인덱스로 접근하여 변경 할 수 있습니다.\nIn [5]: vec1[2]=2.2; vec1\nOut[5]: 5-element Vector{Any}:\n 1\n 2.2\n  \"a\"\n 3.4\n  \"bbc\"\n\n\n\n\n\n\n\n명령문 끝의 ;\n\n\n\n위의 In [5] 에서와 같이 Julia REPL 에서 명령어 다음에 세미콜론 ; 을 붙이면 명령을 수행하지만 그 결과는 출력하지 않습니다. Jupyter 나 vscode 환경에서도 마찬가지 입니다.\n\n\n\n벡터에 성분을 마지막에 추가하고 싶으면 append!(vec1, item1, item2, .. ) 처럼 사용합니다. 그렇게 되면 vec1 에 item1, item2 가 차례대로 추가됩니다. 만약 item1, item2… 들이 컨테이너이라면 vec1 에 item1 를 순서대로 합칩니다.\n\n\n\n\n\n\n함수명 끝의 !\n\n\n\nJulia 에서는 함수명을 붙일 때 관례적으로 함수의 어떤 인자를 변경하는 함수라면 그 이름 끝에 ! 를 붙입니다. 다음부터 나올 push! 나 pop! 함수 이름에 ! 가 붙은것은 이 함수가 직접 vec1 을 변경하기 때문입니다. 직접 변경하지 않을 때는 ! 를 붙이지 않습니다.\n\n\n\n연습문제 1 append!(vec1, [2, 4], [\"k\", \"g\"]) 를 수행해 보세요.\n\n어떤 정해진 인덱스에 삽입하려면 insert!(vec1, index1, item1) 처럼 사용합니다. 그렇게 되면 vec1[index1] == item1 이 되며 원래 index1 에 위치했던 아이템과 그 뒤의 아이템들의 인덱스가 하나씩 늘어나게 됩니다. item 이 컨테이너이라도 append! 처럼 컨테이너의 아이템이 순서대로 삽입되지 않고 컨테이너 자체로 삽입됩니다. (타입이 지정된 벡터이면 에러가 발생합니다.)\nIn [6]: vec1 = [1, 2, \"a\", 3.4, \"bbc\"];\n\nIn [7]: insert!(vec1, 3, \"II\")\nOut[7]: 6-element Vector{Any}:\n 1\n 2\n  \"II\"\n  \"a\"\n 3.4\n  \"bbc\"\n특정 인덱스의 아이템을 삭제하고 싶으면 deleteat! 함수를 사용합니다. 만약 vec1[4] 인 “a” 를 삭제하고 싶으면 deleteat!(vec1, 4) 처럼 사용합니다.\nJulia 의 모든 타입은 Any 로부터 가지처럼 뻗어나가는 계층 구조를 가지고 있습니다. 여기에 대해서는 타입의 계층구조 에서 좀 더 자세히 알아 볼 것입니다. 벡터를 정의할 때 vec1 처럼 여러 타입을 가진 아이템을 포함한다면 julia 가 알아서 적절한 타입으로 변환합니다. 정수와 부동소수만으로 이루어진 배열은 자동적으로 부동소수로 변환됩니다. Any 는 모든 타입을 포함 할 수 있는 타입이므로 임의의 타입을 위한 배열의 타입으로 사용됩니다. 당분간은 배열은 특정한 타입만을 포함 할 수 있으며, 임의의 타입을 포함하고 싶을때는 Vector 다음에 {Any} 를 명시적으로 붙인다고 알고 있겠습니다.\n\n\n\n\n\n\nPromotion\n\n\n\n연산에서 같은 타입이 아닐 때 타입을 조정하는것을 promotion 이라고 합니다. 예를 들자면 2+3.0 이나 3.3 + π 을 계산하는 경우 둘의 타입이 다르기 때문에 julia 가 적절한 타입, 이 경우는 둘 다 부동소수로 타입으로 변환합니다.\n\n\nIn [1]: vec2=Vector{Any}([1,2,3]);\n\nIn [2]: ec3=Vector([1,2,3]);\nvec2 와 vec3 는 모두 세 정수로 이루어진 벡터이지만 vec2 는 Any 타입으로 지정되었습니다. 따라서 insert!(vec2, 2, \"A\") 는 동작하지만 insert!(vec3, 2, \"A\") 는 동작하지 않습니다.\npush! 와 pop! 은 벡터의 미지막에 어떤 아이템을 추가하거나, 마지막 아이템을 제거하는 명령입니다. push!(vec3, 5) 나 pop!(vec3) 처럼 사용합니다. pop! 의 경우 제거된 아이템을 반환합니다.\nIn [3]: push!(vec3, 5)\nOut[3]: 4-element Vector{Int64}:\n 1\n 2\n 3\n 5\n\nIn [4]: pop!(vec3)\nOut[4]: 5\n\nIn [5]: vec3\nOut[5]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\n연습문제 2 pushfirst!, popfirst!, empty! 함수를 알아보고 벡터를 변형시켜 봅시다.\n\n\n\n\nStepRange\n일정한 간격으로 나열되는 수를 위한 immutable 컨테이너입니다. 대표적으로 start:step:end 형식이나 start:end 형식으로 할당하며, 후자의 경우 start 와 end 의 타입으로부터 1 혹은 1.0 의 간격을 갖도록 만들어집니다.\n\nrange1 = start:step:end 형식으로 만들 경우 1 부터 시작하는 인덱스 i 에 대해 range1[i] == start + (i-1)*step 값을 가지며 당연히 end 값을 넘지 않습니다. 그리고 end 값을 포함 할 수 있습니다. 1:1:5 의 경우는 5번째 값은 5 입니다. \nend &gt; start 일 경우는 step 값이 0 보다 작아야 합니다.\n\npython 의 경우 range(1, 5) 나 numpy.arange(1, 5) 로 생성하는 배열은 5 를 포함하지 않습니다.\n연습문제 3 start &gt; end 일 때, step 값을 양수로 정의해 보거나, start &lt; end 일 때 step 값을 음수로 정의하고 인덱스를 통해 접근해 보기 바랍니다. 또한 start == end 일 때는 어떻게 되는지 확인해 보기 바랍니다.\n\nrange 함수를 통해서도 생성 할 수 있습니다. range(1, 10, step=1) 은 1:1:10 과 같습니다. 또한 range(start=0.0, stop=π, length=100) 은 0 부터 \\(\\pi\\) 까지 100 개의 길이를 가진 Range 만듭니다. 자세한 것은 julia 의 기본 문서에서 range 를 검색해 보기 바랍니다.\n많은 경우 StepRange 는 벡터처럼 동작하지만 immutable 이므로 수정 할 수 없습니다. 그리고 많은 경우 수학 함수에 적용되면 결과가 벡터로 변환됩니다.\nIn [6]: sin.(0.0:0.1:π)\nOut[6]: 32-element Vector{Float64}:\n 0.0\n 0.09983341664682815\n 0.19866933079506122\n 0.2955202066613396\n 0.3894183423086505\n 0.479425538604203\n 0.5646424733950355\n 0.6442176872376911\n ⋮\n 0.5984721441039564\n 0.5155013718214642\n 0.4273798802338298\n 0.33498815015590466\n 0.23924932921398198\n 0.1411200080598672\n 0.04158066243329049\n\n\n\n튜플 (Tuple)\n튜플은 벡터처럼 인덱스를 통해 포함하는 아이템에 접근 할 수 있지만 새로운 아이템을 추가할 수도 없고, 포함하는 아이템을 삭제할 수도 없습니다. 즉 immutable 입니다. 튜플은 tuple1 = (1, 3.3, 'A', cos, (2, \"a\", sin)) 과 같이 ( ) 안에서 , 로 구분하여 선언합니다. 여기서 A 는 Char 타입, “a” 는 String 타입이며, sin, cos 는 함수입니다. (Julia 에서 함수는 Function 타입입니다.) 튜플에서는 1 부터 시작되는 인덱스를 이용하여 포함된 아이템에 접근 할 수 있습니다. 앞서의 tuple1 의 경우, tuple1[1]==1 이며, typle1[3]=='A' 입니다. tuple[5]== (2, \"a\", sin) 이므로 tuple1[5][2]==\"a\" 입니다. tuple1[5][3]==sin 인 함수이므로 다음과 같은 결과를 얻을 수 있습니다.\nIn [1]: tuple1 = (1, 3.3, 'A', cos, (2, \"a\", sin))\nOut[1]: (1, 3.3, 'A', cos, (2, \"a\", sin))\n\nIn [2]: tuple1[5][3](π/2)\nOut[2]: 1.0\ntuple 은 immutable 한 컨테이너이므로 tuple1[2]=4.4 와 같은 방식으로 아이템을 변경 할 수 없으며, 성분을 추가하거나 삭제할 수도 없습니다.\n\n\n연습문제 4 임의의 튜플을 만든 후 인덱스를 통해 아이템을 변경해 보고 그 에러를 확인해 보세요.\n\n\n튜플이 벡터와 구별되는 것 가운데 하나는 포함되는 아이템의 타입을 일치시키려 하지 않는 점 입니다. 앞서 보았듯이 vec0 = [1, 2.0] 를 수행하면 맨 처음의 1 은 벡터가 되면서 2.0 의 타입을 고려하여 Float64 타입인 1.0 으로 변경됩니다. 이것은 vec0 = Vector{Any}([1, 2.0]) 를 해도 마찬가지 입니다. 그러나 튜플은 다릅니다.\nIn [1]: tup0 = (1, 2.0)\nOut[1]: (1, 2.0)\n와 같이 타입을 일치시키려 하지 않습니다.\n\n튜플이 가장 흔하게 사용되는 곳은 함수의 return 에서 입니다. 만약 함수가 아래와 같이 여러개의 값을 , 로 구분하여 반환한다면 이것은 이 값들을 순서대로 묶은 튜플을 반환하는 것입니다. 아래의 return3() 함수는 그냥 1, 2, 3 을 반환하는 함수인데, 리턴값은 이 값을 묶은 튜플입니다. 아래의 함수는 1, 2, 3 을 반환하는 함수입니다.\nfunction return3()\n    return 1, 2, 3\nend\n이 함수를 실행시키면 튜플 (1, 2, 3) 을 반환합니다.\nIn [3]: return3()\nOut[3]: (1, 2, 3)\n\n튜플을 사용하는 기법중의 하나가 두 변수의 값을 서로 바꿀 때 입니다. 예를 들어 다음 코드를 봅시다.\nIn [4]: a=1;b=2;a, b = b, a\nOut[4]: (2, 1)\n\nIn [5]: println(\"a=$a, b= $b\")\na=2, b= 1\n우선 a, b 에 각각 1 과 2 를 할당했습니다. 그 다음의 a, b = b, a 를 봅시다. 우선 등호의 오른쪽 b, a 를 수행하여 (b, a) 인 튜플을 만듭니다. 그리고 a, b=b, a 를 통해 a=(b, a)[1] 과 b=(b, a)[2] 를 수행합니다. 즉 (b, a) 인 새로운 튜플을 만들고 그 값을 순서대로 a, b 에 할당하는 것이기 때문에 결과적으로 두 변수의 값을 서로 교환하게 된 것입니다.\n\n\n\n기명 튜플 (NamedTuple)\n기명 튜플은 튜플과 유사하나 성분 하나마다 특별한 이름이 붙으며, 성분에 접근할 때 인덱스를 이용할 수도 있고, 그 이름을 이용할 수도 있습니다. 기명튜플도 immutable 이므로 값을 변경하거나, 성분을 추가하거나 삭제 할 수 없습니다.\nIn [6]: ntup1 = (b=1, a=2)\nOut[6]: (b = 1, a = 2)\n\nIn [7]: ntup1.a\nOut[7]: 2\n\nIn [8]: ntup1[1]\nOut[8]: 1\n\n\n\n사전 (Dictionary)\n사전은 키(key)-값(value) 를 묶어서 여러 타입을 저장하는 컨테이너으로 성분의 값을 변경 할 수 있는 mutable 타입입니다. 아래와 같이 Dict 를 통해 선언하며 [ ] 를 통해 접근하거나 값을 변경 할 수 있습니다. 기명 튜플과는 달리 인덱스로는 접근 할 수 없습니다. 사전은 아래에서 보듯이 명시적으로 키와 와 값의 타입을 알려주지 않았더라도, 그 타입이 정의되며 만들어집니다. 아래의 dict1 은 키인 \"a\", 와 \"b\" 가 모두 문자열이기 때문에 키는 문자열 타입으로, 값인 1 과 2 가 모두 Int64 타입이므로 값은 Int64 타입으로 정의되었습니다. 즉 dict1 을 만들었을 때의 출력 Dict{String, Int64} 는 키가 문자열(String) 타입이며 값이 64비트 정수(Int64) 타입으로 한정된 사전이라는 것을 의미합니다. 원래 사전은 mutable 타입이므로 새로운 키-값 을 추가 할 수 있지만, 이것은 처음 정의될 때의 사전의 키-값 타입이 허용하는 범위 안에 있을 때만 가능합니다.\nIn [10]: dict1=Dict(\"a\"=&gt;1, \"b\"=&gt;2) # 사전 선언\nOut[10]: Dict{String, Int64} with 2 entries:\n  \"b\" =&gt; 2\n  \"a\" =&gt; 1\n\nIn [11]: dict1[\"a\"] # 사전의 성분 접근\nOut[11]: 1\n\nIn [12]: dict1[\"a\"]=3 # 사전의 값 변경\nOut[12]: 3\n\nIn [13]: dict1\nOut[13]: Dict{String, Int64} with 2 entries:\n  \"b\" =&gt; 2\n  \"a\" =&gt; 3\n\nIn [14]: dict1[\"c\"]=-2 # 사전에 새로운 키-값 추가\nOut[14]: -2\n\nIn [15]: dict1\nOut[15]: Dict{String, Int64} with 3 entries:\n  \"c\" =&gt; -2\n  \"b\" =&gt; 2\n  \"a\" =&gt; 3\n\nIn [16]: dict1[\"d\"]=3.3 # 사전의 값의 타입 범위를 벗어나는 키-값 추가 시도는 실패한다.\nERROR: InexactError: Int64(3.3)\n...\nkeys(), values() 함수를 통해 사전의 key 와 value 를 얻을 수 있으며, haskey() 함수를 통해 해당 key 가 사전에 존재하는지 확인 할 수 있습니다.\nIn [17]: keys(dict1)\nOut[17]: KeySet for a Dict{String, Int64} with 3 entries. Keys:\n  \"c\"\n  \"b\"\n  \"a\"\n\nIn [18]: values(dict1)\nOut[18]: ValueIterator for a Dict{String, Int64} with 3 entries. Values:\n  -2\n  2\n  3\n\nIn [19]: haskey(dict1, \"a\")\nOut[19]: true\n\nIn [20]: haskey(dict1, \"c\")\nOut[20]: true\n사전에 key, value 를 추가할때는 dict1[\"f\"]=5 와 같이 합니다. 사전의 값을 호출할때는 dict1[\"a\"] 처럼 사용합니다.\n사전을 처음 선언 할 때 타입을 정할 수 있습니다. 또한 임의의 타입의 키-값을 갖는 사전도 정할 수 있습니다. 예를 들어 아래의 In [21] 과 같이 Dict{Any, Any} 로 시작하는 정의를 사용하면 모든 타입의 키와 값 을 가질 수 있습니다. Any 는 Int64 나 Rational 과 같은 타입 이름으로 모든 타입을 포함하는 최상위 타입입니다. 타입에 대해 자세한것은 타입 계층 구조 에서 알아볼 것입니다.\nIn [21]: dict3=Dict{Any, Any}(\"a\"=&gt;1)\nOut[21]: Dict{Any, Any} with 1 entry:\n  \"a\" =&gt; 1\n\nIn [22]: dict3[4]=\"abcd\"\nOut[22]: \"abcd\"\n\nIn [24]: dict3[\"sinfunction\"]=sin\nOut[24]: sin (generic function with 14 methods)\n\nIn [25]: dict3[\"sinfunction\"](π/2)\nOut[25]: 1.0\n이 때 dict3[4] 의 4 는 인덱스가 아닌 키 입니다. 정수 뿐 아니라, 부동소수나 복소수도 키가 될 수 있습니다. In [24] 는 사전의 값으로 함수가 오는 것을 보여줍니다. In [25] 에서 볼 수 있듯이 사전과 키를 이용하여 함수처럼 사용 할 수 있습니다.\n\n\n\n문자열 (String)\n앞서 타입에서 알아본 문자열(String) 도 개별적인 문자에 인덱스로 접근 할 수 있으며 length() 함수로 그 길이를 알 수 있다는 점에서 컨테이너입니다. 개별적인 문자에 인덱스로 접근 할 수 있지만 바꿀 수 없으므로 immutable 입니다.\n\n\n\n집합 (Set)\n집합은 아이템의 추가나 삭제는 가능하지만 인덱스로도, 키로도 접근 할 수 없는 mutable collection 입니다. 수학적인 집합과 동일하게 같은 값을 두 개 이상 가질 수 없습니다. 예를 들어 tuple1 = (1, 2, 3, 1) 은 1 값을 두개 가지고 있지만 set1 = Set([1, 2, 3, 1]) 은 1 이 중복되므로 아이템의 갯수는 3개 입니다. 아이템을 추가할때는 push! 함수를 사용하여 push!(set1, 5) 와 같이 하며, 아이템을 제거할때는 pop!(set1, 3) 처럼 사용합니다."
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#일반적인-컨테이너에-대한-연산",
    "href": "src/introduction_to_julia/04_containers.html#일반적인-컨테이너에-대한-연산",
    "title": "컨테이너",
    "section": "2 일반적인 컨테이너에 대한 연산",
    "text": "2 일반적인 컨테이너에 대한 연산\n\n∈, ∉\n우선 in 혹은 ∈ (\\in+[tab]) 은 어떤 아이템이 컨테이너에 속해있는지 여부를 true/false 로 반환합니다. 반대로 ∉(\\notin+[tab]) 은 아이템이 컨테이너에 포함되어 있지 않을 때 true 를 반환합니다. StepRange, 벡터, 집합에의 포함 여부는 다음과 같이 알 수 있습니다.\nIn [10]: 1 ∈ 1:10\nOut[10]: true\n\nIn [11]: \"a\" ∈ (2, \"5\", \"a\")\nOut[11]: true\n\nIn [12]: \"a\" ∉ (2, \"5\", \"a\")\nOut[12]: false\n\nJulia 는 키-값 쌍을 Pair 라는 객체로 처리합니다. 사전에 어떤 키가 포함되어있는지, 값이 포함되어 있는지는 keys, values 함수로 알 수 있습니다. 키-값 쌍이 있는지는 다음과 같이 확인 할 수 있습니다.\nIn [13]: Pair(\"a\", 1) ∈ Dict(\"a\"=&gt;1, \"b\"=&gt;2)\nOut[13]: true\n\n우리는 앞서 홑따옴표 ' ' 안에는 글자 하나만 포함 될 수 있으며 Char 타입이고 겹따옴표 \" \" 는 한줄 문자열, 세겹따옴표는 \"\"\" \"\"\" 여러줄 문자열을 포함한다는 것을 알았습니다. 따라서 ∈ 나 ∉ 연산자로 포함 여부를 확인할 때 연산자의 왼쪽에는 Char 형식의 한 글자에 대해서만 가능합니다. 즉\nIn [19]: 'a' ∈ \"abc\"\nOut[19]: true\n\nIn [20]: \"a\" ∈ \"abc\"\nERROR: use occursin(needle, haystack) for string containment\n...\n의 결과를 보입니다. “a” 는 하나의 성분을 갖는 컨테이너이므로 ∈ 나 ∉ 의 왼쪽에 올 수 없습니다.\n\n\n\nlength\nlength 함수는 컨테이너에 포함된 아이템의 갯수를 리턴합니다.\nIn [1]: length(Dict(\"a\"=&gt;1, \"b\"=&gt;2))\nOut[1]: 2\n\nIn [2]: length([1, 2, (3, 4, 5)])\nOut[2]: 3\n\n\n\neltype\neltype 은 컨테이너에 포함된 아이템의 타입을 반환합니다.\nIn [1]: eltype([1.0, 2.0, 3.0])\nOut[1]: Float64\n\nIn [2]: eltype(['a', 'b', 'c'])\nOut[2]: Char\n\n\n\nunique\n컨테이너에 포함된 아이템 가운데 중복되는 것을 제외한 아이템들을 벡터로 반환합니다.\njulia&gt; unique((1, 2, 3, 1, 2, 4))\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\n... 연산자\n... 연산자가 함수의 정의나 실행시에 사용되는 것에 대해서는 Interude : ‘…’ 연산자 에 대해 좀 더 자세히 다루었습니다.\n순서가 있는 컨테이너에서 앞부분의 몇개만 중요할 때 사용할 수 있습니다. 예를 들어\nIn [1]: a, b, c... = [4, 8, 15, 16, 23, 42]\nOut[1]: 6-element Vector{Int64}:\n  4\n  8\n 15\n 16\n 23\n 42\n\nIn [2]: a\nOut[2]: 4\n\nIn [3]: b\nOut[3]: 8\n\nIn [4]: c\nOut[4]: 4-element Vector{Int64}:\n 15\n 16\n 23\n 42\n입니다. 즉 1차원 배열 A 에 대해 첫번째 두개만 중요할 경우 a, b, c.. = arr1 와 같이 사용하면 a==A[1], b==A[2] 이며 c==A[3:end] 가 됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#주로-수로-이루어진-순서가-있는-컨테이너에서-이루어지는-연산",
    "href": "src/introduction_to_julia/04_containers.html#주로-수로-이루어진-순서가-있는-컨테이너에서-이루어지는-연산",
    "title": "컨테이너",
    "section": "3 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산",
    "text": "3 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산\n여기서는 벡터나 StepRange 같은 인덱스로 접근 가능한 컨테이너에 대해 성분이 모두 수로 이루어졌을 때 사용할 수 있는 연산에 대해 다루도록 하겠습니다. 많은 경우 수가 아닌 경우에도 사용 할 수 있지만 여기서는 수로 이루어진 컨테이너에 대해서만 논의하기로 합니다.\n\n\n. 연산 (도트 연산)\n벡터나 튜플, StepRange 같은 컨테이너의 아이템 마다 함수나 연산자를 적용시킬 때 도트 연산자 . 를 사용할 수 있습니다. 함수 이름의 끝에 . 를 붙이거나, 연산자의 앞에 . 를 붙입니다. 이를 도트 연산이라고 합니다.\n\n스칼라와 컨테이너의 연산에서는 컨테이너의 각 성분과 스칼라와의 연산 결과를 반환합니다.\n순서가 있는 컨테이너과 컨에티너의 연산에서는 컨테이너의 각 순서별 성분끼리 연산합니다.\n순서가 없는 컨테이너(예를 들어 집합(Set)) 에 도트연산을 수행 할 수 있지만 그 순서가 유지되지 않으며, 어쨋든 계산이 되면 그 결과는 벡터가 됩니다.\n\n아래의 코드를 봅시다.\n# 스칼라와 컨테이너의 도트 연산\nIn [13]: 3 .* (1, 2, 3)\nOut[13]: (3, 6, 9)\n\n# 순서가 있는 컨테이너의 도트 연산\nIn [14]: [1, 2, 3] .* [-1, 0, 1]\nOut[14]: 3-element Vector{Int64}:\n -1\n  0\n  3\n\n# 함수에서의 도트 연산. 함수 이름 끝에 . 를 붙이기만 하면 됩니다.\nIn [15]: sin.([-π/2, 0.0, π/2])\nOut[15]: 3-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n\n# 순서가 없는 컨테이너에 대한 도트 연산. 순서가 유지되지 않음.\nIn [16]: 3.0 .* Set([1, 2, 3])\nOut[16]: 3-element Vector{Float64}:\n 6.0\n 9.0\n 3.0\n\n함수나 연산자마다 . 을 붙여주는 것이 코드의 가독성을 해치거나 오류의 원인이 될 수 있습니다. 이때는 표현식 앞에 @. 를 붙여주면 julia 는 모든 연산자와 함수에 필요할 때 . 가 붙은 것처럼 작동하도록 합니다. @ 로 시작하는 명령문은 매크로라고 하며 특정한 기능을 하는 함수로 julia 의 핵심적인 기능중의 하나입니다. 자세한 것은 메타프로그래밍과 매크로 에서 다루겠습니다. 일단 다음 코드를 봅시다.\nIn [1]: @. 3+[1,2,3,4]\nOut[1]: 4-element Vector{Int64}:\n 4\n 5\n 6\n 7\n\nIn [2]: @. sin(0.0:0.1:π)\nOut[2]: 32-element Vector{Float64}:\n 0.0\n 0.09983341664682815\n 0.19866933079506122\n 0.2955202066613396\n 0.3894183423086505\n 0.479425538604203\n ⋮\n 0.4273798802338298\n 0.33498815015590466\n 0.23924932921398198\n 0.1411200080598672\n 0.04158066243329049\n\n\n\n\n\n\n도트연산자와 소숫점의 혼동\n\n\n\n3.*[1, 2, 3] 수행하면 (3 과 .* 사이에 공백이 없는 경우 입니다) 에러가 발생합니다. Julia 에서는 정수 다음에 . 이 붙을 경우 부동소수로 간주합니다. 예를 들어 julia 는 -1. 을 -1.0 으로 해석합니다. 따라서 3.*[1, 2, 3] 는 3.0 * [1, 2, 3] 로 해석 될 수도 있고 3 .* [1, 2, 3] 으로 해석 될 수도 있습니다. .* 와 같이 도트를 앞에 붙여서 사용하는 연산의 경우는 . 앞에 공백을 앞에 두는 습관을 들이는 것이 좋습니다.\n\n\n1차원 컨테이너 끼리의 도트 연산을 위해서는 컨테이너의 크기가 같아야 합니다. 다차원 배열의 경우는 배열 에서 다루겠습니다.\n\n많은 경우 StepRange 에 연산을 하면 Julia 가 판단을 해서 필요한 경우 벡터로 바꿔줍니다.\nIn [17]: 2*(1:10)\nOut[17]: 2:2:20\n\nIn [18]: (1:3).^2\nOut[18]: 3-element Vector{Int64}:\n 1\n 4\n 9\n\n\n\nminimum, maximum, extrema\n이 함수들은 컨테이너에 포함되는 값 가운데의 최소값(minimum), 최대값(maximum), 그리고 둘 다(extrema)를 반환합니다. 단 이때는 컨테이너의 모든 아이템들이 서로 비교 가능해야 합니다. 예를 들어 정수와 부동소수는 비교가능 하지만 수와 문자열은 서로 크기를 비교 할 수 없습니다. 따라서 수와 문자열을 같이 포함하는 컨테이너에서는 위의 함수들을 사용 할 수 없습니다.\nIn [23]: extrema(1:5)\nOut[23]: (1, 5)\n\nIn [24]: maximum([1, 2, \"ab\"])\nERROR: MethodError: no method matching isless(::String, ::Int64)\n...\n이 함수들은 어떤 컨테이너의 극값 뿐만 아니라 컨테이너에 함수를 적용했을 때의 최대값 최소값을 구하는 데도 사용 할 수 있습니다. 예를 들어,\nIn [25]: extrema(cos, 0:π/1000:π)\nOut[25]: (-1.0, 1.0)\n는 0:π/1000:π 에 대한 각각의 cos 값의 최소값과 최대값을 반환합니다.\n\n\n\nargmin, argmax, findmin, findmax\nargmin, argmax 는 각각 컨테이너에서 최소값과 최대값의 인덱스를 반환하며, 그 값이 여러개일 경우 첫번째 인덱스를 반환합니다. findmin, findmax 는 각각 최대값, 최소값에 대해 값과 인덱스를 튜플로 반환합니다.\nIn [29]: argmin([2, 3, 1, 2, 3, 1, 4, 1, 6])\nOut[29]: 3\n\nIn [30]: findmax([2, 3, 1, 2, 3, 1, 4, 1, 6])\nOut[30]: (6, 9)\n함수에 대한 결과값의 최대, 최소를 구할 수도 있습니다.\nIn [35]: findmax(cos, range(0.0, π, length=30))\nOut[35]: (1.0, 1)\n\n\n\n\n\n\nargmin, argmax 의 주의사항\n\n\n\nargmin, argmax 도 함수를 입력하면 에러가 나지 않지만 우리가 기대하는 행동을 하지 않습니다. 예를 들어\nIn [37]: argmin(cos, range(0.0, π, length=30))\nOut[37]: 3.141592653589793\n의 경우 range(0.0, π, length=30) 에 cos 함수를 적용시켰을 때 최소값이 나오는 인덱스(이경우30) 이 나오길 기대할 수 있지만 cos 함수를 최소화하는 range(0.0, π, length=30) 에서의 값을 반환합니다. argmax 도 같은 방식으로 동작합니다. 혼란을 줄 수 있으므로 왠만하면 argmin, argmax 는 사용하지 말고 findmin, findmax 를 사용하시기를 권합니다.\n\n\n\n\n\nmap\n함수 f 와 컨테이너 c 에 대해 map(f, c) 는 c 의 개별적인 성분에 f 를 적용한 값을 리턴합니다.\nIn [1]: map(abs, [1, -1, 2, -2, 3, -5])\nOut[1]: 6-element Vector{Int64}:\n 1\n 1\n 2\n 2\n 3\n 5\n\n인자가 여러개인 함수에 대해서는 여러개의 컨테이너를 인자로 입력합니다.\nIn [4]: f(x, y) = x+y\nOut[4]: f (generic function with 1 method)\n\nIn [5]: map(f, [1,2, 3], [3, 4,5])\nOut[5]: 3-element Vector{Int64}:\n 4\n 6\n 8\n\n인자로 주어지는 컨테이너의 갯수가 다를 때는 길이가 최소인 컨테이너에 맞추며 나머지 컨테이너의 성분은 무시합니다.\nIn [6]: map(f, [1,2, 3], [3, 4,5, 6, 7])\nOut[6]: 3-element Vector{Int64}:\n 4\n 6\n 8\n\n함수 뿐만 아니라 연산자가 올 수 도 있습니다.\nIn [8]: map(÷, [4, 7, 9], [2, 3, 5])\nOut[8]: 3-element Vector{Int64}:\n 2\n 2\n 1\n\n\n익명 함수의 사용\nmap 뿐만 아니라 바로 뒤에 나올 reduce, mapreduce, filter 에 익명 함수 가 아주 유용하게 사용될 수 있습니다. 예를 들어\nIn [3]: map(x-&gt;cos(x)+1, range(0, π, length=4))\nOut[3]: 4-element Vector{Float64}:\n 2.0\n 1.5\n 0.5000000000000002\n 0.0\n를 봅시다. range(0, π, length=4) 는 0 부터 π 까지 같은 간격을 가진 4개의 성분을 가진 배열을 만듭니다. 이 배열의 각각의 성분에 cos 함수를 취한후 1 을 더하는 익명함수 x-&gt;cos(x)+1 을 적용시킨 결과입니다.\n\n\n\ndo ... end, begin ... end 의 사용\ndo ... end 구문이나 begin ... end 구문 역시 일종의 익명 함수를 만드는 데 사용될 수 있습니다. 당연히 컨테이너에만 사용되는 것은 아니지만 컨테이에 대한 연산, 특히 map 이나 앞으로 나올 reduce, filter 등의 함수에 유용하게 사용 할 수 있습니다. 일단 In [3] 와 같은 결과를 내는 코드는 다음과 같습니다.\\(^\\ast\\) \\(^\\ast\\) 함수의 정의에서 return 문이 없다면 end 바로전의 표현식의 결과를 반환한다는 것을 알았습니다. 아래 코드에서도 마찬가지로 return cos(x)+1 대신에 cos(x)+1 만 있어도 실행됩니다.\nIn [4]: map(range(0, π, length=4)) do x\n        return cos(x)+1\n        end\n\nIn [5]: map( x-&gt; begin\n        return cos(x) +1\n        end\n        , range(0, π, length=4))\n우선 함수 f1 을 첫번째 인자로 받는 함수 mfunc(f1, b...) 에서 f1 의 정의를 mfunc(b...) do x 로 시작합니다. 이 때 x 는 f1 의 인자입니다. 그 이후 구문은 end 가 나올 때 까지 f1 을 정의하는 구문과 같습니다. do ... end 구문이나 begin ... end 구문에서는 변수를 선언하여 활용 할 수 있습니다.\nmap(0.0:0.1:π) do x\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\nend\n이 코드는 다음과 두 코드와 각각 같습니다.\nfunction f1(x)\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\nend\n\nmap(f1, 0.0:0.1:π)\nmap(x-&gt;begin\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\n    end, \n    0.0:0.1:π)\n\n\n\n\nreduce\nmap 이 컨테이너의 각 성분에 연산을 수행한다면, 그래서 결과는 입력된 컨테이너의 길이와 같은 벡터가 된다면 reduce 는 컨테이너에 대해 각각의 성분에 대해 연산을 수행하여 하나의 값을 얻는데 사용합니다. 예를 들어\nreduce(+, [1,2, 3, 4])\n를 봅시다. reduce 는 우선 첫번째와 두번째 성분으로 주어진 연산자나 함수에 대해 계산한 후 결과값을 세번째성분과 계산하고 이것을 마지막 성분까지 계속합니다. 즉 위의 코드는 (((1+2)+3)+4) 와 같습니다. 그렇다면\nreduce(-, [1,2, 3, 4])\n는 (((1-2)-3)-4) 과 같습니다.\n\n\n\nmapreduce\nmapreduc 는 map 과 reduce 를 합친 기능을 합니다. mapreduce(f, op, iter) 는 reduce(op, map(f, iter)) 와 같은 역할을 합니다. 예를 들어 다음 두 명령어는 기능적으로 같습니다. 1 에서 10 까지의 정수를 제곱한 배열을 만든 후 그 배열의 합을 구하는 것입니다.\nmapreduce(x-&gt;x^2, +, 1:10)\nreduce(+, map(x-&gt;x^2, 1:10))\n\n\nfilter\nfilter(f, c) 에서 f 는 true 혹은 false 를 반환하는 함수나 연산자이어야 합니다. 컨테이너의 성분에 함수를 적용했을 때 참인 성분만을 골라 반환합니다. 예를 들어,\nIn [1]: filter(x-&gt;(x&gt;3), [1,2,3,4,5])\nOut[1]: 2-element Vector{Int64}:\n 4\n 5\n를 봅시다. x-&gt;(x&gt;3) 은 익명함수로 x&gt;3 의 조건을 만족하면 true, 그렇지 않다면 false 를 리턴합니다. 따라서 이 조건을 만족하는 [4, 5] 만을 반환합니다.\n참고로 3보다 큰 성분을 배열로 리턴하는 것이 아니라 3보다 크면 1, 3보다 작으면 0 을 리턴하도록 하려면 어떻게 하면 될까요? 아래를 보고 왜 이렇게 작동하는지 생각해 보시기 바랍니다.\nIn [2]: [1, 2, 3, 4, 5] .&gt; 3\nOut[2]: 5-element BitVector:\n 0\n 0\n 0\n 1\n 1"
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html",
    "href": "src/introduction_to_julia/05_control_flows.html",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\n\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend"
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#for...end",
    "href": "src/introduction_to_julia/05_control_flows.html#for...end",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\n\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend"
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "title": "흐름 제어",
    "section": "2 while ... end",
    "text": "2 while ... end\nwhile 이후에 조건이 오고 그 조건이 참이면 end 까지 실행합니다. 1 부터 100 까지의 합을 구하는 코드를 while ... end 를 이용하여 구현해 봅시다.\nnsum = 0\nnn = 1\nwhile nn&lt;=100\n    nsum += nn\n    nn += 1\nend\nwhile ... end 를 쓸 때 조심할 것은 종료조건이 충족되지 않는 것입니다. for ... end 의 경우는 정해진 수의 컨테이너의 아이템만을 순회하므로 어쨌든 무조건 종료되지만 while ... end 의 경우는 종료되지 않는 무한루프에 빠질 수 있습니다.\n\n\n루프에서 벗어나기\n루프 수행 도중 벗어나고자 할 때는 break 를 씁니다. 예를 들어 1, 1/2, 1/3 과 같이 자연수의 역수를 계속 곱하다가 1/10000 보다 작아지는 첫번째 자연수를 구한다면, 1 부터 충분히 큰 수 (그 역수가 1/10000 보다 작은 수를 선택 할 수도 있다) 까지 루프를 수행하고 그 누적곱이 1/10000 보다 작을 때 break 로 루플에서 빠져나오면 됩니다.\nresult = 1.0\nfor n in 1:10000\n    result *=(1/n)\n    if result &lt; 1.0/10000\n        print(\"$n is the value\")\n        break\n    end\nend\nbreak 는 전체 루프에서 벗어나는 것이 아니라 break 를 포함하는 가장 인접한 루프로부터만 벗어납니다. 예를 들어,\nfor i in 1:10\n    for j in 1:10\n        println(\"i=$i, j=$j\")\n        if j &gt; 5\n            break\n        end\n    end\nend\n코드의 break 는 j&gt;5 일 때 break 되며, i 루프는 벗어나지 못하고 1 부터 10 까지 진행됩니다. 그러나,\nfor i in 1:10, j in 1:10\n    println(\"i=$i, j=$j\")\n    if j &gt; 5\n        break\n    end\nend\n는 i=1, j=6 에서 break 되어 멈춥니다."
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#if-...-elseif-...-else-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#if-...-elseif-...-else-...-end",
    "title": "흐름 제어",
    "section": "3 if ... elseif ... else ... end",
    "text": "3 if ... elseif ... else ... end\n어떤 수 x 에 대해 x&gt;0 이면 1 을 x&lt;0 이면 -1 을, x=0 이면 0 을 리턴하는 함수 msign(x) 를 만들어 봅시다.\nfunction msign(x)\n    if x&gt;zero(x)\n        return one(x)\n    elseif x&lt;zero(x) \n        return -one(x)\n    else\n        return zero(x)\n    end\nend\nzero(x) 는 x 의 타입에서의 0 값을 리턴하는 함수이며, one(x) 는 x 타입의 1 값을 리턴하는 함수입니다. x 는 어떤 값일 수도 있고 타입일 수도 있습니다. zero(1) 은 Int64 타입의 1 이며, one(Float32) 는 Float32 타입의 0.0 입니다. for, while 과 같이 if 블럭도 end 로 끝내야 합니다.\nif 블록에서 elseif 나 else 는 필요 없다면 생략해도 됩니다. 예를 들어 1 부터 100 까지의 정수 가운데 3의 배수만을 더한 합을 구한다고 하면,\nresult = 0\nfor i in 1:100\n    if i % 3 == 0\n        result += i\n    end\nend\n와 같이 사용 할 수 있습니다. i % 3 == 0 일 때만 result += i 를 수행하고 다른 경우는 아무 일도 수행하지 않습니다."
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "href": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "title": "흐름 제어",
    "section": "4 삼항 연산자 a ? b : c",
    "text": "4 삼항 연산자 a ? b : c\na 는 true/false 를 따질 수 있는 조건이며, true 이면 b 를 실행시키고 false 이면 c 를 실행 시킵니다. 예를 들어, 절대값을 리턴하는 함수 mabs() 를 다음과 같이 짧게 구현 할 수 있습니다.\nmabs(x) = (x&gt;0) ? x : -x\n여기서 주의해야 할 것은 ? 와 : 각각의 앞, 뒤에 공백이 존재해야 한다는 것입니다. (x&gt;0)? x : -x 나 (x&gt;0)? x: -x 같은 것들은 에러를 발생시킵니다."
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "href": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "title": "흐름 제어",
    "section": "5 begin ... end 블럭",
    "text": "5 begin ... end 블럭\nJulia 에서 한줄에 여러 명령을 처리하기 위해 ; 을 사용 할 수 있습니다. 예를 들어\nx=3;y=5;z=x+y\n는 세가지 명렁을 차례로 입력한 것과 같습니다. 이것을 begin ... end 블럭으로 묶을 수 있습니다.\nz = begin\n    x=3\n    y=5\n    x+y\nend"
  },
  {
    "objectID": "src/introduction_to_julia/06_I_function_composition_and_piping.html",
    "href": "src/introduction_to_julia/06_I_function_composition_and_piping.html",
    "title": "Interude : 함수의 합성과 전달",
    "section": "",
    "text": "함수의 합성은 ∘ 연산자를 이용하며 \\circ + [탭키] 로 입력합니다. 예를 들어\nIn [1]: (sqrt ∘ +)(9, 16)\nOut[1]: 5.0\n를 봅시다. 두개의 인자 9 와 16 을 더한 후 제곱근을 반환하며, 이것은 보통의 수학적인 합성함수의 정의와 일치합니다. 한 함수의 반환값을 다른 함수의 입력값으로 사용 할 때 함수의 합성을 사용하며, 함수의 합성은 다수의 함수에 대해서도 가능합니다.\nIn [2]: (sin ∘ sqrt ∘ -)(π, π/4)\nOut[2]: 0.9993590241845508\n\n합성연산자는 컨테이너에 대한 도트 연산을 수행할 수 없습니다. 합성연산자와 비슷한 기능을 하며 도트 연산도 수행할 수 있는 것이 전달연산자 |&gt; 입니다.\n\n\n\n\n|&gt; 는 기본적으로 합수의 합성과 같습니다. In [1] 과 In [2] 를 |&gt; 을 사용한 표현으로 바꾸면 다음과 같습니다.\nIn [3]: +(9, 16) |&gt; sqrt\nOut[3]: 5.0\n\nIn [4]: -(π, π/4) |&gt; sqrt |&gt; sin\nOut[4]: 0.9993590241845508\n|&gt; 의 오른쪽의 연산 결과를 |&gt; 왼쪽 함수에 대한 입력으로 사용합니다. In [4] 에서와 같이 |&gt; 연산자를 이어서 사용 할 수도 있습니다.\n앞서 말한 것처럼 .|&gt; 와 같은 도트 연산도 가능합니다.\nIn [6]: 0:0.01:π .|&gt; cos |&gt; maximum\nOut[6]: 1.0\n익명 함수를 사용할 수도 있습니다.\nIn [2]: -π:0.001:π .|&gt; (x-&gt;x^2 * cos(x)) |&gt; maximum\nOut[2]: 0.5497738913075754\n여기서 가운데의 (x-&gt;x^2 * cos(x)) 에서 가장 바깥의 괄호를 표기하지 않으면 julia 는 연산자의 우선순위 상 -π:0.001:π .|&gt; x-&gt; (x^2 * cos(x)) |&gt; maximum) 로 해석을 하기 때문에 다른 결과가 나옵니다."
  },
  {
    "objectID": "src/introduction_to_julia/06_I_function_composition_and_piping.html#합성연산자",
    "href": "src/introduction_to_julia/06_I_function_composition_and_piping.html#합성연산자",
    "title": "Interude : 함수의 합성과 전달",
    "section": "",
    "text": "함수의 합성은 ∘ 연산자를 이용하며 \\circ + [탭키] 로 입력합니다. 예를 들어\nIn [1]: (sqrt ∘ +)(9, 16)\nOut[1]: 5.0\n를 봅시다. 두개의 인자 9 와 16 을 더한 후 제곱근을 반환하며, 이것은 보통의 수학적인 합성함수의 정의와 일치합니다. 한 함수의 반환값을 다른 함수의 입력값으로 사용 할 때 함수의 합성을 사용하며, 함수의 합성은 다수의 함수에 대해서도 가능합니다.\nIn [2]: (sin ∘ sqrt ∘ -)(π, π/4)\nOut[2]: 0.9993590241845508\n\n합성연산자는 컨테이너에 대한 도트 연산을 수행할 수 없습니다. 합성연산자와 비슷한 기능을 하며 도트 연산도 수행할 수 있는 것이 전달연산자 |&gt; 입니다."
  },
  {
    "objectID": "src/introduction_to_julia/06_I_function_composition_and_piping.html#전달-연산자",
    "href": "src/introduction_to_julia/06_I_function_composition_and_piping.html#전달-연산자",
    "title": "Interude : 함수의 합성과 전달",
    "section": "",
    "text": "|&gt; 는 기본적으로 합수의 합성과 같습니다. In [1] 과 In [2] 를 |&gt; 을 사용한 표현으로 바꾸면 다음과 같습니다.\nIn [3]: +(9, 16) |&gt; sqrt\nOut[3]: 5.0\n\nIn [4]: -(π, π/4) |&gt; sqrt |&gt; sin\nOut[4]: 0.9993590241845508\n|&gt; 의 오른쪽의 연산 결과를 |&gt; 왼쪽 함수에 대한 입력으로 사용합니다. In [4] 에서와 같이 |&gt; 연산자를 이어서 사용 할 수도 있습니다.\n앞서 말한 것처럼 .|&gt; 와 같은 도트 연산도 가능합니다.\nIn [6]: 0:0.01:π .|&gt; cos |&gt; maximum\nOut[6]: 1.0\n익명 함수를 사용할 수도 있습니다.\nIn [2]: -π:0.001:π .|&gt; (x-&gt;x^2 * cos(x)) |&gt; maximum\nOut[2]: 0.5497738913075754\n여기서 가운데의 (x-&gt;x^2 * cos(x)) 에서 가장 바깥의 괄호를 표기하지 않으면 julia 는 연산자의 우선순위 상 -π:0.001:π .|&gt; x-&gt; (x^2 * cos(x)) |&gt; maximum) 로 해석을 하기 때문에 다른 결과가 나옵니다."
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html",
    "href": "src/introduction_to_julia/06_arrays.html",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별칭을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n위에서 보였는데, 배열의 차원은 ndims() 함수로 알 수 있습니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다."
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별칭을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n위에서 보였는데, 배열의 차원은 ndims() 함수로 알 수 있습니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다."
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "title": "배열",
    "section": "2 배열의 생성",
    "text": "2 배열의 생성\n앞에서와 같이 각각 배열의 성분을 입력 할 수도 있겠지만, 배열이 클 경우는 거의 불가능한 방법입니다. Julia 는 배열을 생성하고 초기화 할 수 있는 다양한 방법을 제공합니다.\n\n\nArray comprehension 을 이용한 배열의 생성\n[ ] 안에 루프를 사용하여 배열을 만들 수 있습니다. 1 부터 10 까지의 정수의 제곱을 순서대로 포함하는 배열은 아래와 같이 만들 수 있다.\nac1 = [x^2 for x in 1:10]\n다차원 배열도 다음과 같이 만들 수 있습니다.\nIn [6]: [x+y for x = 1:3, y = 1:2]\nOut[6]: 3×2 Matrix{Int64}:\n 2  3\n 3  4\n 4  5\n[ ] 안에 조건을 넣을 수도 있습니다. 예를 들어 앞의 2차원 배열에서 x+y&gt;3 인 경우에는 0 으로 채우고 싶다면,\nIn [7]: [if x+y &gt; 3 0 else x+y end for x = 1:3, y = 1:2]\nOut[7]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n와 같이 쓸 수 있습니다. 3항 연산자를 사용하여 다음과 같이 쓸 수도 있습니다.\nIn [8]: [(x+y &gt; 3) ? 0 : x+y  for x = 1:3, y = 1:2]\nOut[8]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n그런데 if 문이 뒤에 가면 전혀 다른 결과가 발생합니다.\nIn [9]: [x for x in 1:10 if x&gt;4]\nOut[9]: 6-element Vector{Int64}:\n  5\n  6\n  7\n  8\n  9\n 10\n\nIn [10]: [x+y for x = 1:3, y = 1:2 if x+y&gt;3]\nOut[10]: 3-element Vector{Int64}:\n 4\n 4\n 5\nIn[7] 과 같이 for 가 if 뒤에 있으면, 중첩된 for 의 갯수에 따라 다차원 배열을 만든 후 연산을 수행합니다. 반대로 In[9] 나 In [10] 과 같이 if 가 for 의 뒤에 있다면 1차원 배열에 대해 if 문이 일종의 filter 함수 역할을 수행하며 이 filter 에 대해 true 인 경우 1차원 배열에 삽입합니다.\n\n\n\n특정 값으로만 이루어진 배열의 생성\nzeros(), ones(), fill() 함수가 대표적으로 배열을 초기화 하는 함수입니다. zeros(T, dims) 는 T 의 타입에서의 0 값(zero(T))으로 채워진 dims 차원의 배열을 반환합니다. ones(T, dims) 은 one(T) 로 채워진 배열의 형상이dims 인 배열을 반환하며 fill(v, dims) 는 값 v 로 채워진 dims 형상의 배열을 반환합니다. T 가 주어지지 않을 경우는 Float64 타입으로 정해지며 dims 는 1차원 배열의 경우는 정수, 다차원 배열의 경우는 튜플, 혹은 연속적인 정수입니다.\nIn [1]: zeros(Float32, (2, 3))\nOut[1]: 2×3 Matrix{Float32}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [2]: ones(UInt8, (2,2,2)) # == ones(UInt8, 2,2,2)\nOut[2]: 2×2×2 Array{UInt8, 3}:\n[:, :, 1] =\n 0x01  0x01\n 0x01  0x01\n\n[:, :, 2] =\n 0x01  0x01\n 0x01  0x01\n\nIn [3]: fill(2.0, 1, 3)  # == fill(2.0, (1, 3))\nOut[3]: 1×3 Matrix{Float64}:\n 2.0  2.0  2.0\n\nundef 키워드를 사용하여 타입과 크기만을 지정하고 값을 정하지 않고 초기화 할 수도 있습니다.\nA1 = Vector{Int8}(undef, 4) # 1차원 배열 초기화\nA2 = Matrix{Float64}(undef,10,10) # 2차원 배열 초기화\nA3 = Array{Float32}(undef, 2, 2, 2) #3차원 배열 초기화\n이 경우 배열의 성분은 임의의 값이 정해집니다. 이렇게 임의의 값이 채워진 배열을 초기화 하는 이유는 이렇게 배열을 만드는 것이 특정 값으로 채워서 초기화 하는 것보다 훨씬 빠르기 때문입니다. 만약 배열의 모든 성분이 이후의 계산과정에서 채워진다면 굳이 특정 값으로 초기화 시키지 않고 undef 를 사용하여 배열을 만들 수 있습니다.\n\n\n\n이미 존재하는 배열과 같은 크기의 배열 생성\n배열의 타입과 크기를 지정하지 않고 이미 존재하는 배열을 이용하여 초기화 할 수 있습니다. 예를 들어 어떤 배열 A 와 같은 크기와 타입을 갖지만 모든 성분이 0 인 배열을 만들 때 zero(A) 를 사용 할 수 있습니다. (zeros(A) 가 아닙니다) A 가 정사각 행렬일 경우 one(A) 는 A 와 같은 크기와 타입을 갖는 항등행렬을 리턴합니다.\nIn [1]: A=[1.0 -2.0 3.0;4.0 -3.0 -1.0]\nOut[1]: 2×3 Matrix{Float64}:\n 1.0  -2.0   3.0\n 4.0  -3.0  -1.0\n\nIn [2]: zero(A)\nOut[2]: 2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [3]: B=[1 2;3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [4]: one(B)\nOut[4]: 2×2 Matrix{Int64}:\n 1  0\n 0  1\n\n\n\n배열을 확장하여 생성\n2차원 배열을 생성할 때 [1 3;2 4] 와 같이 열 구별은 공백을, 행 구별은 ; 을 이용하여 생성하는 방법을 이미 알아 보았습니다. 이 방법은 스칼라 뿐만 아니라 배열을 사용 할 수도 있는데 예를 들면\nIn [1]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[1]: 1-element Vector{Int64}:\n 9\n\nIn [2]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[2]: 1-element Vector{Int64}:\n 9\n\nIn [3]: F1=[A B]\nOut[3]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n\nIn [4]: F2=[A;C]\nOut[4]: 3×2 Matrix{Int64}:\n 1  2\n 3  4\n 7  8\n\nIn [5]: F3=[A B;C D]\nOut[5]: 3×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n 7  8  9\n와 같습니다. 즉 부분 행렬을 모아 더 큰 행렬을 만들 때 행 방향으로의 확장은 공백으로, 열 방향으로의 확장은 ; 를 이용합니다. 이렇게 작은 배열을 모아 큰 배열을 만드는 것을 concatenation 이라고 합니다. Concatenation 을 이용할 때는 각 부분행렬의 행과 열의 갯수가 서로 잘 맞도록 해줘야 합니다. [A B; C D] 형태로 concatenation 을 할 때는 A 와 B 의 행의 갯수가 같아야 하며 A 와 C 의 열의 갯수가 같아야 하고 B 의 열의 갯수와 D 의 열의 갯수도 같아야 하며 C 와 D 의 행의 갯수가 같아야 합니다. 복잡하게 설명했지만 결국 크기가 다른 타일을 빈 틈 없이 맞추는 경우로 생각할 수 있겠습니다.\nConcatenation 을 해 주는 함수로는 cat, vcat, hcat, hvcat, hvncat 이 있습니다.\nIn [1]: A=[1 2;3 4];B=[5 6;7 8];C=[-1 -2; -3 -4];\n\nIn [2]: vcat(A, B)\nOut[2]: 4×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n 7  8\n\nIn [3]: hcat(A, B, C)\nOut[3]: 2×6 Matrix{Int64}:\n 1  2  5  6  -1  -2\n 3  4  7  8  -3  -4\n\nIn [4]: hvcat((2, 3), [1 2;3 4], [-1;-2], [5; 6], [7;8], [9;10])\nOut[4]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [5]: [[1 2;3 4] [-1;-2] ; [5; 6] [7;8] [9;10]]\nOut[5]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [6]: hvcat(2, [1 2;3 4], [5;6])\nOut[6]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\nvcat(A, B) 는 [A; B] 와 같으며 hcat(A, B) 는 [A B] 와 같습니다. 즉 vcat 은 배열을 수직으로 위에서 아래로 쌓으며, hcat 은 왼쪽에서 오른쪽으로 쌓습니다. vcat 이나 hcat 의 인자로는 다수의 배열 혹은 숫자가 올 수 있습니다. hvcat 은 인자로서 처음에 정수 혹은 정수의 터플이 오며, 그 다음부터 다수의 배열이 위치합니다. In [4] 의 hcat 함수의 첫번째 인자 (2, 3) 는 첫번째 블록열은 2개의 행렬로, 두번째 블록열은 그 다음 세개의 행렬로 이루어진다는 것을 의미합니다. 즉 [1 2;3 4], [-1;-2] 가 첫번째 열을 이루고, [5; 6], [7;8], [9;10] 가 두번째 열을 이룹니다. 따라서 In [5] 와 같습니다. hvcat 의 첫번째 인자로 정수만 있을 때는 첫번째 블록열로만 이루어집니다.\ncat 함수는 좀 많이 복잡합니다. 우리는 여기서는 1차원과 2차원 배열에 대해서만 다루겠습니다. 우선 cat 함수의 시그너쳐는 다음과 같습니다.\ncat(A...; dims)\ndims 는 자연수, 혹은 자연수의 터플이 올 수 있습니다. Julia 1.8 부터는 Val{x} 타입도 가능하지만 여기서는 다루지 않겠습니다. 자연수가 올 때는 그 차원 방향으로 확장합니다.\nIn [1]: cat(1, [2;3], dims=1)\nOut[1]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [2]: cat([1;2], [3;4], dims=2)\nOut[2]: 2×2 Matrix{Int64}:\n 1  3\n 2  4\ndims 에 자연수의 컨테이너가 올 때는 마치 블록 대각 행렬을 만드는 것 처럼 확장됩니다. 다음을 봅시다.\nIn [3]: cat(1, [2;3], [4 5; 6 7], dims=(1, 2))\nOut[3]: 5×4 Matrix{Int64}:\n 1  0  0  0\n 0  2  0  0\n 0  3  0  0\n 0  0  4  5\n 0  0  6  7\ndims=(1, 2) 이므로 첫번째 차원(수직) 과 두번째 차원 (수평) 으로 확장되며 주어진 배열 (스칼라는 0차원 배열로 간주됩니다) 대각으로 놓게 됩니다.\n\n\n\n주어진 배열과 같은 크기와 타입의 값이 정해지지 않은 배열을 생성 : similar\n값을 지정하지 않고 주어진 배열과 같은 타입과 크기의 배열을 생성하는 함수로 similar() 가 있습니다. similar() 를 사용하는 이유도 속도 때문이며, undef 키워드로 배열을 만드는 것과 같이, 이후 연산으로 그 값이 다 채워진다면 충분히 사용할 만 합니다.\nIn [8]: C=[1.0 3.0;2.0 -1.0]\nOut[8]: 2×2 Matrix{Float64}:\n 1.0   3.0\n 2.0  -1.0\n\nIn [9]: similar(C)\nOut[9]: 2×2 Matrix{Float64}:\n 0.0           2.39288e-314\n 2.39288e-314  0.0"
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "title": "배열",
    "section": "3 배열의 인덱스",
    "text": "3 배열의 인덱스\n프로그래밍 언어에서 배열을 다룰 때 첫번째 인덱스가 0 인 언어가 있으며(C/C++, Java, Python, Javascript 등), 1 인 언어(Fortran, Matlab, R 등) 가 있습니다. Julia는 1부터 시작합니다. end 는 각 차원의 마지막 인덱스를 의미하는 키워드입니다. 물론 배열의 차원과 형태를 알고 있다면 인덱스를 직접 써도 됩니다.\nIn [1]: A = [1 4 7 10;2 5 8 11;3 6 9 12] \nOut[1]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [2]: A[1, 1] # a의 1 행 1열\nOut[2]: 1\n\nIn [3]: A[2, end] # a의 2 행 마지막 열\nOut[3]: 11\n\nIn [4]: A[end, end] # a 의 마지막 행 마지막 열\nOut[4]: 12\n\n\n인덱스를 이용한 배열 연산\n인덱스의 범위를 지정할 수도 있습니다. 전체 볌위는 : 로 표기하며, 벡터나 튜플, StepRange 를 사용하여 선택적으로 지정할 수도 있습니다.\nIn [5]: A[:, 1]   # 전체 행, 1 열\nOut[5]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [6]: A[2, 1:2:end]  # 2행 의 1열부터 끝열까지 2열 간격으로\nOut[6]: 2-element Vector{Int64}:\n 2\n 8\n\nIn [7]: A[3, [2, 3]] # 3행 의 2열과 3열\nOut[7]: 2-element Vector{Int64}:\n 6\n 9\n\nB=A[:, 1] 라고 하면 B 는 A 의 1 행과 같은 값을 갖는 벡터이며 A 의 1행이 아닙니다. 즉 B=A[:, 1] 을 수행하고 B 벡터의 성분을 바꾼다고 해도 A 가 변하지 않습니다. 이에 대해서는 배열의 복사 와 view 와 @view 를 참고하시기 바랍니다.\nIn [9]: B=A[:, 1]\nOut[9]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [10]: B[2]=-3\nOut[10]: -3\n\nIn [11]: A\nOut[11]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [12]: B\nOut[12]: 3-element Vector{Int64}:\n  1\n -3\n  3\n\n\n\n행렬의 열/행 우선 방식\n예를 들어 \\(\\boldsymbol{A} =\\begin{bmatrix} 1&2\\\\3&4\\end{bmatrix}\\) 를 메모리상에 저장할 때 1행 1열, 1행 2열,… 1행 마지막열, 2행 1열, … 순으로 저장하는 것을 행 우선 순서(row-major order) 라고 하고 1행 1열 2행 1열, 마지막행 1열, 2행 1열, 2행 2열,… 순으로 저장하는 것을 열 우선 방식(column-major order)이라고 합니다. 행 우선 방식에서는 배열 A 가 1 2 3 4 의 순으로 저장이 되며 열 우선방식에서는 1 3 2 4 순으로 저장이 됩니다. 행 우선 방식을 쓰는 언어로는 C/C++ 과 Python 의 numpy 가 있고 열 우선 방식을 쓰는 언어로는 Fortran, MATLAB, Julia, R 등이 있습니다. 또한 언어에서 사용하는 자료구조나 함수에 따라 달라질 수 있습니다.\n\n\n\n\n\n\n경고\n\n\n\n이것이 문제가 될 수 있는 경우는 우선순위가 다른 언어나 라이브러리간에 데이터를 교환 할 때 입니다. 예를 들어 julia 의 배열을 파일로 저장 한 후 python 의 numpy 로 읽으면 행과 열이 바뀔 수 있습니다.\n\n\n\n\n\n데카르트 인덱스와 선형 인덱스\n지금까지 2차원 배열A 의 2행 3열 성분을 A[2, 3] 으로 접근했습니다. 이와 같이 배열의 차원의 갯수만큼의 자연수로 접근하는 것을 데카르트 인덱스(Cartesian index) 혹은 카르테시안 인덱스 라고 합니다. 다른 접근 방법도 있는데, 다차원 배열의 각 성분을 1부터 하나의 자연수로 접근하는 방법도 사용합니다. 이것을 선형 인덱스(linear index) 라고 합니다. 앞서 알아본 열 우선 방식에서 배열을 나열할 때의 차례입니다. 예를 들어 A=[1 3;2 4] 의 경우 A[3]=3 이며 A[4]=4 입니다.프랑스의 철학자이자 과학자인 르네 데카르트(René Descartes) 의 이름에서 따왔습니다. 데카르트의 라틴어명이 Renatus Cartesius 이기 때문에 영어로는 Cartesian index 라고 씁니다.\nIn [13]: A=[1 2;3 4]\nOut[13]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [14]: A[3]\nOut[14]: 2\n데카르트 인덱스로부터 선형 인덱스를, 선형 인덱스로부터 데카르트 인덱스르 얻는 방법이 존재합니다. 배열 A 에 대해 CartesianIndices(A)[10] 은 배열 A 의 선형 인덱스 10 에 대한 데카르트 인덱스를 리턴합니다. A 가 삼차원 배열일 경우 LinearIndices(A)[1, 2, 3] 은 배열 A 의 데카르트 인덱스(1, 2, 3) 에 대한 선형 인덱스를 리턴합니다. 고차원 배열에대해서도 차원의 갯수만큼의 데카르트 인덱스를 받아 선형 인덱스를 리턴합니다.\nIn [1]: A=Array(reshape(1:2*3*4, (2, 3, 4)))\nOut[1]: 2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\n[:, :, 3] =\n 13  15  17\n 14  16  18\n\n[:, :, 4] =\n 19  21  23\n 20  22  24\n\nIn [2]: CartesianIndices(A)[10]\nOut[2]: CartesianIndex(2, 2, 2)\n\nIn [3]: LinearIndices(A)[1, 2, 3]\nOut[3]: 15"
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "title": "배열",
    "section": "4 배열의 복사",
    "text": "4 배열의 복사\n배열을 복사할 때는 copy() 혹은 deepcopy() 명령어를 사용합니다. 주의해야 할 것은 배열 A 에 대해 B=A 와 B=copy(A) 는 다르다는 것입니다. 아래 코드를 봅시다.\nIn [13]: A=[1 2]\nOut[13]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [14]: B=A;C=copy(A)\nOut[14]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [15]: B[1, 1]=3\nOut[15]: 3\n\nIn [16]: A\nOut[16]: 1×2 Matrix{Int64}:\n 3  2\n\nIn [17]: C\nOut[17]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [18]: C[1, 2]=-1\nOut[18]: -1\n\nIn [19]: A\nOut[19]: 1×2 Matrix{Int64}:\n 3  2\nB=A 라는 표현식은 B 와 A 변수가 같은 행렬에 대한 변수라는 뜻입니다. 따라서 B 라는 변수를 이용해 행렬 값을 변화시키면 A 변수로 접근하더더라도 변화된 행렬에 접근하게 됩니다. B=copy(A) 는 A 복사본을 만들어 B 라는 변수에 지정합니다. 따라서 B 변수를 이용해 행렬을 바꾸더라도 A 변수에 지정된 행렬은 변화하지 않습니다. B=A[:] 는 B=A 가 아닌 copy(A) 를 의미합니다.\n객체를 카피하는 명령어에는 deepcopy 가 있습니다. 다음 예를 봅시다.\nIn [1]: A = [1, 2, 3, [4, 5, 6]]\nOut[1]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\n\nIn [2]: B = A[:]; C=copy(A); D=deepcopy(A);\n\nIn [3]: A[4][2]=-1\nOut[3]: -1\n\nIn [4]: B\nOut[4]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [5]: C\nOut[5]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [6]: D\nOut[6]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\nA = [1, 2, 3, [4, 5, 6]] 는 벡터이며 정수와 벡터를 성분으로 갖기 때문에 Any 타입에 대한 벡터가 됩니다. A 의 네번째 성분은 벡터이며 실제로 A 변수에 내부적으로 저장되는것은 벡터 [4, 5, 6] 에 대한 주소입니다. C=copy(A) 명령어는 값 1, 2, 3 과 벡터 [4, 5, 6] 의 복사본을 만들지 않고 단지 주소만을 복사하여 변수 C 에 할당합니다. deepcopy 함수는 벡터 [4, 5, 6] 에 대해서도 복사본을 만들기 때문에 D=deepcopy(A) 명령어로 D 에 할당된 배열은 A 와는 같은 값을 갖는 완전히 별개인 배열이 됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "href": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "title": "배열",
    "section": "5 배열에 대한 함수",
    "text": "5 배열에 대한 함수\n\n인덱스 순회에 대한 함수들 : eachindex, CartesianIndex\n배열의 인덱스, 혹은 성분 각각에 대해 for ... end 루프를 수행하는 방법은 여러가지가 있습니다. 배열의 선형 인덱스를 이용하여 순회할 때는 eachindex 를 씁니다.\nIn [1]: A = [1 2; 3 4];\n\nIn [2]: for i in eachindex(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (1, 1)\n(i, A[i]) = (2, 3)\n(i, A[i]) = (3, 2)\n(i, A[i]) = (4, 4)\n\nIn [3]: for i in CartesianIndices(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (CartesianIndex(1, 1), 1)\n(i, A[i]) = (CartesianIndex(2, 1), 3)\n(i, A[i]) = (CartesianIndex(1, 2), 2)\n(i, A[i]) = (CartesianIndex(2, 2), 4)\n위에서 알 수 있듯이 eachindex(A) 는 배열 A 에 대한 선형 인덱스를 사용하여 순회하도록 하며 CartesianIndices(A) 는 데카르트 인덱스를 이용하여 순회합니다.\n\n\n\n타입과 모양의 변환\n우리는 앞서 타입이름이 타입 변환함수로 사용될 수 있다는 것을 보았습니다. 예를 들어 Float32(6) 은 Int64 타입의 6 을 4바이트 부동소수 타입인 Float32 타입으로 변환시킵니다. 또한 우리는 . 연산자를 통해 컨테이너의 각각의 성분에 대해 함수를 적용시킬 수 있다는 것을 알았습니다. 따라서 Float32.([1, 2, 3, 4]) 는 Float32 타입의 성분을 갖는 [1.0f0, 2.0f0, 3.0f0, 4.0f0] 입니다.\n\\(3\\times 5\\) 배열을 \\(5 \\times 3\\) 배열로 바꾸거나 \\(12 \\times 5\\) 배열을 \\(3\\times 4 \\times 5\\) 로 바꾸는 것과 같이 그 크기를 유지하지만 배열의 모양을 바꾸는 함수는 reshape 입니다. 예를 들어 보겠습니다.\nIn [1]: A = Array(1:6)\nOut[1]: 6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIn [2]: reshape(A, (2, 3))\nOut[2]: 2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\nIn[1] 에서의 A 는 6개의 성분을 갖는 1차원 벡터였지만 reshape(A, (2, 3)) 를 통해 \\(2 \\times 3\\) 행렬이 되었습니다. 다시 말하지만 원래의 행렬과 변환된 행렬의 총 성분 수는 같아야 합니다. 즉 length 가 같아야 합니다. reshape 는 원래 행렬과 변환 행렬의 선형 인덱스가 같도록 변환됩니다.\n\n\n\nview 와 @view\nview 는 이미 존재하는 배열로부터 특정 부분을 추출하여 만든 배열에 대한 타입이며, 이런 연산을 하는 함수이기도 합니다. 배열 A 에 대해 a=view(A, 1) 은 배열 A 의 첫번째 성분을 가리킵니다. 가리킨다라고 표현한 것은 단지 같은 값을 가질 뿐만 아니라 a 를 변경시키면 A 도 변경되기 때문입니다.\nIn [4]: A= [1 2;3 4];\n\nIn [5]: a = view(A, 1)\nOut[5]: 0-dimensional view(::Vector{Int64}, 1) with eltype Int64:\n1\n\nIn [6]: a[1]=3;\n\nIn [7]: A\nOut[7]: 2×2 Matrix{Int64}:\n 3  2\n 3  4\n다차원 배열의 경우 인덱스를 쓰거나 : 나 배열을 이용하여 범위를 특정 할 수 있습니다.\nIn [8]: B=reshape(Array(1:12), (3, 4))\nOut[8]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [9]: b=view(B, [1, 3], :)  # 1행과 3행, 그리고 열 전체에 대한 view\nOut[9]: 2×4 view(::Matrix{Int64}, [1, 3], :) with eltype Int64:\n 1  4  7  10\n 3  6  9  12\n\nIn [10]: b[2, 2]=-6 # view 의 변경\nOut[10]: -6\n\nIn [11]: B\nOut[11]: 3×4 Matrix{Int64}:\n 1   4  7  10\n 2   5  8  11\n 3  -6  9  12\n앞서 B[:, 3] 과 같이 이미 존재하는 배열로부터 그 부분을 성분으로 갖는 배열을 생성하는 방법을 보았습니다. @view 매크로는 view 함수를 쓰지 않고 B[:, 3] 과 같은 방법으로 view 를 생성합니다. 매크로에 대해서는 메타프로그래밍과 매크로 를 참고하시기 바랍니다. 일단은 @ 로 시작하는 명령문은 매크로 라고 하며 명령문 뒤에 주어진 인자나 함수에 대한 특별한 기능을 한다는 정도만 알아 둡시다\nIn [21]: B=reshape(Array(1:12), (3, 4))\nOut[21]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [22]: B[:, [2, 3]]\nOut[22]: 3×2 Matrix{Int64}:\n 4  7\n 5  8\n 6  9\n\nIn [23]: @view B[:, [2, 3]]\nOut[23]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\nB[:, [2, 3]] 은 B 의 2행과 3행만을 선택하여 새로운 배열을 만들기 때문에, 일단 만든 다음에는 원래의 B 값과 무관하게 변경시킬 수 있습니다. @view B[:, [2, 3]] 는 B 의 부분에 대한 view 를 만들기 때문에 C=@view B[:, [2, 3]] 를 통해 C 에 할당한다면 C 를 변경하는 것은 B 를 변경하는 것이 됩니다.\nIn [24]: C=@view B[:, [2, 3]]\nOut[24]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\n\nIn [25]: C[1, 1]=-1;\n\nIn [26]: B\nOut[26]: 3×4 Matrix{Int64}:\n 1  -1  7  10\n 2   5  8  11\n 3   6  9  12\nview 나 @view 가 필요한 이유는 메모리와 시간을 절약해 주기 때문입니다. 아주 큰 배열을 다룰 때 그 부분 배열에 대해 연산이 필요하다고 합시다. 배열을 새로 생성한다면 그만큼의 메모리와 배열의 생성과 복사를 위한 시간이 필요하지만 view 를 사용한다면 이미 존재하는 배열을 사용하기 때문에 약간의 메모리에서의 빈 공간만으로 연산을 수행 할 수 있습니다. 다만 view 나 @view 를 이용해 얻은 부분배열을 변경할 경우 원래의 배열도 변경된다는 사실을 명심해야 합니다.\n\n\n\n다차원 배열에서의 도트연산\n앞서 컨테이너 에서 도트 연산, 즉 연산자 앞이나 함수 뒤에 . 를 붙여 성분별 연산을 수행하는 것을 다루었습니다. 다차원 배열의 경우 차원이 같으면(즉 차원의 갯수와, 각 차원별 원소의 갯수가 같으면) 도트 연산을 수행할 수 있지만 차원이 다를 경우에는 차원을 확장하여 수행합니다.\n\n도트 연산에서의 차원 확장은 그 차원이 정의되어 있지 않거나 차원의 성분의 갯수가 1개 일때만 이루어집니다. 즉 [1 2] .+ [1 2; 3 4] 나 [1 2;] .+ [1 2; 3 4]는 가능하지만 [1 2;3 4] .+ [1 2 3; 2 3 4] 는 에러를 발생시킵니다.\n차원 확장은 차원이 없거나 1차원인 차원으로 원래의 배열을 반복합니다. [1 2] .+ [1 2; 3 4] 의 경우는 [1 2] 를 배열로 변환시킬 때 \\(1 \\times 2\\) 배열이 되며 첫번째 차원이 하나의 성분을 가지므로 첫번째 차원에 대해 두번 반복한 [1 2;1 2] 와 [1 2;3 4] 의 연산을 수행하게 됩니다.\n따라서 스칼라나 영차원 배열은 모든 차원의 다차원 배열에 대해 도트 연산이 가능합니다.\n\nIn [1]: [1;;2] .+ [1 2;3 4]\nOut[1]: 2×2 Matrix{Int64}:\n 2  4\n 4  6\n\nIn [2]: [1; 2] .+ [1 2;3 4]\nOut[2]: 2×2 Matrix{Int64}:\n 2  3\n 5  6\n\nIn [3]: [3] .* [1 2; 3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 3   6\n 9  12\n[1;;2] 는 \\(1 \\times 2\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 2; 1 2] 로 바뀌어 연산됩니다. [1 ; 2] 는 \\(2 \\times 1\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 1; 2 2] 로 바뀌어 연산됩니다.\n컨테이너에서의 도트 연산과 같이 @. 매크로도 동작합니다. @. 매크로를 앞에 붙이면 뒤에 나오는 함수나 연산자에 . 를 붙이지 않아도 julia 가 알아서 연산을 해 줍니다.\n\n\n\nbroadcast\nbroadcast(f, As...) 함수는 하나 이상의 값 혹은 컨테이너인 As... 에 함수 혹은 연산자 f 를 적용합니다. map 함수와 같은것이라고 생각 할 수 있지만, 실제로는 julia 에서 차원과 크기가 다른 컨테이너에 함수를 적용할 때는 이 함수가 기본이 되기 때문에 다차원 배열의 연산을 이해하기 위해서는 이 함수를 이해해야 합니다.\n\nf 를 제외한 인자가 스칼라나 0차원 배열일 경우 스칼라를 반환합니다.\nf 를 제외한 인자에 튜플이 포함되며, 튜플을 제외한 나머지 인자가 스칼라이면 튜플을 반환합니다.\nf 를 제외한 인자가 위의 두 경우와 다르다면 배열을 반환합니다.\nf 를 제외한 인자가 배열이나 스칼라라면 위의 도트 연산시의 차원 확장 규칙에 따라 차원을 확장하여 도트 연산으로 계산합니다.\n\nIn [1]: broadcast(+, 2, 3)\nOut[1]: 5\n\nIn [2]: ones()\nOut[2]: 0-dimensional Array{Float64, 0}:\n1.0\n\nIn [3]: broadcast(+, 1, ones())\nOut[3]: 2.0\n\nIn [4]: broadcast(*, 2, (1, 2, 3))\nOut[4]: (2, 4, 6)\n\nIn [5]: broadcast(*, (1, 2, 3), [-1, 1, 0])\nOut[5]: 3-element Vector{Int64}:\n -1\n  2\n  0\nIn [6]: broadcast(sin, range(0, π, length = 5))\nOut[6]: 5-element Vector{Float64}:\n 0.0\n 0.7071067811865475\n 1.0\n 0.7071067811865476\n 1.2246467991473532e-16\n크기가 다른 배열의 경우 다차원 배열의 도트 연산 과 같은 규칙으로 계산됩니다. 실제로는 도트 연산의 자체가 broadcast 함수를 사용하여 정의되었으므로 당연한 것입니다."
  },
  {
    "objectID": "src/introduction_to_julia/07_I_sort.html",
    "href": "src/introduction_to_julia/07_I_sort.html",
    "title": "Interude : 정렬",
    "section": "",
    "text": "Interude : 정렬\n정렬(sorting)이란 데이터를 정해진 순서에 따라 나열하는 것을 말합니다. 예를 들어 \\(1, 3, 2\\) 를 오름차순으로 정렬하면 \\(1, 2, 3\\) 이 되고, 내림차순으로 정렬하면 \\(3, 2, 1\\) 이 됩니다. 일반적으로 정렬이라고 하면 오름차순 정렬을 말합니다.\n정렬은 컴퓨터로 아주 많이 수행하는 연산중의 하나이며, 정렬을 효율적으로 하기 위해 많은 알고리즘이 제안되기도 하였습니다. 여기서는 그 알고리즘을 다루지는 않으며, 기본적인 정렬 함수와 그 사용법에 대해서만 다루도록 합니다. 좀 더 자세히 알고 싶으면 julia 문서 Soring and Related Functions 를 참고하시기 바랍니다.\nsort() 가 정렬을 수행하는 기본적인 함수입니다. sort(a) 는 컨테이너 a 를 정렬한 컨테이너를 반환하며 a 자체를 바꾸지는 않습니다. 그러나 sort!(a) 는 a 를 정렬된 상태로 바꿉니다. 그리고 함수 인자에 rev = true 를 입력하면 내림차순으로 정렬합니다.\nIn [1]: a=[1, 3, 5, 2]; b = sort(a)\nOut[1]: 4-element Vector{Int64}:\n 1\n 2\n 3\n 5\n\nIn [2]: sort!(b, rev = true);\n\nIn [3]: b\nOut[3]: 4-element Vector{Int64}:\n 5\n 3\n 2\n 1\nsortperm() 함수는 컨테이너가 정렬되었을 때의 인덱스를 반환합니다. 예를 들어 v=[11, 3, 22] 일 때 v 를 정렬하면 [3, 11, 22] 될 것이며 원래 v 의 입장에서는 v[2], v[1],v[3]가 될 것입니다.sortperm()함수는 바로 그 인덱스[2, 1, 3]` 을 반환합니다.\nIn [1]: v = [11, 3, 22]\nOut[1]: 3-element Vector{Int64}:\n 11\n  3\n 22\n\nIn [2]: sortperm(v)\nOut[2]: 3-element Vector{Int64}:\n 2\n 1\n 3\n배열 a 에 대해 a[[1, 3, 2, 4]] 는 [a[1], a[3], a[2], a[4]] 와 같습니다. 즉 a[sortperm(a)] 는 sort(a) 와 같습니다. sortperm 함수는 어떤 컨테이너의 정럴 순서로 다른 컨테이너를 정렬 할 수 있게 해 줍니다. 예를 들어 우리가 다음과 같은 데이터를 얻었다고 합시다.\n\n\n\nx\ny\n\n\n\n\n5\n10\n\n\n2\n3\n\n\n1\n6\n\n\n7\n12\n\n\n\n배열 x 는 [5, 2, 1, 7] 이고 y 는 [10, 3, 6, 12] 입니다. 이것을 보기 좋게 x 의 순서대로 y 까지 정렬해 봅시다..\nIn [10]: x=[5, 2, 1, 7];y=[10, 3, 6, 12];\n\nIn [11]: v = sortperm(x); x1 = x[v]; y1 = y[v]\nOut[11]: 4-element Vector{Int64}:\n  6\n  3\n 10\n 12\n\nIn [12]: for (x, y) in zip(x1, y1)\n         @show x, y\n         end\n(x, y) = (1, 6)\n(x, y) = (2, 3)\n(x, y) = (5, 10)\n(x, y) = (7, 12)\nx1 과 y1 이 각각 x 의 순서대로 x 와 y 를 정렬한 것임을 확인 할 수 있습니다..\n\n\n함수에 의한 정렬\n함수 f 에 대해 b = sort(a, by = f) 는 함수 f 의 결과값에 따라 a 를 정렬한 배열입니다. 다음 예를 봅시다. sort(0, by=cos) 은 a[perm(cos.(0))] 와 같습니다. 물룐 rev=true 를 인자로 넣으면 역순으로 정렬합니다.\nIn [1]: θ = [0, π/2, π, 3*π/2]\nOut[1]: 4-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 3.141592653589793\n 4.71238898038469\n\nIn [2]: θ[sortperm(cos.(θ))]\nOut[2]: 4-element Vector{Float64}:\n 3.141592653589793\n 4.71238898038469\n 1.5707963267948966\n 0.0\n\nIn [3]: sort(θ, by = cos)\nOut[3]: 4-element Vector{Float64}:\n 3.141592653589793\n 4.71238898038469\n 1.5707963267948966\n 0.0\n\nIn [4]: sort(θ, by = cos, rev=true)\nOut[4]: 4-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 4.71238898038469\n 3.141592653589793"
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html",
    "href": "src/introduction_to_julia/07_module_package.html",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다."
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다."
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#모듈",
    "href": "src/introduction_to_julia/07_module_package.html#모듈",
    "title": "이름공간, 모듈, 패키지",
    "section": "2 모듈",
    "text": "2 모듈\n모듈은 어떤 기능과 관련된 값, 함수, 자료형 등의 모음입니다. 추상적인 개념이 아닌 julia 에 그 문법이 정의된 기능으로 아래의 예제 코드와 같이 module 로 시작해서 end 로 끝납니다. 모듈 안에는 다른 모듈이 포함 될 수 있습니다. 하나의 파일에 여러개의 모듈이 같이 있을 수도 있습니다.\nmodule mymodule1\n\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\n\nend\n앞서 설명했듯이 모듈은 새로운 전역적인 이름공간을 만들 수 있습니다. 그 안에서 정의된 이름들은 다른 이름공간의 이름과 충돌할 염려 없이 사용 할 수 있습니다. 다른 이름공간에서 모듈의 이름을 사용하기 위해서는 우선 모듈 내에서 export 명령어를 통해 밖에서 사용 할 수 있는 이름을 지정해 줘야 합니다. 예를 들어\nIn [1]: module mymodule1\n        export a, mf\n        a=2\n        b=3\n        function mf(x)\n            return x*2\n        end\n        end\nOut[1]: Main.mymodule1\n이 모듈은 REPL 이 실행될 때 만들어지는 Main 이라는 전역적인 이름공간 내에 mymodule1 이라는 이름이 붙은 부분적인 이름공간을 만듭니다. 부분적 이름공간의 이름에 접근할 때는 . 으로 구분하여 Main.mymodule1.a 와 같이 접근하거나 전역적 이름공간을 제외한 mymodule1.a 와 같이 접근합니다. 예를 들어\nIn [2]: mymodule1.mf(3)\nOut[2]: 6\n는 mymodule1 모둘의 함수 mf 를 의미합니다.\n\nusing\nusing 명령어는 module 에서 export 명령어를 통해 지정한 이름들을 전역적 이름공간에서 사용 할 수 있게 해 줍니다.\nIn [6]: using .mymodule1\n\nIn [7]: a\nOut[7]: 2\n\nIn [8]: mf(3)\nOut[8]: 6\n\nIn [9]: mymodule1.b\nOut[9]: 3\n\nIn [10]: b\nERROR: UndefVarError: `b` not defined\nexport 를 통해 지정되지 않은 b 는 전역 이름공간에서 사용 할 수 없으며 굳이 접근하고자 하면 mymodule1.b 와 같이 접근해야 합니다.\n\n\n\nimport\nusing 명령어는 모듈 내의 이름을 전역적인 이름공간으로 가져오는데 비해 import 명령어는 모듈 이름만을 전역적인 이름공간으로 가져옵니다. 즉 import mymodule1 을 하면 mymodule1.a 나 mymodule1.mf 를 통해 접근해야 합니다. 그렇다면 단순히 REPL 에서 사용할 때는 차이가 없게 됩니다. 이 차이를 알기 위해 다음과 같은 내용을 mymodule.jl 파일로 저장합니다.\nmodule mymodule1\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\nend\n\nmodule mymodule2\nexport b, mf\na=4\nb=5\nfunction mf(x)\n    return x*a*b\nend\n두 모듈 모두 mf 란 함수가 존재하며 export 되므로 충돌의 가능성이 있습니다.. 이제 julia REPL 에서 모듈이 있는 파일을 읽고 mf 함수를 실행시켜 봅니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1\n\nIn [3]: mf(1)\nOut[3]: 2\nIn [2] 에서는 mymodule1 모듈만을 반입했으므로 mf 함수는 mymodule1 모듈의 그것입니다.\nIn [4]: using .mymodule2\nWARNING: using mymodule2.mf in module Main conflicts with an existing identifier.\n\nIn [5]: b\nOut[5]: 5\n\nIn [6]: mf(3)\nOut[6]: 6\nusing .mymodule2 를 하면 충돌이 발생하기 때문에 julia 인터프리터는 경고합니다. b 는 mymodule2 에서 반입된 5 가 사용되며 mf 함수는 먼저 반입된 mymodule1 의 그것입니다. 이렇게 이름이 충돌하는 것은 중요한 오류를 발생시킬 수 있으므로 절대로 피해야 합니다. 이런 경우에는 import 를 사용하는 것이 하나의 방법입니다. import 를 사용하면 모듈 이름에 다음에 . 을 붙이고\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: import .mymodule1\n\nIn [3]: import .mymodule2\n\nIn [4]: mymodule1.mf(1)\nOut[4]: 2\n\nIn [5]: mymodule2.mf(2)\nOut[5]: 40\n\n\n\nusing ... as, import ... as\n또 하나의 방법은 이름을 바꾸는 것입니다. usimg .mymodule1: a as a1, mf as mf1 이라고 하면 mymodule1 모듈의 a 를 전역적인 이름영역으로 반입하면서 그 이름을 a1 으로 바꾸며, mf 를 mf1 으로 이름을 바꿉니다. 이름울 바꾸지 않고 반입할 경우는 as ... 없이 이름만 쓰면 됩니다. 아래 코드의 In [2] 처럼 하면 됩니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1: a, mf as mf1\n\nIn [3]: a\nOut[3]: 2\n\nIn [4]: mf\nERROR: UndefVarError: `mf` not defined\n...\n\nIn [5]: mf1\nOut[5]: mf (generic function with 1 method)\n\nIn [6]: using .mymodule2:b, mf as mf2\n\nIn [7]: b\nOut[7]: 5\n\nIn [8]: mf2(a)\nOut[8]: 40\n\nIn [9]: mf1(1)\nOut[9]: 2\n이름을 바꾸는 것은 이름의 중복을 방지하는데도 사용되지만, 긴 이름을 짧게 해서 편리하게 쓰고자 할 경우나, 짧은 이름을 명확하게 하기위해 긴 이름으로 바꿀 때도 사용할 수 있습니다."
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "3 변수의 범위",
    "text": "3 변수의 범위\n모듈을 통해 이름공간과 다른 이름공간을 현재의 이름공간으로 반입하는 법을 알아보았습니다. 이름공간 내에서 사용 할 수 있는 변수를 전역적(global) 이라고 합니다. 반대로 이름공간 내의 특정 부분에서만 사용할 수 있는 변수를 지역적(local) 이라고 합니다. 변수가 유효한 지역적인 범위를 만들어 낼 수 있는 코드 영역을 블럭이라고 합시다. 대표적으로 함수를 정의하는 function ... end 구문이나 흐름 제어문인 for ... end 구문입니다. 이들은 그 내에서만 유효한 변수를 선언 할 수 있습니다.\n이제 이름 공간 내에서 변수의 범위를 알아봅시다. 아래 코드를 수행하기 전에 i 와 j 라는 변수를 할당하지 않았다고 합시다.\nIn [1]: for i in 1:10\n            j=i+1\n        end\n이 때 i 나 j 는 for ... end 블럭 밖에서는 접근 할 수 없으며, 접근하려고 하면 에러가 발생합니다.\nIn [2]: j\nERROR: UndefVarError: `j` not defined\n...\n\nIn [3]: i\nERROR: UndefVarError: `i` not defined\n...\n그러나 아래 코드와 같이 미리 j 변수를 정해둔 경우에는 j 변수는 for ... end 블럭 안에서 그대로 적용됩니다.\nIn [1]: j=0\nOut[1]: 0\n\nIn [2]: for i in 1:10\n        j=i+1\n        end\n\nIn [3]: j\nOut[3]: 11\n\n이젠 함수의 경우를 봅시다.\nIn [1]: j=4\nOut[1]: 4\n\nIn [2]: function mf1(x)\n        k = x+j\n        return k\n        end\nOut[2]: mf1 (generic function with 1 method)\n\nIn [3]: mf1(5)\nOut[3]: 9\n\nIn [4]: k\nERROR: UndefVarError: `k` not defined\n위의 코드에서 j 는 전역적 범위에서 4 를 할당받았습니다\\(^\\ast\\). mf1 이라는 함수 안의 k 라는 변수는 함수 내부에만 영항을 끼칠 수 있습니다. 그러나 j 는 전역변수이므로 함수 내의 j 는 함수 밖의 j 와 동일합니다. \\(^\\ast\\) 함수 내에서 인자로 주어지지 않은 함수 밖의 변수를 사용하는 것은 대부분의 경우 피해야 할 습관입니다. 이 경우는 무조건 인자로 전달해서 함수에서 처리해야 하지만, 변수 범위를 설명하기 위해 억지로 예를 든 것입니다.\n\nIn [4]: function mf2(x)\n        k = x+1\n            function mf3(y)\n                return (k+1)\n            end\n            return mf3(x+1)\n        end\n\nOut[4]: mf2 (generic function with 1 method)\n\nIn [5]: mf2(3)\nOut[5]: 5\nmf2 함수 정의 안에서는 새로운 지역적 변수들을 정의 할 수 있으며 mf3 는 mf2 안에서 더 지역적인 변수들을 만들 수 있습니다. k 는 mf2 함수 내에서 정의되었기 때문에 mf3 함수 정의 내에서 사용 할 수 있습니다. 이렇게 변수의 범위는 계층적입니다. 최상위에 전역적인 이름들이 있으며, 그 하위 범위마다 지역적인 변수를 사용 할 수 있습니다. 하위의 블럭에서는 상위의 변수를 사용 할 수 있습니다. 필요하다면 지역적 블럭에서 전역적인 혹은 상위의 블럭의 변수와 같은 이름을 갖지만 별도로 동작하는 이름을 만들 수 있습니다\\(^\\ast\\).  하지만 혼동을 일으키며, 이러한 혼동은 에러의 큰 원인이 되기 때문에 되도록이면 피해야 할 것입니다.\\(^\\ast\\) 이렇게 상위 이름공간에서 정의된 이름을 하위 이름공간에서 별도로 사용할 때, 해당하는 상위 이름공간의 이름의 효과를 일시적으로 멈추는 것을 shadowing 이라고 합니다.\n\n\n영역 타입\n전역적 혹은 지역적 범위의 변수를 생성 할 수 있는 블럭은 다음과 같습니다.\n\n\n\n\n\n\n\n\nConstruct\n영역 타입\n혀용되는 이름공간\n\n\n\n\nmodule, baremodule\n전역\n전역\n\n\nstruct\n지역 (soft)\n전역\n\n\nfor, while, try\n전역, 지역 (soft)\n전역\n\n\nmacro\n지역 (hard)\n전역\n\n\nfunctions, do blocks, let blocks, comprehensions, generators\n지역 (hard)\n전역, 지역\n\n\nbegin blocks, if blocks\n전역\n전역\n\n\n\n상위 범위의 이름은 하위 범위에서 사용 할 수 있습니다. 문제는 상위 범위에 있는 이름과 같은 이름을 하위 범위에서 사용할 때 이며 크게 두가지로 나눌 수 있겠습니다.\n\n상위 범위 변수를 그대로 사용하고 싶을 때.\n상위 변수와 같은 이름을 가진 변수를 별도로 하위 범위에서 사용하고 싶을 때.\n\n2번의 경우는 굳이 상위 변수와 같은 이름을 사용한다기 보다는, 상위 범위에 많은 변수명과 연산이 얽혀 있는데 그것을 일일이 확인하고 싶지 않을 때에 발생한다고 볼 수 있겠습니다. 이때는 local 을 사용하면 되는데 이후 설명하겠습니다.\n상위 범위에서 v=1 이라고 이름을 할당 했다고 합시다. 하위 범위에서 v=2 라고 변수를 명시적으로 할당 했다면 하위 이름공간의 영역에서는 v==2 이며 상위 이름공간의 v 는 가려집니다. 그런데 변수에 값을 할당 하지 않고 w=v+2 와 같이 v 의 값을 사용 할 때의 성질에 따라 hard scope 와 soft scope 로 나뉩니다.\n\nHard scope 의 경우 : 해당 하위 이름공간에 지역적 범위의 변수 v 가 생성됩니다.\n\nIn [1]: v=1\nOut[1]: 1\n\nIn [2]: function myfunc1(x)\n            println(\"in myfunc1, v+x=\", v+x)\n        end\nOut[2]: myfunc1 (generic function with 1 method)\n\nIn [3]: function myfunc2(x)\n            v=3 # local variable 이 생성됩니다. shadowing !!\n            println(\"in myfunc1, v=3, v+x=\", v+x)\n        end\nOut[3]: myfunc2 (generic function with 1 method)\n\nIn [4]: myfunc1(3)\nin myfunc1, v+x=4\n\nIn [5]: myfunc2(3)\nin myfunc1, v=3, v+x=6\n\nIn [6]: v\nOut[6]: 1\n\nSoft scope 의 경우\n\nJulia REPL 이나 jupyter 와 같이 interactive mode 일 경우에는 상위 범위의 변수 v 가 할당됩니다.\nInteractive mode 가 아닐경우에는 경고가 출력되며 하위 범위의 변수 v 가 생성됩니다.\n\n\n\n\n연습문제 1 for ... end 는 soft scope 입니다. 아래의 코드를 파일로 저장하고 julia 로 실행시켜보고 어떤 경고(Warning) 가 출력되는지 확인해 봅시다. Julia REPL 이나 jupyter 로 실행시켜 봅시다.\nv=10\nfor i in 1:10\n    v=i\nend\n\n\n\n\nlocal\n다음 코드를 봅시다.\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    v1 = v2+1\n    x = sin(v1)\nend\n이미 v1=0 라고 선언되었으며 if 문의 분기조건을 충족하기 때문에 위 코드의 실행이 끝나면 v1=4 가 됩니다. 그런데 당신이 실제로 원하는 것은 v1 값을 바꾸는 것이 아니라 단지 sin(v2+1) 을 계산하는 것이었다고 합시다. 코드가 길거나 많은 변수가 복잡하게 계산되고 있다면 이런 일이 벌어질 수 있습니다. 이 때 변수 할당 앞에 local 키워드를 놓으면 이 변수는 더 상위 범위의 같은 이름의 변수와 내부적으로 다르게 처리하며, 상위 범위의 미리 선언된 변수의 값에 영향을 주지 않습니다. 즉\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    local v1 = v2+1\n    x = sin(v1)\nend\n를 실행시키고 난 뒤에도 v1 == 0 입니다. local 키워드는 전역적으로 어떤 변수가 선언되었더라도 지역적인 변수를 만들어서 그 변수를 사용하며, 전역적인 변수는 건드리지 않도록 합니다."
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#패키지",
    "href": "src/introduction_to_julia/07_module_package.html#패키지",
    "title": "이름공간, 모듈, 패키지",
    "section": "4 패키지",
    "text": "4 패키지\n패키지는 모듈들과 모듈들을 관리하고 테스트하기위한 여러 파일들의 모음입니다. 공식적으로 지원되는 패키지들은 https://juliapackages.com 에서 확인 할 수 있습니다.\nJulia 를 설치하면 기본적으로 많은 자료형과 함수들도 같이 설치되지만 이것만으로는 충분하지 않습니다. 어떤 패키지는 Julia 언어와 함께 제공되며, 어떠 패키지는 패키지 관리자 Pkg.jl 을 이용하여 설치할 수 있습니다. Julia 의 패키지들은 Github 저장소에서 관리됩니다.\n\n패키지 추가\n패키지를 추가하는 방법은 두가지가 있습니다. 우선은\nusing Pkg\n를 실햄합니다. Pkg 는 패키지를 관리해주는 패키지로 기본적으로 julia 에 포함된 패키지 입니다. using Pkg 는 이제 Pkg 패키지에 포함된 여러 값, 함수, 자료형 등을 사용수 있도록 julia 에게 준비하라는 뜻입니다. 패키지 설치는 Pkg.add 함수를 사용합니다. 예를 들어 코드의 수행을 분석해주는 BenchmarkTools 를 설치한다면\nPkg.add(\"BenchmarkTools\")\n를 실행시키면 됩니다. 보통 하나의 패키지는 다른 패키지를 필요로 하는데 이 필요성 관계를 의존성(dependency) 이라고 합니다. Julia 는 자동적으로 이 패키지를 설치하는데 필요한 다른 패키지도 설치합니다. 패키지 설치가 성공하면\nusing BenchmarkTools\n명령문을 통해 BenchmarkTools 패키지의 여러 기능을 사용 할 수 있습니다.\n\n\n\n패키지 update\n보통 널리 사용되는 패키지는 끊임없이 개선됩니다. 이것을 update 라고 하며\nPkg.update()\n명령어는 이미 설치된 패키지 전체를 자동적으로 업데이트 합니다. 설치된 패키지가 많으면 몇분 정도의 시간이 걸릴 수도 있습니다.\n\n\n\n패키지 제거\nBenchmarkTools 패키지를 제거할때는 Pkg.rm(\"BenchmarkTools\") 명렬어를 수행하면 됩니다. 만약 제거하고자 하는 패키지에 의존하는 다른 패키지가 존재한다면 제거 할 수 없습니다. 억지로 제거할 수는 있지만 추천하지 않습니다. 다른 패키지를 먼저 제거하고 제거하십시요.\n\n\n\n패키지의 사용\n앞의 모듈의 사용과 마찬가지로 using 혹은 import 명령문을 사용합니다."
  },
  {
    "objectID": "src/introduction_to_julia/08_I_documentation.html",
    "href": "src/introduction_to_julia/08_I_documentation.html",
    "title": "Interude : 문서화",
    "section": "",
    "text": "Interude : 문서화\n함수나 연산자에 대해 알고 싶을 때 도움말은 다음과 같이 사용 할 수 있습니다.\n\nJulia REPL : ? 를 쳐 들어가는 help? 프롬프트에 함수 이름 등을 입력하고 엔터를 누른다.\nJupyter Notebook/Lab : 입력 셀에 ? 이후 함수 이름등을 입력하고 실행시킨다.\nvscode notebook : 입력 셀에 함수 이름 등을 입력하고 마우스 포인터를 위로 이동시킨다.\n\n여기서 보이는 도움말은 별도의 문서가 있는 것이 아니라 해당 함수나 뒤에 나올 복합타입 등의 위에 세겹 따옴표 \"\"\" 를 사용하여 표기합니다. 예를 들어 다음을 doctest01.jl 로 저장해 봅시다.\n\"\"\"\n    bps(a::Number) \n\n`a` 에 2를 곱한다.\n\n# Example\n\n```julia-repl\njulia&gt; bps([1 2;3 4])\n\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n\n\"\"\"\nfunction bps(a::Number) \n    return a*2\nend\njulia REPL 이나 jupyter 노트북에서는\ninclude(\"doctest01.jl\")\n를 이용하여 파일을 포함하면 각각의 방법을 통해 bps 에 대한 도움말을 볼 수 있습니다. vscode 에서는 2023년 8월 현재 단순히 include 를 통해 포함시킨 julia 함수에 대한 도움말을 볼 수는 없는 것 같습니다.\n함수 혹은 객체에 대한 도움말을 작성 할 때 julia 언어에서 권고하는 몇가지 방침이 있습니다. 여기에 공식 문서 Documentations 의 지침을 요약하여 설명합니다. 영어를 기준으로 기술되었기 때문에 한국어와는 잘 안맞을 수도 있습니다.\n\nJulia 마크다운(markdown) 문법으로 작성합니다.\n\nJulia 의 마크다운은 일반적인 마크다운과 약간 다릅니다. 예를 들어 일반적인 마크다운에서 문장내 수식이 $\\sin x$ 형식으로 가능하지만 julia 마크다운에서는 문장 내 수식이 불가능하며 코드블럭을 이용하여 다음과 같이 사용합니다.\n\n\n```math\nf(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n```\n```\n\n4개의 공백으로 들여쓰기를 한후 함수의 시그너쳐를 표현합니다.\n\n기본적으로 함수 정의의 시그너쳐를 그대로 쓰지만 시그너쳐가 너무 길 경우 인자의 타입을 생략하는 등의 간략화도 가능합니다.\n기본값이 정해진 선택적 인자는 그 기본값도 표시합니다. func(x, y=1) 과 같이 표현합니다.\n기본값이 없는 선택적 인자는 [ ] 안에 표현합니다. func(x, [y]) 나 func(x[, y[, z]]) 와 같이 표현합니다. 혹은 각각의 경우에 대해 별도의 문단에서 설명 할 수 있습니다.\n키워드 인자를 받는 함수의 경우 키워드 인자의 갯수가 많으면 func(x; &lt;keyword arguments&gt;) 와 같이 쓰고 뒤에 별도로 셜명합니다.\n\n시그너쳐 아랫줄의 설명은 함수가 어떤 기능을 하는지 한 문장으로 짧게 설명하는 것으로 시작합니다. 이 한문장 설명 이후 두번째 문장부터는 필요하다면 상세히 설명합니다.\n\n첫번째 한문장으로 설명하는 문장은 명령문 혹은 지시문의 형태를 사용하며 함수를 주어로 하는 3인칭을 사용하지 않으며 마침표로 끝납니다.\n함수의 의미를 간단 명료하게 요약하기 힘들 경우, 각각의 분야에 대해 자세하며 전체적으로는 일관된 기술로 대신 할 수 있습니다.\n\n반복은 피하십시요.\n\n예를 들어 첫줄의 함수 시그너쳐 부분에 함수 이름이 있기 때문에 다음에 나오는 한문장 설명이 bps 함수는 으로 시작될 필요가 없습니다. 또한 인자 유형이 시그너쳐에 표현될 경우 굳이 그것을 다시 설명할 필요도 없습니다.\n\n꼭 필요할 경우에만 인자들의 목록을 제시합니다.\n\n간단한 함수의 경우는 인자들의 역할만 기술합니다.\n키워드 인자가 많은 경우와 같이 함수 시그너쳐가 복잡할 경우는 인자들의 목록을 제시하는 것이 오히려 나을 경우가 있습니다.\n\n관련된 함수에 대한 정보를 제공합니다.\n\nsin 함수에 대한 도움말에\n\nSee also [`sind`](@ref), [`sinpi`](@ref), [`sincos`](@ref), [`cis`](@ref), [`asin`](@ref).\n라고 쓰인 것처럼 하면 됩니다.\n# Example 절에 예를 들어 줍니다. 마크다운 문법에서 코드블럭은 ```jldoctetst 로 시작해서 ``` 로 끝납니다.\n\n\"\"\"\nSome nice documentation here.\n\n# Examples\n```jldoctest\njulia&gt; a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n\"\"\"\n# Examples 섹션은 패키지가 제대로 설치되었는지 확인할 수 있는 간단한 코드를 넣습니다. 가능하면 julia REPL 에서 실행하는 코드를 넣는것이 좋습니다. 임의의 수를 생성하는 rand 함수 같은 것은 실행할 때 마다 결과가 다를 수 있기 때문에 꼭 필요한 경우가 아니라면 사용하지 않는 것이 좋습니다.\n\n물론 이 원칙이 항상 적용되는 것도 아니며, 많은 유명한 패키지들도 이런 원칙을 다 지키는 것은 아니지만 이런 것들을 따르는 것이 도움이 됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html",
    "href": "src/introduction_to_julia/08_type_hierarchy.html",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "2 메서드 다중 디스패치(Multiple dispatch)",
    "text": "2 메서드 다중 디스패치(Multiple dispatch)\n\n함수와 메서드\n각각의 컴퓨터 프로그래밍 언어나 프로그래밍 패러다임마다 함수와 메서드의 의미와 관계가 조금씩 다릅니다. 보통 프로그래밍에서 함수란 어떤 일련의 동작들을 모아 하나의 기능으로 만든 것을 말합니다. Julia 기본 문서의 Methods 를 보면 Julia 에서 보는 함수와 메서드는 이와는 약간 다릅니다. Julia 에서의 함수는 일종의 기능의 추상화입니다. 예를 들어 두 수를 더하는 함수를 생각해 봅시다. 먼저 원시 타입에 대한 더하기를 생각해보면, 원시 타입이란 특정한 비트의 배열이기 때문에 각 원시 타입마다 내부적으로 더하기를 다르게 구현해야 합니다. 하지만 모두 + 라는 연산자에 대해 정의됩니다. 이렇게 추상적으로 정의된 함수에 대해 각 타입마다 구체적으로 구현된 코드를 julia 에서는 메서드라고 부릅니다. 함수와 메서드의 의미와 관계는 언어마다 다르기 때문에 julia 에서 사용되는 용어가 다른 용어에서는 다른 의미 일 수 있습니다.\n다음의 함수 정의를 봅시다.\nIn [1]: function myfunc1(a, b)\n            return a*b\n        end\nOut[1]: myfunc1 (generic function with 1 method)\n함수를 정의할 때 특별히 인자에 제한조건을 두지 않았습니다. 이제 인자의 타입을 바꿔 가며 함수를 실행시켜봅시다.\nIn [2]: myfunc1(1, 3)\nOut[2]: 3\n\nIn [3]: myfunc1(2.2, 3.3)\nOut[3]: 7.26\n\nIn [4]: myfunc1(\"a\", \"bc\")\nOut[4]: \"abc\"\nJulia 는 함수의 정의를 기억했다가 처음 실행할 때 주어진 인자의 타입에 맞추어 컴파일하며 한 번 컴파일된 함수는 그 인자 타입으로 다음번 실행 할 때는 컴파일 없이 빠르게 실행 할 수 있습니다다. 이렇게 어떤 소스코드를 실행 전에 컴파일 하는 것이 아니라 실행하는 가운데 컴파일 하는것을 JIT(just-in-time) 컴파일 이라고 합니다\nmyfunc1 함수를 선언 할 때 인자의 타입에 대해 제한을 가하지 않았다는 것은 a, b 모두 Any 타입으로 지정되었다는 것입니다. 만약 a, b 모두 정수일 때, 즉 Integer 의 하위타입일 때는 곱하기가 아니라 더하기를 수행하기를 원한다고 해 봅시다.\nIn [5]: function myfunc1(a::Integer, b::Integer)\n        return a+b\n        end\nOut[5]: myfunc1 (generic function with 2 methods)\n\nIn [6]: myfunc1(1, 2)\nOut[6]: 3\n\nIn [7]: myfunc1(1.0, 2.0)\nOut[7]: 2.0\n\nIn [8]: myfunc1(1.0, 2)\nOut[8]: 2.0\n인자가 둘 다 정수일 때는 더하기가, 둘 중 하나라도 정수가 아니라면 곱하기가 수행됩니다. 만약 a 가 문자열이고 b 가 정수라면 a 를 b 의 절대값만큼 반복하도록 합시다.\nIn [9]: function myfunc1(a::String, b::Integer) \n        return a^abs(b)\n        end\nOut[9]: myfunc1 (generic function with 3 methods)\n\nIn [10]: myfunc1(\"aa\", -3)\nOut[10]: \"aaaaaa\"\n이렇게 우리는 인자 타입에 대해 myfunc1 이라는 함수 이름으로 3개의 메서드를 생성하였습니다.\n\n\n시그너쳐와 methods 함수\n메서드의 시그너쳐(signature) 는 함수이름과 인자, 그리고 인자의 타입을 포함합니다. 하나의 함수의 다양한 메서드는 시그너쳐로 구분되며, 한 함수의 시그너쳐는 method 함수로 확인 할 수 있습니다. methods(myfunc1) 는 함수 myfunc1 에 대한 모든 메서드의 시그너쳐를 반환합니다.\nIn [12]: methods(myfunc1)\nOut[12]: # 3 methods for generic function \"myfunc1\" from Main:\n [1] myfunc1(a::Integer, b::Integer)\n     @ REPL[5]:1\n [2] myfunc1(a::String, b::Integer)\n     @ REPL[9]:1\n [3] myfunc1(a, b)\n     @ REPL[1]:1\n여기서 볼 수 있듯이 myfunc1 함수에는 세가지의 메서드가 구현되었으며, 특정 타입에 대해 어떤 메서드가 실행될 지 파악 할 수 있습니다.\n\n함수 뿐만 아니라 연산자도 여러개의 메서드를 가질 수 있습니다. methods(+) 를 통해 + 연산자가 아주 많이 정의되었다는 것을 확인해 보시기 바랍니다. 이렇게 같은 함수나 연산자의 이름으로 인자의 타입에 따라 기능을 정하는 것을 메서드 디스패치, 혹은 다중 디스패치라고 합니다. 여러분은 앞으로 새로운 타입을 만드는 방법을 알게 될텐데 이미 존재하는 +, - 등의 연산자나 println, length 등의 함수를 다중 디스패치를 통해 타입에 맞게 사용 할 수 있습니다.\n\n\n\n\n모호한 메써드\n\\(a^b\\) 를 리턴하는 mypow 함수를 다음과 같이 구현했다고 해 봅시다.\nIn [1]: function mypow(a, b)\n        return a^b\n        end\nOut[1]: mypow (generic function with 1 method)\n\nIn [2]: function mypow(a::Number, b)\n        return a^b\n        end\nOut[2]: mypow (generic function with 2 methods)\n\nIn [3]: function mypow(a, b::Number)\n        return a^b\n        end\nOut[3]: mypow (generic function with 3 methods)\n\nIn [4]: methods(mypow)\nOut[4]: # 3 methods for generic function \"mypow\" from Main:\n [1] mypow(a::Number, b)\n     @ REPL[2]:1\n [2] mypow(a, b::Number)\n     @ REPL[3]:1\n [3] mypow(a, b)\n     @ REPL[1]:1\n3가지의 메서드가 구현되었습니다. 여기에 mypow(2, 3) 는 어떤 값을 리턴할까요? 컴파일러 입장에서는 두번째와 세번째 메써드가 동등한 권리를 갖고 있기 때문에 불확실 성이 존재하며 컴파일러는 에러를 발생시킵니다.\nIn [5]: mypow(2, 3)\nERROR: MethodError: mypow(::Int64, ::Int64) is ambiguous.\n\n\n\n타입 매개변수를 갖는 메서드\n메서드를 정의할 때 구체적, 추상적인 타입을 직접 표현하는 것이 아니라 타입 매개변수를 이용하여 정의 할 수도 있습니다. Julia 공식 문서의 예를 가져와 보겠습니다. 함수 인자 두개에 대해 그 타입이 같으면 true, 다르면 false 를 반환하는 함수를 작성해 봅시다. typeof 함수를 이용 할 수도 있겠지만 메서드를 이용하여 깔끔하게 정의 할 수도 있습니다. 일단 두개의 타입이 같으면 true 를 반환하는 함수를 작성합니다.\nIn [1]: same_type(x::T, y::T) where {T} = true\nOut[1]: same_type (generic function with 1 method)\n여기서 T 는 타입 매개변수 입니다. 함수의 인자 표현에서 x::T, y::T 는 x 와 y 가 그것이 무엇이든 같은 타입이어야 한다는 의미입니다. 타입이 다르면 적용할 메서드가 없다는 에러가 발생합니다.\nIn [2]: same_type(1, 2.0)\nERROR: MethodError: no method matching same_type(::Int64, ::Float64)\n타입이 다를 때는 false 를 반환하게 하려면\nIn [3]: same_type(x,y) = false\nOut[3]: same_type (generic function with 2 methods)\n와 같이만 하면 됩니다.\nIn [4]: same_type(1, 2.0)\nOut[4]: false\n이것이 작동하는 원리는 쉽습니다. 함수를 호출하면 메서드의 시그너쳐를 확인하여 실제 실행될 메서드를 찾는데 두 인자가 같은 타입일 경우 same_type(x::T, y::T) where {T} = true 메서드가 호출되며, 다른 타입일 경우 same_type(x,y) = false 메서드가 호출됩니다.\n\n타입 매개변수에 재한을 걸 수 있습니다. 예를 들어 다음을 봅시다.\nIn [10]: same_integer_type(x::T, y::T) where {T&lt;:Integer} = true\nOut[10]: same_integer_type (generic function with 1 method)\n\nIn [11]: same_integer_type(x, y) = false\nOut[11]: same_integer_type (generic function with 2 methods)\n\nIn [12]: same_integer_type(3, 4)\nOut[12]: true\n\nIn [13]: same_integer_type(UInt8(3), 4)\nOut[13]: false\n\nIn [14]: same_integer_type(3, 4.0)\nOut[14]: false\n두 변수 x, y 가 같은 종류의 정수 타입이 아니면 false 를 리턴합니다. 즉 다른 종류의 정수타입에도 false 를 반환합니다.\n\n\n함수 안에서의 타입매개변수\n함수에 타입 매개변수를 쓰는 또하나의 중요한 경우는 타입매개변수를 함수 안에서 사용하는 것입니다. 우리는 기본타입의 경우 타입 이름이 함수로 사용 될 수 있다는 것을 앞에서 보았습니다. 예를 들어 Float64(3) 에서 Float64 는 Int64 타입의 3 을 Float64 타입으로 변환시키는 함수로 사용되었습니다. 다음 함수를 봅시다.\nIn [1]: function myconvert(a::T, b) where {T}\n        return T(b)\n        end\nOut[1]: myconvert (generic function with 1 method)\n\nIn [2]: myconvert(2.0, 4)\nOut[2]: 4.0\n이 myconvert 함수는 두개의 인자를 받아 두번째 인자를 첫번째 인자의 타입으로 변환시켜 반환하는 함수입니다. 이 때 함수 시그니쳐의 타입 매개변수 T 가 함수의 몸체에서 사용되었습니다.\n\n\n\n아무것도 아닌 함수\n여러 메서드를 가지는 함수를 작성할 때 일단은 이름을 갖고 코드가 에러를 발생시키지는 않지만 실행은 안되는 함수가 필요할 때가 있습니다. 실용적으로 필요한 것이 아니라 문서화 작업 혹은 앞으로 작성할 함수라고 흔적을 남기기 위해 사용되기도 합니다.\nfunction great_function_with_many_methods end\ngreat_function_with_many_methods 은 함수로서 이름공간 포함되지만 아무 일도 할 수 없습니다."
  },
  {
    "objectID": "src/introduction_to_julia/09_I_pretty_printing.html",
    "href": "src/introduction_to_julia/09_I_pretty_printing.html",
    "title": "Interude : 객체를 보기좋게 출력하기",
    "section": "",
    "text": "Interude : 객체를 보기좋게 출력하기\n복소수를 나타내는 Complex 타입은 복합 타입이며 복소수에 대한 출력은 다음과 같습니다.\nIn [1]: c1 = Complex(2.0, 3.0)\nOut[1]: 2.0 + 3.0im\n당신이 만약 당신만의 복소수 타입을 복합타입으로 만들었다고 합시다.\nIn [2]: struct mycomplex\n        re\n        im\n        end\n\nIn [3]: c2 = mycomplex(2.0, 3.0)\nOut[3]: mycomplex(2.0, 3.0)\n보통 복합 타입의 출력은 위와 같이 타입 이름 뒤에 괄호로 그 필드의 값을 정의된 순서대로 나열합니다. 만약 어떤 타입에 많은 필드가 있지만 실제로 사용하면서 확인해야 할 필드는 소수라면, 굳이 여러개의 필드를 보여주지 않아도 됩니다. 혹은 Complex 타입에서 순허수 \\(\\sqrt{-1}\\) 를 im 으로 표기하는 것이 당신의 미적 감각에 거슬릴 수도 있습니다. 이 때 Base.show 함수를 mycomplex 타입에 대한 메서드로 만든다면 그 출력을 바꿀 수 있습니다.\nIn [12]: Base.show(io::IO, cc::mycomplex) = print(io, cc.re , \" + i\",  cc.im)\n\nIn [13]: c2\nOut[13]: 2.0+ i 3.0\n\nIn [14]: [mycomplex(2.0, 3.0); mycomplex(3.0, 4.0)]\nOut[14]: 2-element Vector{mycomplex}:\n 2.0 + i3.0\n 3.0 + i4.0\n그런데 허수부가 음수일 경우에는 별로 보기 안좋습니다.\nIn [20]: mycomplex(2.0, -1.0)\nOut[20]: 2.0 + i-1.0\n이것은 표준적인 복소수 표기법에 어긋나죠. 우리가 원하는 것은 2.0 - i1.0 입니다.\nIn [23]: function Base.show(io::IO, cc::mycomplex)\n         if cc.im &gt;= 0.0\n             print(io, cc.re, \" + i\", cc.im)\n         else\n             print(io, cc.re, \" - i\", abs(cc.im))\n         end\n         end\n\nIn [24]: mycomplex(2.0, -1.0)\nOut[24]: 2.0 - i1.0\n이젠 좀 괜찮아 진 것 같습니다. 물론 mycomplex 타입은 기본적인 사칙연산도 정의가 안되어 있기 때문에 쓸모 없긴 합니다. repr 함수는 Base.show 함수로 출력하는 문자열을 리턴합니다. 예를 들어\nIn [25]: c=mycomplex(1.0, -1.0)\nOut[25]: 1.0 - i1.0\n\nIn [26]: c\nOut[26]: 1.0 - i1.0\n\nIn [27]: repr(c)\nOut[27]: \"1.0 - i1.0\"\n입니다."
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html",
    "href": "src/introduction_to_julia/09_composite_types.html",
    "title": "복합 타입",
    "section": "",
    "text": "복합 타입(composite type) 은 필드(field)라고 불리는 하위 변수를 갖는 타입이며, 필드는 정수나 실수 타입 뿐만 아니라 함수 타입이나 다른 복합 타입이 될 수 있습니다. 우선 우리에게 아마도 익숙할 복수수 타입부터 시작해 보도록 하겠습니다."
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#complex",
    "href": "src/introduction_to_julia/09_composite_types.html#complex",
    "title": "복합 타입",
    "section": "1 Complex",
    "text": "1 Complex\nJulia 는 복소수를 다루기 위한 Complex{T} 타입을 내장하고 있습니다. Complex{T} 는 필드로 실수부와 허수부를 가지며 다음과 같이 정의됩니다.\nstruct Complex{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nComplex(x::Real, y::Real) = Complex(promote(x,y)...)\nComplex(x::Real) = Complex(x, zero(x))\n\nstruct ... end 부분은 복합 타입을 선언하는 부분입니다.\n&lt;:Number 를 통해 Complex 객체는 Number 의 하위타입으로 정의됩니다.\n{T&lt;:Real} 은 Complex 의 필드인 re 와 im 의 타입을 제한하기 위한 것입니다. T&lt;:Real 이며 re::T, im::T 이므로 re 와 im 의 두필드 는 Real 의 하위타입을 가지며 동일한 타입을 가집니다. 타입을 제한할 필요가 없을 경우에는 {T&lt;:Real} 과 같은 부분을 제거해도 됩니다. 두 개 이상의 타입이 필요할 경우는 {T1&lt;:Real, T2&lt;:Integer} 와 같이 { } 안에 , 로 분리하여 나열하면 됩니다.\n타입과 같은 이름을 가진 함수를 정의 할 수 있으며, 이 함수는 타입의 변수를 생성하는데 사용됩니다. 이렇게 어떤 타입과 같은 이름을 가지며, 그 타입의 값을 만드는데 사용되는 함수를 생성자(constructor) 라고 합니다.\n첫번째 생성자는 x 와 y 가 Real 타입의 하위 타입일 때 타입을 일치시키기 위한 생성자입니다. promote(x, y) 는 x 와 y 변수의 타입을 두 변수를 공통적으로 표현할 수 있는 타입으로 변환시켜 튜플로 반환합니다. 이렇게 다른 타입의 둘 이상의 값을 같은 타입이 되도록 변환하는 것을 julia 에서는 promotion 이라고 합니다. promote(2, 3.0) == (2.0, 3.0) 입니다. 그런데 Complex(promote(2, 3.0)) 은 Complex(2.0, 3.0) 이 아니라 Complex((2.0, 3.0)) 으로 튜플 인자 하나만 주어지며, 따라서 에러가 발생합니다. Complex(promote(2, 3.0)...) 는 promote(2, 3.0) 의 결과로 주어지는 튜플을 풀어서 함수의 인자로 넣도록 합니다. 즉, Complex(promote(2, 3.0)...) 은 결과적으로 Complex(2.0, 3.0) 입니다. 함수를 실행시킬때 인자에서의 사용법 을 참고하시기 바랍니다.\n두번째 생성자는 인자가 하나만 주어졌을 때 허수부를 인자 x 와 같은 타입의 0 으로 간주하여 생성하도록 하는 생성자입니다.\n\nComplex{T&lt;:Real} 은 다음과 같이 사용 할 수 있습니다.\nIn [1]: com1 = Complex{Float32}(3.3, 2.3) #Float32 타입의 필드를 갖는 복소수\nOut[1]: 3.3f0 + 2.3f0im\n\nIn [2]: com2 = Complex(3.3, 2.3) # 3.3, 2.3 이 Float64 이므로 타입의 필드를 갖는 복소수\nOut[2]: 3.3 + 2.3im\n\nIn [3]: com3 = 3.3 + 2.3im # 복소수를 선언하는 두번째 방법\nOut[3]: 3.3 + 2.3im\n\nIn [4]: com2 == com3 # 둘은 같다\nOut[4]: true\ntrue\n\n복합타입 변수의 필드에 접근하기 위해서는 . 를 사용합니다.\nIn [6]: c1 = Complex{Float64}(2.0, 3.0)\nOut[6]: 2.0 + 3.0im\n\nIn [7]: c1.re\nOut[7]: 2.0\n\nIn [8]: c1.im\nOut[8]: 3.0\n\nIn [9]: c1.im = 4.0\nERROR: setfield!: immutable struct of type Complex cannot be changed\n\n복합타입의 경우는 기본적으로 immutable 입니다. 즉 필드의 값을 직접적으로 바꿀 수 없으며 In [9] 에서와 같이 직접적으로 변경하고자 하면 에러가 발생합니다. 복합타입의 필드의 값을 바꿀 수 있는 복합타입은 mutable 이라고 하며 뒤에 변경할 수 있는 복합 타입 에서 다루겠습니다.\n\n위의 Complex{T&lt;:Real} 과 유사하지만 필드의 타입을 강제하지 않는 복합타입을 mycomplex 라는 이름으로 만들면 다음과 같습니다.\nstruct mycomplex1\n    re\n    im\nend\n문법적으로는 문제가 없지만 거의 쓸모 없는 코드입니다. 그러나 Complex{T&lt;:Real} 와 비교하여 복합 타입에 대한 이해를 도울 수 있습니다. Complex{T&lt;:Real} 과 다른 것은 필드의 타입을 제한하는 타입 매개변수 T 가 없다는 것이고, 필드인 re 와 im 이 어떤 타입이든 가질 수 있다는 것입니다. mycomplex1 은 복합 타입의 이름이기도 하며 이 복합타입을 생성하는 함수이기도 합니다. 함수의 인자로 멤버를 정의된 순서대로 입력하면 됩니다.\nIn [1]: struct mycomplex1\n            re\n            im\n        end\n\nIn [2]: c1 = mycomplex1(2, 3)\nOut[2]: mycomplex1(2, 3)\n\nIn [3]: c1.re\nOut[3]: 2\n\nIn [4]: c1.im\nOut[4]: 3\n\nIn [5]: c2=mycomplex1(3)\nERROR: MethodError: no method matching mycomplex1(::Int64)\n...\nIn [1] 에서 처럼 별도의 생성자 없이 타입 이름으로 복합 타입의 정의에서의 멤버의 순서대로, 멤버의 타입이 지정되었다면 지정된 타입에 맞게 입력하면 타입이 생성됩니다. 이렇게 별도의 생성자를 정의하지 않아도 자동적으로 생기는 생성자를 기본 생성자 라고 합니다. 하지만 In [5] 에서와 같이 인자를 하나만 입력하면 필요함 멤버 수에 부족하기 때문에 에러가 발생합니다. 생성자는 이 경우에 필요합니다.\nstruct mycomplex2\n    re\n    im\n    function mycomplex2(x)\n        return new(x, zero(x))\n    end\n\n    function mycomplex2(x, y)\n        return new(promote(x, y)...)\n    end\nend\n여기서 생성자는 Complex 와는 다르게 복합 타입 선언 내부에 정의되었습니다. 이렇게 복합 타입 선언 내부에서 정의된 생성자를 내부생성자 (inner constructor) 라고 합니다. 반대로 Complex 처럼 생성자가 복합 타입 선언 밖에서 정의된 생성자를 외부 생성자 (outer constructor) 라고 합니다. 내부생성자에는 new 함수를 사용 할 수 있는데 new 함수는 생성자를 찾지 않고 즉각적으로 멤버에 접근하여 복합 타입을 만들게 해 줍니다. new 함수는 외부생성자에서는 사용 할 수 없습니다.\n\n\n내부생성자와 외부생성자\n코드 유지보수의 관점에서는 아무래도 외부생성자가 편리합니다. 그러나 내부생성자만이 할 수 있는 일은 기본생성자를 변경하는 것입니다. 다음의 예를 봅시다.\nstruct A\n    m::Int64\n    function A(x, y)\n        return new(Int64(x+y))\n    end\nend\n\nstruct B\n    m::Int64\nend\n\nfunction B(x, y)\n    return B(Int64(x+y))\nend\n이 때 B(3) 은 기본생성자가 호출되어 B.m==3 인 객체가 만들어지지만 A(3) 은 기본생성자가 교체되었으므로 에러가 발생합니다."
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#sec-mutable_composite_types",
    "href": "src/introduction_to_julia/09_composite_types.html#sec-mutable_composite_types",
    "title": "복합 타입",
    "section": "2 변경할 수 있는 복합 타입 (mutable struct)",
    "text": "2 변경할 수 있는 복합 타입 (mutable struct)\n\nMutable and imutabile 타입\n앞서 언급했듯이 복합타입은 기본적으로 immutable 입니다. 이 말은 한 번 생성된 복합타입의 필드를 바꿀 수 없다는 뜻입니다. 필드를 바꿀 수 있는 복합타입은 struct 앞에 mutable 키워드를 넣습니다.\nIn [1]: mutable struct mycomplex2{T&lt;:Real} &lt;: Number\n        re::T\n        im::T\n        end\n\nIn [2]: mycomplex2(x::Real, y::Real) = mycomplex2(promote(x, y)...)\nOut[2]: mycomplex2\n\nIn [3]: mycomplex2(x::Real) = mycomplex2(x, zero(x))\nOut[3]: mycomplex2\n\nIn [4]: c2 = mycomplex2(2.0, 3.0)\nOut[4]: mycomplex2{Float64}(2.0, 3.0)\n\nIn [5]: c2.im\nOut[5]: 3.0\n\nIn [6]: c2.im = -3\nOut[6]: -3\n\nIn [7]: c2\nOut[7]: mycomplex2{Float64}(2.0, -3.0)"
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#sec-parametric_types",
    "href": "src/introduction_to_julia/09_composite_types.html#sec-parametric_types",
    "title": "복합 타입",
    "section": "3 타입 매개변수를 갖는 타입 (Parametric types)",
    "text": "3 타입 매개변수를 갖는 타입 (Parametric types)\n우리가 앞서 Complex 에 대한 정의를 보았을 때 Complex{T&lt;:Real} 로 정의했습니다. 이렇게 특정 타입 매개변수를 갖는 복합 타입을 정의 할 수 있으며, 타입 매개변수는 하나 이상이어도 됩니다. 예를 들어 실수를 정수와 \\([0.0, 1.0)\\) 사이의 실수로 나누는 dFloat 라는 두개의 타입 매개변수를 갖는 복합 타입을 아래와 같이 정의해 봅시다. 외부 생성자를 사용했으며 다음에 알아볼 보기좋게 출력하는법을 미리 사용했습니다.\nstruct dFloat{N&lt;:Integer, T&lt;:Real} &lt;: Number\n    vint::N\n    vfloat::T\n\n    function dFloat(x::Integer)\n        return new{typeof(x), Float64}(x, 0.0)\n    end\n\n    function dFloat(x::AbstractFloat)\n        vint = floor(Int64, x)\n        return new{Int64, typeof(x)}(vint, x-vint)\n    end\n\n    function dFloat(x::Integer, y::Real)\n        vint = floor(typeof(x), x+y)\n        vfloat = (x + y) - vint\n        return new{typeof(x), typeof(vfloat)}(vint, vfloat)\n    end\nend\n\n\nBase.show(io::IO, v::dFloat) = println(v.vint , \"+\", v.vfloat)\n\n기본생성자를 변경하기 위해 내부생성자를 사용했습니다. 그 결과는 다음과 같습니다.\nIn [1]: p = dFloat(4)\nOut[1]: 4+0.0\n\n\nIn [2]: q = dFloat(3.3)\nOut[2]: 3+0.2999999999999998\n\n\nIn [3]: dFloat(-5.2)\nOut[3]: -6+0.7999999999999998\n\n\nIn [4]: dFloat(3, 4.2)\nOut[4]: 7+0.20000000000000018\n\n\nIn [5]: dFloat(-3, 4.2)\nOut[5]: 1+0.20000000000000018\n\n\nIn [6]: dFloat(-3, -4.2)\nOut[6]: -8+0.7999999999999998"
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "title": "메타프로그래밍과 매크로",
    "section": "",
    "text": "메타프로그래밍은 프로그램 실행중에 자기 자신 혹은 다른 프로그램을 읽고 수정하고 실행할 수 있는 기술을 말합니다. Julia 처럼 어떤 언어가 자기 자신을 메타프로그래밍 하는것을 reflection 이라고 합니다. Julia 에서는 메타프로그래밍이 macro 를 통해 구현됩니다. Julia 에서의 메타프로그래밍과 매크로를 이해하기 위해서는 소스코드가 어떻게 실행되는지 그 과정을 이해해야 합니다."
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "title": "메타프로그래밍과 매크로",
    "section": "1 표현식",
    "text": "1 표현식\n\n표현식의 생성\n\nMeta.parse\nJulia 에서 소스코드의 실행은 소스코드의 문자열을 파싱(parsing) 하여 Expr 객체인 표현식(expression) 을 만드는데서 시작합니다. 문자열을 표현식으로 바꾸는 함수는 Meta.parse 입니다. `\nIn [1]: ex1 = Meta.parse(\"1+2\")\nOut[1]: :(1 + 2)\n\nIn [2]: typeof(ex1)\nOut[2]: Expr\n\nIn [3]: ex1.head\nOut[3]: :call\n\nIn [4]: ex1.args\nOut[4]: 3-element Vector{Any}:\n  :+\n 1\n 2\nExpr 객체는 head 와 args 라는 두 부분으로 나뉩니다. head 는 Symbol 타입으로 표현식의 종류를, args 는 표현식에 사용되는 Symbol, 값, 구문 등을 의미합니다. 앞서 ex1.head 가 :call 인데 이것은 함수, 혹은 연산자 호출이라는 것을 의미합니다. 아래의 코드에서 보듯이 함수 호출이 아닌 할당에서는 head 가 :(=) 로 바뀝니다.\nIn [5]: ex2=Meta.parse(\"a=2\")\nOut[5]: :(a = 2)\n\nIn [6]: ex2.head, ex2.args\nOut[6]: (:(=), Any[:a, 2])\n\n표현식은 eval 함수를 통해 실행 할 수 있습니다.\nIn [8]: eval(ex1)\nOut[8]: 3\n\n\n\nQuoting\n우리는 앞서 심볼 타입 에서 a=:b 와 같이 : 를 사용하여 심볼 타입을 정의하는 것을 보았습니다. : 로 시작하는 구문은 심볼 타입 뿐만 아니라 표현식도 생성합니다. Out[1] 에서 보듯이 : 로 시작하여 ( ) 안에 표현된 구문은 표현식을 정의합니다. 이렇게 :( ) 를 이용하여 표현식을 정의하는 것을 quoting 이라고 합니다.\nIn [1]: ex1 = :(a=1+2)\nOut[1]: :(a = 1 + 2)\n\nIn [2]: ex2 = Meta.parse(\"a=1+2\")\nOut[2]: :(a = 1 + 2)\n\nIn [3]: ex1==ex2\nOut[3]: true\n\nIn [4]: eval(ex1)\nOut[4]: 3\n\nIn [5]: a\nOut[5]: 3\n\n\n표현식의 내부\n이제 표현식이 내부적으로 어떻게 구성되는지를 봅시다. 보통 두가지 방법이 있습니다. 하나는 dump 함수를 통해 들여쓰기와 참조 표시를 포함하여 출력하는 것입니다.\nIn [7]: dump(ex1)\nExpr\n  head: Symbol =\n  args: Array{Any}((2,))\n    1: Symbol a\n    2: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol +\n        2: Int64 1\n        3: Int64 2\n다른 하나는 S-표현식 의 형태로 보는 것으로 Meta.show_sexp 함수를 이용합니다.\nIn [8]: Meta.show_sexpr(ex1)\n(:(=), :a, (:call, :+, 1, 2))\n\n\n\n:( ) 안에 값이 있는 경우\n한가지 유의해야 할 것은 표현식에 :(3) 처럼 :( ) 안에 값을 넣는다면 표현식이 아닌 값이 됩니다.\nIn [12]: :(3)\nOut[12]: 3\n\nIn [13]: :(3.34)\nOut[13]: 3.34\n\nIn [14]: :(\"aBγΔ\")\nOut[14]: \"aBγΔ\"\n\n\n\n\n\nquote ... end\n앞서 알아본 것처럼 :( ) 를 이용한 quting 을 통해 표현식을 정의 할 수 있으며 단순한 표현식에 적합합니다. 좀 더 복잡한 표현식을 위해서는 quote ... end 블럭을 다음과 같이 사용 할 수 있습니다.\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\nex 는 :(x=1;y=2;x+y) 와 같습니다.\n\n\n\n표현식의 보간법\n\n$ 를 이용한 보간\n$ 를 이용한 문자열 보간처럼 $ 를 이용하여 표현식을 보간 할 수 있습니다.\nIn [1]: a=1;\n\nIn [2]: ex1 = :(b=$a+3)\nOut[2]: :(b = 1 + 3)\nex1 표현식 내의 $a 는 즉시 a 라는 변수가 가진 값 1 로 치환됩니다. $ 로 보간하지 않았을 경우에는 a 변수의 값이 바뀔 경우 그 결과가 달라집니다.\nIn [3]: ex2 = :(b=a+3)\nOut[3]: :(b = a + 3)\n\nIn [4]: eval(ex1), eval(ex2)\nOut[4]: (4, 4)\n\nIn [5]: a=4; eval(ex1), eval(ex2)\nOut[5]: (4, 7)\n앞서 말했듯이 $ 로 보간했을 때는 즉시 변수가 현재의 값으로 치환됩니다. 따라서 ex1 에는 변수 a 의 흔적이 남아 있지 않습니다. 그러나 $ 로 보간되지 않은 ex2 는 eval 함수가 실행 될 때의 a 값이 입력되므로 그 값이 바뀌게 됩니다.\nIn [6]: Meta.show_sexpr(ex1)\n(:(=), :b, (:call, :+, 1, 3))\n\nIn [7]: Meta.show_sexpr(ex2)\n(:(=), :b, (:call, :+, :a, 3))\n\n\n\n스플래팅 보간\n$ 를 이용한 보간은 한번에 하나의 표현식만 보간합니다. 앞서 알아본 … 연산자 처럼 표현식의 배열을 이용하여 한꺼번에 보간 할 수 있습니다.\nIn [1]: exprs = [:a, :b, :c]\nOut[1]: 3-element Vector{Symbol}:\n :a\n :b\n :c\n\nIn [2]: :(f(1, $(exprs...)))\nOut[2]: :(f(1, a, b, c))\n\n\n\n중첨된 quote\n앞서 우리는 표현식의 보간을 알아보았습니다. 표현식 또한 표현식에 보간 될 수 있습니다. 다음을 봅시다.\nIn [1]: ex = :(1+2);\n\nIn [2]: ex1 = quote $ex end\nOut[2]: quote\n    #= REPL[2]:1 =#\n    1 + 2\nend\n\nIn [3]: eval(ex1)\nOut[3]: 3\n\nIn [4]: ex2 = quote ex end\nOut[4]: quote\n    #= REPL[4]:1 =#\n    ex\nend\n\nIn [5]: eval(ex2)\nOut[5]: :(1 + 2)\n\nIn [6]: eval(eval(ex2))\nOut[6]: 3\nex 는 표현식이며 ex1 은 quoto ... end 안에 $ex 즉 1+2 라는 식을 삽입합니다. 따라서 ex1 은 quote 1+2 end 와 같습니다. ex2 는 quote ... end 안에 :(1+2) 를 삽입합니다. 따라서 ex2 는 quote :(1+2) end 와 같으며, eval(ex2) 는 (1 + 2) 를 반환합니다. 아래의 ex3 는 당연히 quote ex end 와 같습니다.\nIn [8]: ex3 = quote quote $ex end end\nOut[8]: quote\n    #= REPL[8]:1 =#\n    $(Expr(:quote, quote\n    #= REPL[8]:1 =#\n    $(Expr(:$, :ex))\nend))\nend\n\n\n\n\nQuoteNode\n\n\n\n함수를 호출하는 표현식\n두 수의 최대공약수를 구하는 함수는 gcd 입니다. 즉 gcd(4, 6) 은 2 입니다. 이 표현식에 대한 S-표현식은 다음과 같습니다.\nIn [1]: ex1 = :(gcd(4, 6))\nOut[1]: :(gcd(4, 6))\n\nIn [2]: Meta.show_sexpr(ex1)\n(:call, :gcd, 4, 6)\nS- 표현식을 이용하여 ex1 과 같은 표현식을 Expr(:call, :gcd, 4, 6) 을 통해 만들 수 있습니다.\nIn [3]: ex3 = Expr(:call, :gcd, 4, 6)\nOut[3]: :(gcd(4, 6))\n\nIn [4]: eval(ex3)\nOut[4]: 2\n즉 인자 op1, op1 를 받는 함수 func1 을 호출하는 표현식은 Expr(:call, :func1, op1, op2) 입니다. 만약 인자가 많아지면 계속 , 로 이어 쓰면 됩니다."
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "title": "메타프로그래밍과 매크로",
    "section": "2 매크로",
    "text": "2 매크로\n매크로는 인자를 받아 표현식을 반환하는 특별한 타입의 함수라고 볼 수 있습니다. mymacro 라는 함수에 인자로 ag1, ag2 를 입력 할 때 @mymacro(ag1, ag2) 혹은 @mymacro ag1 ag2 와 같이 실핼 시킬 수 있습니다. 좀 더 자세히 알아봅시다.\n\n매크로와 함수의 차이\n매크로에 인자를 입력 할 수 있으며, 역시 함수와 유사합니다. 그러나 매크로는 함수와 다른 몇가지 차이점이 존재합니다.\n\n매크로는 전역 범위 내에서만 정의 될 수 있습니다.\n매크로의 인자는 매크로 내부에서 인자에 대한 표현식으로 바뀝니다.\n매크로의 반환값은 표현식이며 반환값을 값으로 반환하지 않고 실행합니다.\n매크로는 함수처럼 괄호 안에 인자를 나열할 수도 있으며, 괄호 없이 공백으로 구분하여 나열할 수도 있습니다.\n\n\n1은 매크로가 함수 정의 안이나 for ... end 같은 블럭 내부에서 정의될 수 없다는 것을 말합니다. 함수는 이와 반대로 함수 내부나 블럭 내부에서 정의 될 수 있습니다.\n\n\n매크로의 정의와 반환값\n매크로는 인자들을 받아 표현식을 반환하는 함수를 의미합니다. 매크로는 함수와 비슷하게 macro ... end 구문으로 정의하며, 매크로 이름 앞에 @ 를 붙여 실행 할 수 있습니다.\nIn [1]: macro hello_world()\n            return :(println(\"Hello, world!\"))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world()\nHello, world!\n\n\n\n매크로의 인자\n우선 매크로에 전달되는 인자가 매크로 내부에서 어떻게 되는지 알아봅시다.\nIn [1]: macro hello_world(your_name)\n            println(\"In macro, arg is = \", your_name, \", and the type is \", typeof(your_name))\n            return :(println(:\"Hello, world! I'm \", $your_name))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world(\"Julia\")\nIn macro, arg is = Julia, and the type is String\nHello, world! I'm Julia\n\nIn [3]: @hello_world(1+1)\nIn macro, arg is = 1 + 1, and the type is Expr\nHello, world! I'm 2\nIn [3] 를 봅시다. 인자로 1+1 을 넣었을 때 macro 내부에서는 Expr 객체인 :(1+1) 로 인식이 된다는 것을 알 수 있습니다. In [2] 의 경우처럼 식이 아닌 값을 넣는 경우는 앞에서 언급했듯이 표현식이 값으로 바뀝니다.\n\n\n\n매크로의 반환값과 macroexpand 매크로\n매크로는 정의상 표현식을 반환하지만 실제로는 반환되는 표현식을 실행합니다. 표현식을 반환받기 위해서는 macroexpand 라는 매크로를 사용합니다.\nIn [10]: @macroexpand(hello_world(\"Julia\"))\nOut[10]: :(hello_world(\"Julia\"))\n@macroexpand 는 매크로 분석에 아주 유용한 메크로입니다.  앞으로 @macroexpand 와 같이 @ 로 시작하는 이름은 별다른 설명이 없다면 매크로를 의미합니다.\n\n\n매크로 실행시 인자의 입력\n매크로는 인자를 함수처럼 ( ) 안에 넣어서 전달 할 수도 있지만 매크로 이름 뒤와 인자들 사이에 공백을 두고 나열 할 수 있습니다.\nIn [1]: macro club_members(mem1, mem2, mem3)\n            return :(println(\"Members are : \", $mem1, \", \", $mem2, \", \", $mem3))\n            end\nOut[1]: @club_members (macro with 1 method)\n\nIn [2]: @club_members(\"John\", \"Jenny\", \"Jucy\")\nMembers are : John, Jenny, Jucy\n\nIn [3]: @club_members \"Henny\" \"Mark\" \"Tony\"\nMembers are : Henny, Mark, Tony\n\n\n\n\n@assert 매크로\n개인적으로 많이 사용하는 매크로입니다. @assert 매크로는 인자로 true 나 false 를 판별하는 표현식과 문자열을 받으며 표현식이 true 일 경우는 아무것도 하지 않고 false 일 경우는 에러를 내며 프로그램을 정지합니다. @assert 매크로는 built-in 이므로 julia 에서 추가 패키지 설치 없이 실행 할 수 있습니다.\nIn [1]: @assert 2==3 \"에러 메시지\"\nERROR: AssertionError: 에러 메시지\n...\n2==3 은 거짓이므로 에러를 발생시킵니다. 에러에는 여러 종류가 있으며 여기서는 AssertionError 를 발생시켰습니다. 에러를 발생시킬 때는 추가 메시지를 출력 할 수 있는데 @assert 의 두번째 인자가 바로 추가메시지 입니다. @macroexpand 를 통해 @assert 가 반환하는 표현식을 봅시다.\nIn [22]: @macroexpand @assert a==b\nOut[22]: :(if a == b\n      nothing\n  else\n      Base.throw(Base.AssertionError(\"a == b\"))\n  end)\n자 이제 이것과 같은 일을 하는 매크로를 작성 해 봅시다. 실제 @assert 매크로와는 다를 수 있지만 거의 똑같이 작동합니다.\nIn [1]: macro myassert(ex, msgs...)\n            msg = ((isempty(msgs) ? ex : msgs[1]) |&gt; string)\n            return :($ex ? nothing : AssertionError($msg))\n        end\nOut[1]: @myassert (macro with 1 method)\n\nIn [2]: @myassert 3&gt;4 \"맞을 경우는 메시지가 출력되지 않음\"\nOut[2]: AssertionError(\"맞을 경우는 메시지가 출력되지 않음\")\n\nIn [3]: @myassert 3&lt;4 \"맞을 경우는 메시지가 출력되지 않음\"\n\n\n\n청결한 매크로\n매크로에 전달되는 표현식이 매크로를 오염시킬 수 있습니다. 다음의 코드를 봅시다.\nmacro mm(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $ex\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        return val\n    end\nend\n@mm t=100 으로 실행시키면 다음과 같은 출력을 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 100, val = 100\n100\n코드의 5 번째 줄 val = $ex 에서 실제로 수행하는 것은 val = t = 100 이며, t 와 val 모두 100 이 됩니다. 이 때 사용될 수 있는 것이 esc 함수입니다. esc 함수는 매크로 내에서만 사용 할 수 있는 함수로, 표현식을 평가할 때 내부 변수의 오염을 막아줍니다. 이제 다음 코드를 봅시다.\nmacro nn(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $(esc(ex))\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        val\n    end\nend\n@mm 과 @nn 의 차이는 5번째 줄에 esc 함수를 사용했다는 것 뿐입니다. @nn t=100 을 실행하면 우리가 원했던 오염되지 않은 결과를 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 1, val = 100\n100"
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html",
    "href": "src/introduction_to_julia/11_polynomial.html",
    "title": "Julia & Numerical Anlaysis",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\njulia&gt; ff = poly1([1.0, -2.0, 1.0])\n#1 (generic function with 1 method)\n\njulia&gt; ff(1.0)\n0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\njulia&gt; poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\njulia&gt; poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\ncoeff 가 벡터가 아니거나, 수의 벡터가 아니면 에러가 발생함을 알 수 있다.\nreturn 뒤의 return x::Number -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T}\n    coeffs :: Vector{T}\nend\n\nfunction SimplePolynomial(coeff::AbstractVector{T}) where T &lt;: Number\n    if length(coeff) == 0 \n        return SimplePolynomial(zeros(T, 1))\n    else \n        last_nz =findlast(!iszero, coeff)\n        coeff_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n        return SimplePolynomial(coeff[1:coeff_last])\n    end\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\njulia&gt; a = SimplePolynomial([1, 3])\nSimplePolynomial{Int64}([1, 3])\n\njulia&gt; a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial(coeff::AbstractVector{T}) where T &lt;: Number 에서 시작하는 구문은 내부생성자 (inner constructor) 구문이다. 여기서 T 의 타입을 Number 의 subtype 으로 제한한다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\njulia&gt; a1 = SimplePolynomial([1.0, 2.0, 3.0])\nSimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\njulia&gt; a1(1.0)\n6.0\n\njulia&gt; a1([4 3; 2 4])\n2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\njulia&gt; a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "href": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "title": "Julia & Numerical Anlaysis",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\njulia&gt; ff = poly1([1.0, -2.0, 1.0])\n#1 (generic function with 1 method)\n\njulia&gt; ff(1.0)\n0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\njulia&gt; poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\njulia&gt; poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\ncoeff 가 벡터가 아니거나, 수의 벡터가 아니면 에러가 발생함을 알 수 있다.\nreturn 뒤의 return x::Number -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T}\n    coeffs :: Vector{T}\nend\n\nfunction SimplePolynomial(coeff::AbstractVector{T}) where T &lt;: Number\n    if length(coeff) == 0 \n        return SimplePolynomial(zeros(T, 1))\n    else \n        last_nz =findlast(!iszero, coeff)\n        coeff_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n        return SimplePolynomial(coeff[1:coeff_last])\n    end\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\njulia&gt; a = SimplePolynomial([1, 3])\nSimplePolynomial{Int64}([1, 3])\n\njulia&gt; a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial(coeff::AbstractVector{T}) where T &lt;: Number 에서 시작하는 구문은 내부생성자 (inner constructor) 구문이다. 여기서 T 의 타입을 Number 의 subtype 으로 제한한다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\njulia&gt; a1 = SimplePolynomial([1.0, 2.0, 3.0])\nSimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\njulia&gt; a1(1.0)\n6.0\n\njulia&gt; a1([4 3; 2 4])\n2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\njulia&gt; a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/index.html",
    "href": "src/introduction_to_julia/index.html",
    "title": "Introduction to Julia",
    "section": "",
    "text": "Introduction to Julia"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "",
    "text": "현대의 수치 해석은 어떤 수학적인 문제를 컴퓨터를 이용하여 계산하는 것이다. \\(4x+2=6\\) 과 같은 단순한 방정식의 해를 구하는 것 부터 아주 큰 행렬을 이용한 계산이나 복잡한 미분방정식을 푸는 것까지 사용되고 있다. 수치 해석이 필요한 이유는 복잡하거나, 계산의 양이 많거나, 정확한 해를 구하기가 힘들어 근사적으로 구해야 하는 등 사람이 직접 계산하기 힘든 난관이 존재하기 때문이다.\n우리는 5차 이상의 방정식이 해석적으로 풀리지 않는다는 것을 알고 있다. 방정식이 해석적으로 풀린다는 것은 \\(ax^2+bx+c=0\\) 의 해가 \\(\\dfrac{-b \\pm \\sqrt{b^2-4ac}}{2}\\) 인 것처럼 방정식의 계수들로 이루어진 식으로 존재하지 않는 다는 것이다. 자연과학과 공학에서 매우 중요한 미분방정식의 경우는 해가 존재하는 경우가 오히려 드물다. 점성을 가진 유체의 흐름을 기술하는 나비에-스토크스 방정식 (Navier-Stokes equation) 의 경우는 그 3차원에서 그 해가 존재하는지 여부가 소위 밀레니엄 문제로 지정되었으며, 보통 나비에-스토크스 방정식은 아주 제한된 경우에 근사적으로 수치해석을 이용하여 계산할 뿐이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#컴퓨터에서의-정수와-실수real-number-의-표현",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#컴퓨터에서의-정수와-실수real-number-의-표현",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "1 컴퓨터에서의 정수와 실수(Real number) 의 표현",
    "text": "1 컴퓨터에서의 정수와 실수(Real number) 의 표현\n현대의 컴퓨터는 2진수로 모든것을 표현한다. 하나의 2진 단위를 비트 (bit) 라 하며 보통 8개의 비트를 단위로 표현하는데 이렇게 2진수 8자리로 이루어진 단위를 바이트 (Byte) 라 한다. 우리가 다루는 컴퓨터는 정해진 수의 바이트 수에 특정한 규칙에 따라 수를 표현한다. 예를 들어 8비트, 즉 1바이트에 정수를 표현한다고 하자. 이것으로 표현 할 수 있는 정수는 28=256 개가 전부이다. 이것보다 더 많은 정수를 표현하기 위해서는 더 큰 비트수를 차지하는 정수형을 사용해야 한다. Julia 에서 실수 표현의 기본값으로 많이 쓰이는 64비트 부동 소수(floating number)의 경우에는 표현할 수 있는 실수의 갯수는 최대 264 (\\(\\approx\\) 1.8×1019) 이며 실제로는 이것보다 다소 작다. 아주 큰 수 이기는 하지만 무한은 아니다.\n\n\n정수의 표현\nIntroductio to Julia 의 기본적인 수 타입 과 정수형 타입 을 참고하라.\n\n참고로 정수를 _ 로 이어서 표현 할 수 있다. 예를 들어 1234 는 1_2_34 와 같다. _ 가 정수 표현의 맨 앞이나 맨 뒤만 아니면 상관 없다.\nIn [1]: 123456789 == 1_234_56_789\nOut[1]: true\n이 표현은 정수가 매우 큰 수일 때 입력오류를 줄이는데 유용하다.\n\n\n\n유리수의 표현\nJulia 에서는 유리수 타입이 기본 타입이며 // 를 이용하거나 Rational 함수를 이용하여 정의한다.\nIn [4]: 3//2\nOut[4]: 3//2\n\nIn [5]: Rational(3, 2)\nOut[5]: 3//2\n3//2 는 \\(\\dfrac{3}{2}\\) 이다. 유리수끼리, 혹은 유리수와 정수의 사칙연산의 결과는 유리수이다.\nIn [6]: 5//2*2\nOut[6]: 5//1\n\nIn [7]: 5//2 +3\nOut[7]: 11//2\n유리수 타입은 자동으로 인수분해를 해 준다. 다만 In [6] 에서 보았듯이 정수형으로 자동으로 바꿔주진 않는다.\nIn [8]: 121//33\nOut[8]: 11//3\n\n\n\n실수(Real Number) 의 표현\n빛의 속도 \\(c\\) 는 299792458 m/s = 0.299792458 x 109 m/s 이다. 여기서 0.299794568 부분을 가수(mentissa) 라고 하고 109 를 지수(exponent)라 한다. 실수를 이렇게 가수와 지수로 나누어 표현하는 것을 부동소수점 표현이라고 하며 실수(real number)를 컴퓨터에서 표현 할 때 부동소숫점 표현(floating point representation) 이 기본적으로 사용된다.\nJulia 는 부동소숫점 표현에서 The IEEE 754 기준을 따른다. 이 기준에 따르면, 64비트 실수 (이후 Float64 라 한다)의 경우 음수/양수 를 나타내는 1 비트, 지수를 나타내는 UInt 형식의 11비트, 가수를 나타내는 52비트로 이루어진다. 각각의 비트를 \\(b_0,\\,b_1,\\ldots,\\,b_{63}\\) 이라 하자. \\(0\\) 부터 시작하는 인덱스에 익숙하지 않은 독자를 위해 설명하자면 C, C++, Python 등 많은 언어는 배열의 인덱스를 \\(0\\) 부터 시작하도록 한다. Fortran 이나 Julia 는 \\(1\\) 시작하지만, 메모리 비트를 표현할때는 보통 \\(0\\) 부터 시작하는계 관례이므로 여기서는 \\(0\\) 부터 시작하도록 하자. 64 비트 실수형이므로 인덱스는 \\(0\\) 부터 \\(63\\) 까지 이다.실제로는 대부분의 컴퓨팅 연산의 기본이 IEEE 754 이다\n이 때 마지막 비트, 즉 \\(b_{63}\\) 을 최상위 비트라 하고, 양수인지, 음수인지를 나타내는 비트이다. 이 값을 \\(p\\) 라 하자. \\(0\\) 이면 양수, \\(1\\) 이면 음수이다. \\(b_{52}\\) 부터 \\(b_{62}\\) 까지는 지수 정보를 저장한다. 지수정보는 UInt 형식으로 저장되며 지수를 \\(e\\) 라 하면,\n\\[\ne= \\sum_{i=0}^{10} b_{52+i} 2^i\n\\]\n이다. \\(e\\) 는 \\(0\\) 부터 \\(2047\\) 까지의 값을 가질 수 있지만 실제 지수로서 기능하는 것은 \\(1\\) 부터 \\(2046\\) 까지이다. \\(e=0\\) 일 때와, \\(e=2047\\) 일 때는 뒤에 기술하는 특별한 방법을 사용한다.\n가수는 \\(b_{0}\\) 부터 \\(b_{51}\\) 까지의 비트에 저장된다. 가수 \\(m\\) 은 \\(e&gt;0\\) 인지 아닌지 여부에 따라 다르다.\n\\[\nm= \\left\\{ \\begin{array}{ll} 1.0+ \\displaystyle{\\sum_{i=1}^{52}} \\, b_{52-i}2^{-i} \\qquad & \\text{if }e&gt;0\\,,\\\\ \\displaystyle{\\sum_{i=1}^{52}}\\, b_{52-i}2^{-i} & \\text{if }e = 0\\,. \\end{array} \\right.\n\\]\n가수 \\(m\\)의 범위는 \\(e&gt;0\\) 일 때는 \\(1\\le m &lt; 2\\) 이고 \\(e=0\\) 일 때는 \\(0\\le m &lt; 1\\) 이다. \\(e&gt;0\\) 일 경우, 52 비트로 1.0 이하의 유효숫자를 표현하고 거기에 에 1을 더해주기때문에 실제적으로는 가수는 53 bit 로 저장된다고 볼 수 있다. \\(e=0\\) 일 경우는 52비트로 저장된다고 볼 수 있다. \\(2^{-53} \\approx 1.1 \\times 10^{-16},\\, 2^{-52} \\approx 2.2 \\times 10^{-16}\\) 이므로 Float64 형식의 실수는 소수점 아래 17자리 이하의 가수의 차이는 구별 할 수 없다. 즉 \\(1.0 + 1.0 \\times 10^{-17}\\) 은 \\(1.0\\) 과 구별되지 않는다.\n이제 부호 \\(p\\) 와 지수 \\(e\\), 가수 \\(m\\) 을 이용해 실수 \\(r\\) 을 표현하면,\n\\[\nr=\\left\\{ \\begin{array}{ll} (-1)^p \\times m \\times 2^{e-1023}  \\qquad & \\text{if }e&gt;0\\,, \\\\ (-1)^p \\times m \\times e^{-1022} & \\text{if } e=0 \\,.\\end{array}\\right.\n\\]\n이다.\n한가지 언급하자면, \\(e=0,\\,m=0.0\\) 일 경우 \\(p\\) 값에 관계 없이 \\(0.0\\) 이 된다. 즉, 실수 \\(0.0\\) 을 Float64로 표현하는 방법은 2가지로 \\(+0.0\\) 과 \\(-0.0\\) 인데, 대부분의 언어는 특별한 경우를 제외하면 이 둘을 동일하게 처리하도록 되어 있다.\n\n\n\nNaN, \\(\\pm \\infty\\)\n앞서 지수 \\(e\\) 가 2047일 경우는 특별히 다룬다고 언급하였다.\nIEEE 754 표준에서는 NaN 과 양/음의 무한대 표현을 정의한다. 지수비트가 모두 \\(1\\) 이고 가수비트가 모두 \\(0\\) 이면 무한대를 의미한다. 부호비트가 \\(0\\) 이면 \\(+\\infty\\), 부호비트가 \\(1\\) 이면 \\(-\\infty\\) 이다.\n\\(e=2047\\) 이고 양과 음의 무한대를 표현하는 경우를 제외하면 모두 NaN 으로 처리한다. NaN 은 Not a Number 의 약자로, 연산 과정 등에서의 오류를 표현한다. NaN 도 종류에 따라 구분하는 경우가 있지만 여기서는 다루지 않는다.\n아래 표는 이런 특별한 표현을 정리한 것이다.\n\n\n\n\n\n\n\n\n\n\\(b_{63}\\)\n\\(b_{62}\\) ~ \\(b_{52}\\)\n\\(b_{51}\\) ~ \\(b_{0}\\)\n표현\n\n\n\n\n0\n00000000000\n0000000000000000000000000000000000000000000000000000\n+0.0\n\n\n1\n00000000000\n0000000000000000000000000000000000000000000000000000\n−0.0\n\n\n0\n11111111111\n0000000000000000000000000000000000000000000000000000\n\\(+\\infty\\)\n\n\n1\n11111111111\n0000000000000000000000000000000000000000000000000000\n\\(-\\infty\\)\n\n\n0\n11111111111\n0000000000000000000000000000000000000000000000000001\nNaN\n\n\n0\n11111111111\n1000000000000000000000000000000000000000000000000001\nNaN\n\n\n0\n11111111111\n1111111111111111111111111111111111111111111111111111\nNaN\n\n\n\n\n혹시나 관심있는 사람을 위해 bitstring 함수를 소개한다. 이 함수는 값을 비트표현의 문자열로 바꾸어준다.\nIn [9]: bitstring(0.0)\nOut[9]: \"0000000000000000000000000000000000000000000000000000000000000000\"\n\nIn [10]: bitstring(Inf)\nOut[10]: \"0111111111110000000000000000000000000000000000000000000000000000\"\n\nIn [11]: bitstring(-Inf)\nOut[11]: \"1111111111110000000000000000000000000000000000000000000000000000\"\n\nIn [12]: bitstring(UInt8(255))\nOut[12]: \"11111111\"\n\nIn [13]: bitstring(UInt8(1))\nOut[13]: \"00000001\"\n\n\n\nTrunctation error, Round-off error\n컴퓨터로 수치해석을 하는 경우 많은 오류가 있을 수도 있다. 프로그래밍적으로 오류가 발생하여 실행되지 않을 수도 있고, 프로그래머의 오류로 (예를 들면 더해야 하는데 곱한다던가) 틀린 답을 낼 수도 있다. 이런 인적 오류 이외에 발생할 수 있는 오류로는 truncation error 와 round-off error 가 있다.\nTruncation error 는 수학적 근사에서 기인하는 오차이다. 예를 들어 \\(e^x\\) 를 테일러 전개를 이용하여 계산한다면,\n\\[\ne^x \\approx 1+x+\\dfrac{x^2}{2} + \\dfrac{x^3}{3!} + \\cdots + \\dfrac{x^n}{n!}+ \\cdots\n\\]\n임을 이용한다. 그런데 컴퓨터는 무한번 계산을 할 수 없으므로 어느 정도에 끊어야 하며, 나머지 항에 의한 값이 오차가 될 것이다. 이러한 오차를 truncation error 라 한다. Truncation error 는 어쨌든 시간과 컴퓨터의 자원을 사용하기만 하면 대부분 원하는 정확도로 계산 할 수 있다.\nRound-off error 는 앞서 알아본 실수의 컴퓨터 표현에 의한 오차이다. 실수의 갯수는 무한대이며, 임의의 서로 다른 두 실수 사이에도 무한개의 실수가 존재한다. 그러나 64비트로 표현 가능한 실수는 최대한 \\(2^{64} \\approx 1.8\\times 10^{19}\\) 정도이다. 또한 앞서 알아봤듯이 유효숫자의 갯수는 10진수 표현으로 대략 16개 이며, IEEE 754 표준을 따르면 \\(3.6\\) 과 \\(3.6+1.0 \\times 10^{-16}\\) 은 구별되지 않는다. Julia 언어로 다음과 같이 계산해보자.\nIn [1]: 3.6-2.4-1.2\nOut[1]: 2.220446049250313e-16\n\nIn [2]: 3.6-1.2-2.4\nOut[2]: 4.440892098500626e-16\n다음과 같은 결과를 얻는다. 우리는 \\(3.6-2.4-1.2=0.0\\) 임을 알고 있지만, 컴퓨터로 계산한 결과는 다르다. 게다가 \\(3.6-2.4-1.2\\) 와 \\(3.6-1.2-2.4\\) 의 결과가 다르다. 이것은 불가피하며, 인간적인 관점에서는 다소 무작위적이기 때문에 계산을 하는 사람이 항상 주의해야 할 수 밖에 없다.\n또하나의 예를 들면,\nIn [3]: (3.4/1.6)*1.6\nOut[3]: 3.4000000000000004\n이다. 우리는 이 값이 3.4 이어야 함을 알고 있지만 ronnd-off 에러에 의해 결과가 \\(3.4+4.0\\times 10^{-16}\\) 으로 나왔다. 이는 Float64 에서 다루는 유효숫자의 갯수가 10진법으로 대략 16개 정도이기 때문에 발생한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#계산의-분석",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#계산의-분석",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "2 계산의 분석",
    "text": "2 계산의 분석\n특정 프로그래밍 언어를 사용하여 작성된 알고리즘이 어떤 정해진 문제를 해결하는 데 걸리는 시간을 예측하는 것은 거의 불가능하며, 보통 알고리즘을 실행 속도 측면에서 분석할 때는 수행 시간이 문제의 크기를 표현하는 변수 \\(n\\) 에 대해 점근적으로 어떻게 행동하는지 예측한다. 여기서 \\(n\\) 은 벡터의 차원, 행렬의 크기, 다항식의 차수(degree) 등을 의미한다. 보통 \\(n\\) 이 커짐에 따라 수행시간이 어떻게 되는지에 관심이 있기 때문에 \\(n\\to \\infty\\) 극한에서 생각하는데, 알고리즘의 계산 복잡도 (computational complexity) 를 분석하는 방법으로 많이 사용되는 것 중 하나가 대문자 \\(O\\) 표기법이다.\n\n\nFLOP\n수행 시간을 계산할 때 대상의 크기에 대한 변수 \\(n\\) 에 대해 몇번의 기본연산을 수행하는지를 따진다. 많이 사용되는 FLOP(floating-point operations) 는 계산에 수행되는 모든 스칼라 사칙연산과 제곱근을 1 flop 단위로 삼아 \\(n\\) 에 대한 함수 \\(T(n)\\) 으로 표현한다. 예를 들어 \\(n\\) 차원 공간에서의 두 벡터 u, v 의 내적은\nudotv = 0.0\nfor i = 1:n\n    udotv = udotv + u[i] * v[i]\nend\n를 통해 계산 할 수 있으며, \\(n\\) 번의 스칼라곱과 \\(n\\) 번의 스칼라합 계산이 수행되므로 내적에 대해서는 \\(T(n) = 2n = O(n)\\) 으로 표현한다. \\(n \\times n\\) 두 행렬 A, B 의 곱 C 는\nfor i = 1:n\n    for j = 1:n\n        for k = 1:n\n            C[i, j] = C[i, j] + (A[i, k] * B[k, j])\n        end\n    end\nend\n로 계산 할 수 있으며, \\(n^3\\) 번의 스칼라곱과 \\(n^3\\) 번의 스칼라 합 계산이 수행되므로 \\(T(n) = 2n^3\\) 이다.\n\n\n\n대문자 \\(O\\) 표기법\n예를 들어 \\(T(n) = n^3+n\\) 이라고 하자. \\(n\\) 이 매우 클 경우 \\(T(n)\\) 의 값에 대한 기여는 대부분 \\(n^3\\) 에서 오며 \\(n\\) 이 기여하는 바는 미미하다. 이 때 함수를 가장 크게 기여하는 부분만을 표현하는 방법이 대문자 \\(O\\) 표기법이다.\n\n대문자 \\(O\\) 표기법의 정의\n자연수 \\(n\\) 에 대한 양의 함수 \\(f(n)\\), \\(g(n)\\) 에 대해 \\(f(n) = O(g(n))\\) 은\n\\[\n\\lim_{n \\to \\infty}\\dfrac{f(n)}{g(n)} &lt;\\infty\n\\]\n이 됨을 의미한다. 또한 \\(f(n) \\sim O(g(n))\\) 은\n\\[\n\\lim_{n \\to \\infty}\\dfrac{f(n)}{g(n)} =1\n\\]\n을 의미한다.\n\n보통 \\(O(f(n))\\) 에서 \\(f(n)\\) 은 가능한 함수 가운데 가장 간단한 함수를 사용한다. 예를 들어,\n\\[\n\\begin{aligned}\n2n^3-3n+1 &= O(n^2)\\\\\nn \\ln(n) + 3n &= O(n \\ln (n))\n\\end{aligned}\n\\]\n과 같다. 즉, \\(2n-1 = O(n)\\) 이다. \\(n \\times n\\) 행렬 \\(\\boldsymbol{A},\\,\\boldsymbol{B}\\) 의 곱 \\(\\boldsymbol{C}=\\boldsymbol{AB}\\) 를 생각하자. \\(C_{ij} = \\boldsymbol{A}_{i:}\\cdot \\boldsymbol{B}_{:j}\\) 이므로 \\(T(n) = 2n^3-n^2 = O(n^3)\\) 이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#알고리즘과-루프-불변성",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#알고리즘과-루프-불변성",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "3 알고리즘과 루프 불변성",
    "text": "3 알고리즘과 루프 불변성\n알고리즘은 어떤 문제가 주어졌을 때 이 문제를 풀기 위한 구체적인 방법으로 유한번의 절차 이후 종료되어야 한다. 수치해석에서 대부분의 중요한 알고리즘은 for ... end 나 while ... end 같은 루프문 과 if ... elseif ... else... end 같은 분기문으로 이루어져 있다. 루프로 이루어지는 알고리즘이 가져야 할 가장 중요한 성질이 루프 불변성 (loop invariance) 이다. 알고리즘상의 어떤 명제 혹은 식 \\(P\\)가 아래와 같은 성질을 만족하면 루프 불변이라고 한다.\n\n초기조건 : 루프가 첫 번째 반복을 시작하기 전에 \\(P\\)가 참이어야 한다\n유지조건 : 루프의 \\(N\\) 회차 반복이 시작되기 전에 \\(P\\) 가 참이었다면 \\(N+1\\) 회차 반복이 시작되기 전까지도 계속 참이어야 한다\n종료조건 : 루프가 종료될 때 \\(P\\)이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다\n\n초기조건과 유지조건은 수학적 귀납법이 성립하는 조건과 동일하다는 것을 쉽게 알 수 있을 것이다. 세번째 종료조건이 여기에 고유한 것으로 어쨌든 알고리즘은 원하는 결과를 얻게 하며 종료되어야 한다.\n가장 간단한 문제로 두 자연수의 최대공약수를 구하는 유클리드 호제법을 생각해보자. 두 자연수 \\(n_1,\\,n_2\\) 에 대해 \\(n_1\\) 을 \\(n_2\\) 로 나눈 나머지를 \\(\\text{rem} (n_1,\\,n_2)\\) 라 하자. 두 자연수 \\(a\\), \\(b\\) 에 대한 최대공약수는 다음과 같은 절차로 얻을 수 있다.\n[과정 1] \\(a,\\,b\\) 중 큰 수를 \\(a_1\\), 작은 수를 \\(b_1\\) 이라 하자. \\(a=b\\) 이면 당연히 최대공약수는 \\(a(=b)\\) 이다.\n[과정 2] \\(n=2,\\,3,\\ldots,\\) 에 대해 \\(a_n\\), \\(b_n\\) 이 양의 정수이며 \\(a_n&gt;b_n\\) 일 때 \\(a_{n+1}=b_n,\\, b_{n+1}=\\text{rem}( a_n,\\,b_n)\\) 이라 한다. 이 과정을 \\(b_n=0\\) 이 될 때 까지 수행한다.\n[과정 3] \\(b_{n}=0\\) 일 때 \\(\\gcd(a,\\,b) = a_{n}\\) 이다.\n유클리드 호제법에 대해 다음 명제가 루프불변성을 가짐을 보이자.\n\n\\(a_n &gt; b_n&gt;0\\)\n\\(a_{n+1} &lt; a_n,\\, b_{n+1} &lt; b_n\\)\n\n첫번째 반복이 시작하기 전에 \\(a_1 = \\max \\{a,\\,b\\},\\,b_1 = \\min \\{a,\\,b\\}\\) 정의했으므로 1번을 만족한다. 2 번은 첫번째 루프에서 만족시킬 필요가 없다.이제 \\(N\\) 번 반복을 수행했을 때 위의 두 명제를 만족한다고 하자. \\(N+1\\) 번 수행한 \\(a_{n+1},\\,b_{n+1}\\) 이 이 조건을 만족하는것은 자명하다. 루프가 종료되는 조건은 \\(a_n=b_n\\) 일 때이다. \\(0&lt;a_{n+1}&lt;a_n\\) 이며 \\(a_n\\) 은 항상 자연수이므로 이 알고리즘은 필연적으로 \\(a_n=b_n\\) 이 되어 종료된다. 이때의 값이 두 수 \\(a,\\,b\\) 의 최대공약수이다.\nJulia 의 minmax(x, y) 함수는 x, y 중 작은값, 큰값을 튜플로 리턴한다. 즉 minmax(9, 7)=(9, 7) 이다. 이 함수를 이용하면 간단히 구현 할 수 있다. gcd 는 julia 내에 정의된 함수이므로 이것과 구별하기 위해 mygcd 함수로 구현해보자.\nfunction mygcd(a::T, b::T) where T&lt;:Integer \n    a, b = minmax(a, b)\n    while(b ≠ 0)\n        a, b = b, rem(a, b)\n    end\n    return a\nend"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html",
    "href": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html",
    "title": "수학에 관련된 표기법과 명제들",
    "section": "",
    "text": "수치해석을 위해서는 기본적으로 미적분학과 선형대수학에 관련된 지식이 필요하다. 이 장은 문서에 걸쳐 사용될 표기법과 명제들을 점검하기 위한 것이다. 수학적 명제들은 학부 1-2 학년 수준의 미적분학과 선형대수학에 포함되는 내용이며 증명은 제시하지 않는다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-basic_notations",
    "href": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-basic_notations",
    "title": "수학에 관련된 표기법과 명제들",
    "section": "1 기본적인 개념과 표기법",
    "text": "1 기본적인 개념과 표기법\n\n정의 1 (수) 정수의 집합을 \\(\\mathbb{Z}\\) 라고 한다. 양의 정수의 집합을 \\(\\mathbb{Z}_+\\) 라고 하고 음의 정수의 집합을 \\(\\mathbb{Z}_-\\) 라고 한다. 유리수의 집합을 \\(\\mathbb{Q}\\) 라고 하고 실수의 집합을 \\(\\mathbb{R}\\), 복소수의 집합을 \\(\\mathbb{C}\\) 라고 한다. 실수의 집합과 복소수의 집합은 체(field) 라고 불리우는 사칙연산이 잘 정의되는 집합이다. 체는 \\(\\mathbb{F}\\) 로 표기한다.\n\n\n\n정의 2 (함수) 집합 \\(X\\) 에서 \\(Y\\) 로의 함수 \\(f\\) 는 \\(f:X\\to Y\\) 라고 표기한다. \\(X\\) 에서 \\(Y\\) 로의 어떤 함수를 의미할때는 \\(X \\mapsto Y\\) 라고 표기한다.\n\n\n\n정의 3 (크로네커 델타 함수) 정수 \\(i, j\\) 에 대해\n\\[\n\\delta _{ij} = \\left\\{\\begin{array}{ll} 1 \\qquad &; \\text{if } i = j, \\\\ 0 &; \\text{if }i \\ne j \\end{array} \\right.\n\\]\n로 정의된 함수 \\(\\delta_{ij}\\) 를 크로네커 델타 함수라고 한다.\n\n\n\n정의 4 (행렬) 실수 성분을 갖는 \\(m \\times n\\) 행렬 전체의 집합을 \\(\\mathcal{M}_{m\\times n}(\\mathbb{R})\\) 이라고 한다. 복소수 성분을 갖는 \\(m \\times n\\) 행렬 전체의 집합을 \\(\\mathcal{M}_{m \\times n}(\\mathbb{C})\\) 라고 하며, 실수/복소수 여부가 일단 고정되기만 하면 상관 없는 경우 \\(\\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 라고 한다. 행렬 \\(\\boldsymbol{A}\\) 의 \\(i\\) 행 \\(j\\) 열 성분은 \\((\\boldsymbol{A})_{ij}\\) 혹은 \\(A_{ij}\\) 와 같이 표기한다.\n\\(n\\times 1\\) 행렬의 집합을 특히 \\(\\mathcal{M}_n (\\mathbb{F})\\) 라고 한다. 실수/복소수 여부가 정해져 있을 경우 \\(\\mathbb{F}\\) 는 \\(\\mathbb{R}\\) 이나 \\(\\mathbb{C}\\) 가 된다. \\(\\boldsymbol{v}\\in \\mathcal{M}_n (\\mathbb{F})\\) 의 \\(j\\) 행 성분은 \\(v_j\\) 로 표기한다. \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대해 \\(B_{ij} = A_{ji}\\) 인 행렬 \\(\\boldsymbol{B}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 를 \\(\\boldsymbol{A}\\) 의 전치 행렬 (transposed matrix) 이라고 하며 \\(\\boldsymbol{A}^T\\) 라고 쓴다. \\(\\boldsymbol{A}=\\boldsymbol{A}^T\\) 일 때 \\(\\boldsymbol{A}\\) 를 대칭 행렬(symmetric matrix) 이라고 한다. \\(\\boldsymbol{A}\\) 가 복소행렬일 때 \\(C_{ij} = \\overline{A_{ji}}\\) 인 행렬 \\(\\boldsymbol{C}\\) 를 수반 행렬 (adjoint matrix) 라고 하며 \\(\\boldsymbol{A}^\\ast\\) 라고 쓴다. \\(\\boldsymbol{A}=\\boldsymbol{A}^T\\) 이면 대칭 행렬 이라고 하고 \\(\\boldsymbol{A}=\\boldsymbol{A}^\\ast\\) 이면 에르미트 행렬(Hermitian matrix) 이라고 한다.\n\n\n이미 사용했지만 행렬은 \\(\\boldsymbol{A}\\) 와 같이 기울어진 굵은 글씨체 대문자로 표현한다. 열벡터, 즉 벡터의 행렬표현의 경우 \\(\\boldsymbol{v}\\) 와 같이 기울어진 굵은 글씨체의 소문자로 표현한다. 집합의 경우는 \\(X, A\\) 와 같이 대문자를, 집합의 원소의 경우는 소문자를 사용한다. 학문적인 관례에 따르거나, 혹은 특별한 필요가 있을 경우 언급과 함께 이 원칙에 어긋날 수 있다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-summary_of_linear_algebra",
    "href": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-summary_of_linear_algebra",
    "title": "수학에 관련된 표기법과 명제들",
    "section": "2 행렬대수학 정리",
    "text": "2 행렬대수학 정리\n\n정의 5 (벡터공간과 벡터) 어떤 집합 \\(V\\) 와 체 \\(\\mathbb{F}\\) 에 대해 \\(V\\) 의 원소 사이의 덧셈과 \\(\\mathbb{F}\\) 와 \\(V\\) 사이의 곱셈이 정의되어 있으며, 다음이 성립하면 \\(V\\) 를 \\(\\mathbb{F}\\) 위에서의 벡터공간 혹은 \\(\\mathbb{F}\\)-벡터공간 이라 한다.\n\n\\(u,\\,v \\in V ,\\, a\\in \\mathbb{F} \\implies u+v = v+u \\in V\\), \\(av\\in V\\),\n\\(u,\\,v,\\,w \\in V,\\, a,\\, b\\in \\mathbb{F} \\implies (u + v) + w = u+(v+w)\\), \\((ab)v = a(bv)\\),\n\\(\\exists 0_V\\in V\\, \\forall v\\in V,\\, v + 0_V=0_V+v = v\\),\n\\(\\forall v\\in V \\;\\exists w\\in V\\) s.t. \\(v + w = 0_V\\),\n\\(\\forall v \\in V \\implies 1v =v\\),\n\\(u,\\,v \\in V,\\, a,\\, b\\in \\mathbb{F} \\implies a(u+v)=au + av,\\, (a+b)v = av+bv\\).\n\n벡터공간 \\(V\\) 가 정의되었을 때 벡터공간의 원소를 벡터(vector) 라 한다. \\(\\mathbb{R}\\) 위에서의 벡터 공간을 실벡터공간(real vector space) 혹은 \\(\\mathbb{R}\\)-벡터공간, \\(\\mathbb{C}\\) 위에서의 벡터 공간을 복소벡터공간(complex vector space) 혹은 \\(\\mathbb{C}\\)-벡터공간 이라 한다. \\(0_V\\) 는 영벡터라고 불린다.\n\n\n\n정의 6 (선형 결합, 선형 독립, 기저) \\(\\mathbb{F}\\)-벡터공간 \\(V\\) 와 \\(v_1,\\ldots,\\,v_m\\in V\\) 에 대해\n\\[\nv = a_1v_1 + \\cdots + a_mv_m ,\\qquad a_1,\\ldots,\\,a_m\\in \\mathbb{F}\n\\tag{1}\\]\n일 때 \\(v\\) 는 \\(\\{v_1,\\ldots,\\,v_m\\}\\) 의 선형 결합이라고 한다. \\(\\text{span}\\, (v_1,\\ldots,\\,v_m)\\) 은 \\(\\{v_1,\\ldots,\\,v_m\\}\\) 의 선형결합인 모든 벡터의 집합이다. 즉,\n\\[\n\\text{span}\\, (v_1,\\ldots,\\,v_m) =\\{a_1v_1 + \\cdots + a_m v_m: a_1,\\ldots,\\,a_m\\in \\mathbb{F}\\}\n\\tag{2}\\]\n이다. \\(\\{v_1,\\ldots,\\,v_m\\}\\) 에 대해\n\\[\na_1v_1 + \\cdots + a_m v_m = 0_V \\implies a_1= \\cdots =a_m=0\n\\]\n일 때 \\(\\{v_1,\\ldots,\\,v_m\\}\\) 이 선형 독립 이라고 한다. 선형 독립이 아닌 벡터의 집합을 선형 종속 이라고 한다.\n\\(\\{v_1,\\ldots,\\,v_m\\}\\) 이 선형 독립이며 \\(\\text{span}\\, (v_1,\\ldots,\\,v_m) = V\\) 일 때 \\(\\{v_1,\\ldots,\\,v_m\\}\\) 를 \\(V\\) 의 기저(basis) 라고 한다. 유한개의 벡터로 이루어진 기저를 갖는 벡터공간을 유한차원 벡터공간이라고 한다. 유한차원 벡터공간이 아닌 벡터공간을 무한차원 벡터공간이라고 한다.\n\n\n\n명제 1 벡터공간의 기저는 항상 찾을 수 있다. 또한 벡터공간의 기저는 유일하지 않다. 그러나 유한차원 벡터공간의 기저에 포함되는 벡터의 갯수는 정해져 있으며 이 갯수를 벡터공간의 차원(dimension) 이라고 한다. 벡터공간 \\(V\\) 의 차원은 \\(\\dim (V)\\) 로 표기한다. \\(\\dim(\\mathcal{M}_n (\\mathbb{F})) = n\\) 이다.\n\n\n\n명제 2 벡터공간 \\(V\\) 의 기저 \\(\\mathcal{B}_V = \\{v_1,\\ldots,\\,v_m\\}\\) 에 대해 벡터 \\(v\\in V\\) 를 \\(\\mathcal{B}_V\\) 의 선형결합으로 표현하는 방법은 유일하다.\n\n\n\n정의 7 \\(U\\) 가 벡터공간 \\(V\\) 의 부분집합이며 벡터공간일 때 \\(U\\) 를 \\(V\\) 의 부분공간이라고 한다.\n\n\n\n명제 3 \\(U\\) 가 유한차원 벡터공간 \\(V\\) 의 부분부분공간이면 \\(U\\) 도 유한차원 벡터공간이며 \\(\\dim (U) \\le \\dim (V)\\) 이다. \\(\\dim (U)= \\dim (V)\\) 이면 \\(U=V\\) 이다.\n\n\n\n정의 8 \\(\\mathbb{F}\\)-벡터공간 \\(U,\\,V\\) 에 대해 함수 \\(T:U \\to F\\) 가 다음을 만족하면 선형 사상(linear map) 이라고 한다.\n\\[\n\\forall u_1,\\,u_2\\in U,\\, \\forall c\\in \\mathbb{F}, \\qquad T(u_1+cu_2) =  T(u_1)+cT(u_2).\n\\]\n\\(U \\mapsto V\\) 선형 사상의 집합을 \\(\\mathcal{L}(U, V)\\) 라고 표기한다. 자기 자신으로의 선형사상을 선형 연산자 (linear operator) 라고 하고 \\(\\mathcal{L}(U)\\) 처럼 표현한다.\n\n\n\n명제 4 (선형연산자의 합과 스칼라곱) \\(\\mathbb{F}\\)-벡터공간 \\(U,\\,V\\) 에서의 선형사상의 집합 \\(\\mathcal{L}(U, V)\\) 에 더하기와 스칼라곱 연산을 다음과 같이 정의한다. \\(T,\\,S\\in \\mathcal{L}(U, V)\\) 이고 \\(c\\in \\mathbb{F}\\) 일 때 \\(u\\in U\\) 에 대해\n\\[\n\\begin{aligned}\n(T+S)(u) &= T(u)+S(u), \\\\\n(cT)(u) & =  c(T(u)).\n\\end{aligned}\n\\]\n이렇게 정의된 연산에 대해 \\(\\mathcal{L}(U, V)\\) 는 벡터공간이다.\n\n\n\n명제 5 \\(S\\in \\mathcal{L}(U, V)\\), \\(T\\in \\mathcal{L}(V, W)\\) 일 때 선형사상의 합성 \\(T \\circ S\\) 도 선형사상이다.\n\n\n\n명제 6 \\(T\\in \\mathcal{L}(U, V)\\) 는 \\(U\\) 의 어떤 기저 \\(\\{u_1,\\ldots,\\,u_m\\}\\) 에 대해 \\(T(u_1)=v_1, \\ldots,\\,T(u_m)=v_m\\) 을 만족하는 선형사상은 유일하다.\n\n\n\n명제 7 \\(T\\in \\mathcal{L}(U, V)\\) 일 때 \\(n=\\dim (U), m = \\dim (V)\\) 라고 하자. \\(\\{u_1,\\ldots,\\,u_n\\}\\) 이 \\(U\\) 의 기저이고 \\(\\{v_1,\\ldots,\\,v_m\\}\\) 이 \\(V\\) 의 기저일 때 선형사상 \\(T\\) 는 \\(u_i\\) 에 대해 항상\n\\[\nT (u_i) =  A_{1i}v_1 + \\cdots + A_{mj}v_m  = \\sum_{j=1}^m A_{ji}v_j, \\qquad i=1,\\ldots, n\n\\tag{3}\\]\n꼴이다.\n\n\n\n정의 9 (벡터와 선형 사상의 행렬 표현) \\(T\\in \\mathcal{L}(U, V)\\) 이고 \\(\\mathcal{B}_U = \\{u_1,\\ldots,\\,u_m\\}\\) 과 \\(\\mathcal{B}_V = \\{v_1,\\ldots,\\,v_n\\}\\) 이 각각 \\(U\\) 와 \\(V\\) 의 기저라고 하자. \\(u = a_1 u_1 + a_m u_m\\) 일 때 \\(u\\) 를 \\(m \\times 1\\) 행렬로 \\(\\begin{bmatrix} a_1 & \\cdots & a_m\\end{bmatrix}^T\\) 와 같이 \\(m \\times 1\\) 행렬로 표현하는 것을 \\(u\\) 의 \\(\\mathcal{B}_U\\) 기저에 대한 행렬 표현이라고 하며 \\([u]_{\\mathcal{B}_U}\\) 로 표기한다. 역시 \\(v= b_1 v_1 + \\cdots + b_n v_n\\) 일 때 \\([v]_{\\mathcal{B}_V} = \\begin{bmatrix}b_1 & \\cdots & b_n\\end{bmatrix}^T\\) 이다.\n\\(T\\) 는 \\(\\mathcal{B}_U,\\,\\mathcal{B}_V\\) 에 대해 식 3 와 같이 정의되므로 행렬 형태로 쓸 수 있으며 이것을 \\([T]_{\\mathcal{B}_U, \\mathcal{B}_V}\\) 라고 표기한다. 즉 \\(([T]_{\\mathcal{B}_U, \\mathcal{B}_V})_{ij} = A_{ij}\\) 이다.\n\n\n\n명제 8 정해진 기저에 대해 벡터와 선형사상의 행렬표현은 유일하다.\n\n\n\n명제 9 정의 9 의 정의, 표기법과 일반적인 행렬의 합과 스칼라곱, 행렬간 곱 연산에 대해\n\\[\nT(u) =v \\iff [T]_{\\mathcal{B}_U, \\mathcal{B}_V} [u]_{\\mathcal{B}_U} = [v]_{\\mathcal{B}_V}\n\\]\n가 성립한다. \\(T,\\,S\\in \\mathcal{L}(U, V)\\), \\(u_1,\\,u_2\\in U\\), \\(c\\in \\mathbb{F}\\) 에 대해\n\\[\n\\begin{aligned}\nT(u_1+cu_2) = v &\\iff [T]_{\\mathcal{B}_U,\\mathcal{B}_V}[u_1]_{\\mathcal{B}_U} + c[T]_{\\mathcal{B}_U,\\mathcal{B}_V}[u_2]_{\\mathcal{B}_U} = [v]_{\\mathcal{B}_V}, \\\\\n(T+cS)(u) = v &\\iff ([T]_{\\mathcal{B}_U,\\mathcal{B}_V}+c[S]_{\\mathcal{B}_U,\\mathcal{B}_V})[u]_{\\mathcal{B}_U} = [v]_{\\mathcal{B}_V}, \\\\\n\\end{aligned}\n\\]\n가 성립한다. \\(T\\in \\mathcal{L}(U, V),\\, S\\in \\mathcal{L}(V, W)\\) 이고 \\(\\mathcal{B}_U,\\, \\mathcal{B}_V,\\, \\mathcal{B}_W\\) 가 각각 \\(U, V, W\\) 의 기저 일 때,\n\\[\n(S \\circ T)(u) = w \\iff [S]_{\\mathcal{B}_V, \\mathcal{B}_W} [T]_{\\mathcal{B}_U, \\mathcal{B}_V} [u]_{\\mathcal{B}_U} = [w]_{\\mathcal{B}_W}\n\\]\n가 성립한다.\n\n\n\n명제 10 두 벡터공간 사이에 전단사 함수가 존재할 때 두 벡터공간이 동형 (isomorphic) 이라고 하며, 두 벡터공간 사이의 전단사 함수를 동형 사상(isomorphism) 이라고 한다. 두 벡터공간 \\(U,\\,V\\) 가 동형일 때 \\(U\\cong V\\) 로 표현한다.\n(\\(1\\)) 유한차원 벡터공간 \\(U,\\,V\\) 에 대해 다음이 성립한다.\n\\[\nU \\cong V \\iff \\dim(U) = \\dim (V).\n\\]\n(\\(2\\)) \\(n\\) 차원 \\(\\mathbb{F}\\)-벡터공간과 \\(\\mathcal{M}_n (\\mathbb{F})\\) 는 동형이다.\n(\\(3\\)) \\(n\\) 차원 \\(\\mathbb{F}\\)-벡터공간 \\(U\\) 와 \\(m\\) 차원 \\(\\mathbb{F}\\)-벡터공간 \\(V\\) 사이의 선형사상의 집합 \\(\\mathcal{L}(U, V)\\) 와 \\(\\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 는 동형이다.\n\n\n\n명제 11 벡터와 선형사상은 그 행렬 표현과 본질적으로 같다.\n\n\n\n정의 10 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대해 \\(\\ker (\\boldsymbol{A})\\), \\(\\text{im}\\, (\\boldsymbol{A})\\), \\(\\text{rank}\\, (\\boldsymbol{A})\\), \\(\\text{nuliity}(\\boldsymbol{A})\\) 는 다음과 같이 정의된다.\n\\[\n\\begin{aligned}\n\\ker (\\boldsymbol{A}) &= \\{\\boldsymbol{v}\\in \\mathcal{M}_n(\\mathbb{F}) : \\boldsymbol{Av}=\\boldsymbol{0} \\}, \\\\\n\\text{im}\\, (\\boldsymbol{A}) &= \\{\\boldsymbol{Av}: \\boldsymbol{v}\\in \\mathcal{M}_n(\\mathbb{F})\\}, \\\\\n\\text{rank}\\, (\\boldsymbol{A}) &= \\dim (\\text{im}\\, (\\boldsymbol{A})), \\\\\n\\text{nullity}\\, (\\boldsymbol{A}) & = \\dim (\\ker (\\boldsymbol{A})).\n\\end{aligned}\n\\]\n\n\n\n명제 12 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대해 \\(\\ker (\\boldsymbol{A})\\) 는 \\(\\mathcal{M}_n (\\mathbb{F})\\) 의 부분공간이며 \\(\\text{im}\\, (\\boldsymbol{A})\\) 는 \\(\\mathcal{M}_{m}(\\mathbb{F})\\) 의 부분공간이다. 또한 다음이 성립한다.\n\\[\n\\dim (\\mathcal{M}_m(\\mathbb{F})) = \\text{rank}\\, (\\boldsymbol{A}) + \\text{nullity}\\, (\\boldsymbol{A}).\n\\]\n\n\n\n정의 11 (행렬식) 행렬식 \\(\\det :\\mathcal{M}_{n \\times n}(\\mathbb{F}) \\to \\mathbb{F}\\) 은 다음과 같이 정의된 함수이다. 식 4 에 관한 사항들은 선형대수학 책을 참고하라\n\\[\n\\det(\\boldsymbol{A}) = \\sum_{\\sigma \\in S_n} \\text{sgn}(\\sigma)\\left(\\prod_{i=1}^n A_{i\\sigma(i)}\\right)\n\\tag{4}\\]\n\n\n\n명제 13 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 와 \\(c\\in \\mathbb{F}\\) 에 대해 다음이 성립한다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 의 서로 다른 두 행이나 두 열의 위치를 바꾼 행렬을 \\(\\boldsymbol{A}_1\\) 이라 할 때 \\(\\det(\\boldsymbol{A}_1) = -\\det (\\boldsymbol{A})\\) 이다.\n  (\\(2\\)) \\(\\boldsymbol{A}\\) 의 한 행 혹은 한 열에 상수 \\(c\\) 가 곱해진 행렬을 \\(\\boldsymbol{A}_2\\) 라 할 때 \\(\\det(\\boldsymbol{A}_2) = c\\det(\\boldsymbol{A})\\) 이다.\n  (\\(3\\)) \\(\\boldsymbol{A}\\) 의 한 행이 다른 행의 상수곱이거나 한 열이 다른 열의 상수곱이면 \\(\\det (\\boldsymbol{A}) = 0\\) 이다.\n  (\\(4\\)) \\(\\det(\\boldsymbol{A}^T) = \\det(\\boldsymbol{A})\\) 이다.\n  (\\(5\\)) \\(\\det(\\boldsymbol{AB}) = \\det(\\boldsymbol{A}) \\det(\\boldsymbol{B})\\) 이다.\n\n\n\n정의 12 (항등행렬과 역행렬) \\(n \\times n\\) 행렬을 정사각 행렬(square matrix) 이라고 한다. \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 가 \\(A_{ii}=1\\), \\((i=1,\\ldots,\\,n)\\) 이며 나머지 성분이 \\(0\\) 일 때 항등 행렬 (Identity matrix) 라고 하며 \\(\\boldsymbol{I}_n\\) 으로 표기한다. 행렬의 크기를 구체적으로 표기할 필요가 없을 때는 \\(\\boldsymbol{I}\\) 라고 표기한다.\n\\(\\boldsymbol{X}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 에 대해 어떤 행렬 \\(\\boldsymbol{Y}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 가 존재하여 \\(\\boldsymbol{XY}=\\boldsymbol{YX}=\\boldsymbol{I}_n\\) 일 때 \\(\\boldsymbol{Y}\\) 를 \\(\\boldsymbol{X}\\) 의 역행렬 (inverse matrix) 라고 하며 행렬 \\(\\boldsymbol{A}\\) 의 역행렬은 \\(\\boldsymbol{A}^{-1}\\) 로 표기한다. 역행렬이 존재하는 행렬을 가역 행렬 이라고 한다.\n\n\n\n명제 14 \\(\\boldsymbol{A},\\,\\boldsymbol{B}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 와 \\(c\\in \\mathbb{F}\\) 에 대해 다음이 성립한다.\n  (\\(1\\)) \\((\\boldsymbol{A}^{-1})^{-1} =\\boldsymbol{A}\\),\n  (\\(2\\)) \\((c\\boldsymbol{A})^{-1} = \\dfrac{1}{c} \\boldsymbol{A}^{-1}\\),\n  (\\(3\\)) \\((\\boldsymbol{AB}^{-1}) =\\boldsymbol{B}^{-1}\\boldsymbol{A}^{-1}\\).\n  (\\(4\\)) \\(\\det(\\boldsymbol{A}^{-1}) = \\dfrac{1}{\\det (\\boldsymbol{A})}\\)\n\n\n\n명제 15 정사각 행렬 \\(\\boldsymbol{A}\\) 가 가역행렬일 필요충분조건은 \\(\\det (\\boldsymbol{A}) \\ne 0\\) 이다.\n\n\n\n명제 16 \\(\\boldsymbol{A} \\in \\mathcal{M}_{m\\times n}(\\mathbb{F})\\) 과 \\(\\boldsymbol{x}\\in \\mathcal{M}_n (\\mathbb{F})\\), \\(\\boldsymbol{y} \\in \\mathcal{M}_m (\\mathbb{F})\\), 그리고 가역행렬 \\(\\boldsymbol{S}\\in \\mathcal{M}_{m \\times m} (\\mathbb{F})\\) 에 대해 다음이 성립한다.\n\\[\n\\boldsymbol{Ax}=\\boldsymbol{y} \\iff \\boldsymbol{SAx} = \\boldsymbol{Sy}\n\\]\n\n\n\n명제 17 \\(\\{\\boldsymbol{v}_1,\\ldots,\\,\\boldsymbol{v}_n \\}\\) 가 \\(\\mathcal{M}_n(\\mathbb{F})\\) 의 기저이며 \\(\\boldsymbol{P}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 가 가역이면 \\(\\{\\boldsymbol{Pv}_i : i=1,\\ldots,\\,n\\}\\) 도 \\(\\mathcal{M}_n(\\mathbb{F})\\) 의 기저이다.\n\n\n\n정의 13 두 정사각 행렬 \\(\\boldsymbol{A},\\, \\boldsymbol{B}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 에 대해 어떤 가역 행렬 \\(\\boldsymbol{P}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 가 존재하여 \\(\\boldsymbol{A}= \\boldsymbol{PBP}^{-1}\\) 일 때 두 행렬을 닮은 행렬 이라고 한다. 행렬 \\(\\boldsymbol{A}\\) 와 가역행렬 \\(\\boldsymbol{P}\\) 에 대해 \\(\\boldsymbol{PAP}^{-1}\\) 로 바꾸는 것을 닮음 변환 (similar transform) 이라고 한다.\n\n\n\n명제 18 닮음 변환은 기저의 변환이다. \\(\\mathcal{B} = \\{u_1,\\ldots,\\,u_n\\}\\), 가 벡터공간 \\(U\\) 의 기저라고 하고 \\(T\\in \\mathcal{L}(U)\\) 에 대해 \\([T]_{\\mathcal{B}} = \\boldsymbol{A}\\) 라고 하자. \\([u_i]_{\\mathcal{B}}= \\hat{\\boldsymbol{e}}_i\\) 이다. \\(U\\) 의 다른 기저 \\(\\mathcal{B}' = \\{u_1', \\ldots,\\, u_n'\\}\\) 에 대해 \\(\\boldsymbol{p}_i = [u'_i]_{\\mathcal{B}}\\) 를 \\(i\\) 번째 열벡터로 갖는 행렬을 \\(\\boldsymbol{P}\\) 라고 하자. 이 때 \\(\\boldsymbol{PAP}^{-1} = [T]_{\\mathcal{B}'}\\) 이다.\n\n\n\n정의 14 (내적과 노름) \\(\\mathbb{F}\\) 벡터공간 \\(V\\) 에서 다음을 만족하는 함수 \\(\\langle \\,, \\,\\rangle : V \\times V \\to \\mathbb{F}\\) 를 내적(inner product) 이라고 한다.\n  (\\(1\\)) \\(\\langle v,v\\rangle \\ge 0\\),\n  (\\(2\\)) \\(\\langle v,v \\rangle = 0 \\iff v=0_V\\),\n  (\\(3\\)) \\(\\langle u + u',v\\rangle = \\langle u, u\\rangle + \\langle u', u\\rangle\\), \\(\\langle u, v + v'\\rangle = \\langle u, v\\rangle + \\langle u, v'\\rangle\\),\n  (\\(5\\)) \\(c\\in \\mathbb{F}\\) 에 대해 \\(\\langle cu,v\\rangle = c\\langle u, v\\rangle\\), \\(\\langle u, cv\\rangle = \\overline{c} \\langle u, v\\rangle\\),\n  (\\(6\\)) \\(\\langle u, v\\rangle = \\overline{\\langle v, u\\rangle}\\). \\(\\mathbb{R}\\)-내적벡터공간인 경우 \\(\\langle u, v\\rangle =\\langle v, u\\rangle\\)\n내적이 부여된 벡터공간을 내적벡터공간 이라고 한다. 두 백터의 내적이 \\(0\\) 일 때 두 벡터는 서로 직교한다(perpendicular, orthogonal) 라고 한다.\n내적벡터 공간에서 거리함수(노름, norm) \\(\\|\\, \\|:V \\to [0, \\infty)\\) 를\n\\[\n\\|v\\|=\\sqrt{\\langle v, v\\rangle}\n\\tag{5}\\]\n로 정의 할 수 있다.\n\n\n\n명제 19 \\(\\mathbb{F}\\)-내적벡터공간의 거리 함수에 대해 다음이 성립한다.\n  (\\(1\\)) \\(\\|v\\|\\ge 0\\),\n  (\\(2\\)) \\(\\|v\\|=0 \\iff v=0_V\\),\n  (\\(3\\)) \\(c \\in \\mathbb{F}\\) 에 대해 \\(\\|cv\\|= |c|\\|v\\|\\),\n  (\\(4\\)) \\(\\|u+v\\| \\le \\|u\\| + \\|v\\|\\).\n\n\n\n명제 20 \\(\\mathbb{F}\\)-내적벡터공간의 내적과 거리함수에 대해 다음이 성립한다.\n  (\\(1\\)) 피타고라스 정리 : \\(\\langle u,v\\rangle = 0 \\iff \\|u+v\\|^2 = \\|u\\|^2 + \\|v\\|^2\\),\n  (\\(2\\)) 코시-슈바르츠 부등식 : \\(| \\langle u,v\\rangle | \\le \\|u\\| \\|v\\|\\),\n  (\\(3\\)) 삼각부등식 : \\(\\|u+ v\\| \\le \\|u\\| + \\|v\\|\\),\n  (\\(4\\)) 평행사변형 공식 : \\(\\|u+v\\|^2 + \\|u-v\\|^2 = 2\\|u\\|^2 + 2\\|v\\|^2\\).\n\n\n\n정의 15 (고유값, 고유벡터, 고유공간) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{m \\times n}(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Av}=\\lambda \\boldsymbol{v}\\) 를 만족하는 \\(\\lambda \\in \\mathbb{F}\\) 와 \\(\\boldsymbol{0}\\) 이 아닌 \\(\\boldsymbol{v}\\in \\mathcal{M}_n (\\mathbb{F})\\) 가 존재할 때 \\(\\lambda\\) 를 \\(\\boldsymbol{A}\\) 의 고유값 (eigen value) 이라고 하고 \\(\\boldsymbol{v}\\) 를 고유값 \\(\\lambda\\) 에 대한 \\(\\boldsymbol{A}\\) 의 고유 벡터 (eigne vector) 라고 한다. 고유값 \\(\\lambda\\) 를 갖는 고유벡터의 집합과 \\(\\{\\boldsymbol{0}\\}\\) 의 합집합을 고유값 \\(\\lambda\\) 에 대해 \\(\\boldsymbol{A}\\) 의 고유 공간 (eigenspace) 라고 하며, \\(E(\\lambda, \\boldsymbol{A})\\) 라고 표기한다.\n\n\n\n정의 16 (특성다항식) 정사각 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 에 대해 \\(p_\\boldsymbol{A}(\\lambda) = \\det(\\lambda \\boldsymbol{I}_n -\\boldsymbol{A})\\) 는 \\(\\lambda\\) 에 대한 \\(n\\)-차 다항식으로 행렬 \\(\\boldsymbol{A}\\) 의 특성다항식 (characteristic polynomial) 이라 한다.\n\n\n\n명제 21 \\(\\lambda \\in \\mathbb{F}\\) 가 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 의 고유값이기 위한 필요충분조건은 \\(p_{\\boldsymbol{A}}(\\lambda) = 0\\) 인 것이다.\n\n\n\n명제 22 복소수체에서 정의된 정사각 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n\\times n}(\\mathbb{C})\\) 에 대한 고유값이 항상 존재한다.\n\n\n\n명제 23 \\(\\mathbb{F}\\)-내적 벡터 공간에서 서로 다른 고유값을 갖는 고유벡터들의 집합은 선형독립이다.\n\n\n\n정의 17 (정규직교기저와 표준기저) \\(\\{\\boldsymbol{v}_1,\\ldots,\\,\\boldsymbol{v}_n\\}\\) 이 벡터공간 \\(V\\) 의 기저이며 \\(\\langle \\boldsymbol{v}_i,\\,\\boldsymbol{v}_j\\rangle = \\delta_{ij}\\) 일 때 \\(\\{\\boldsymbol{v}_1,\\ldots,\\,\\boldsymbol{v}_n\\}\\) 를 \\(V\\) 의 정규직교기저 (orthonormal basis) 라고 한다. 벡터공간 \\(\\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\hat{\\boldsymbol{e}}_i \\in \\mathcal{M}_n (\\mathbb{F})\\) 를 \\((\\hat{\\boldsymbol{e}}_i)_j = \\delta_{ij}\\) 로 정의하자. 이 때 \\(\\{\\hat{\\boldsymbol{e}}_1, \\ldots, \\hat{\\boldsymbol{e}}_n\\}\\) 는 \\(\\mathcal{M}_n(\\mathbb{F})\\) 의 정규직교기저이며 특히 표준 기저 (standard basis) 라고 한다.\n\n\n\n명제 24 \\(\\mathbb{F}\\)-벡터공간 \\(V\\) 의 정규직교기저 \\(\\mathcal{B}_V = \\{v_1,\\ldots,\\,v_n\\}\\) 에 대해 \\(v=\\sum_{i} a_i v_i\\) 라면 \\(a_i = \\langle v,\\,v_i\\rangle\\) 이다. 즉,\n\\[\nv = \\sum_{i} \\langle v,\\, v_i\\rangle v_i\n\\]\n이다.\n\n\n\n명제 25 유한차원 내적벡터공간에서는 기저로부터 항상 정규직교기저를 얻을 수 있다. 그중 한 가지 방법이 그람-슈미트(Gram-Schmidt) 방법이다\n\n\n\n명제 26 (슈어 정리 (Schur’s Theorem)) 유한차원 \\(\\mathbb{C}\\)-내적벡터공간 \\(V\\) 에서 정의된 연산자 \\(T\\in \\mathcal{L}(V)\\) 는 어떤 정규직교기저에서 상삼각 행렬로 표현된다.\n\n\n\n명제 27 \\(\\mathbb{R}\\)-내적공간 \\(V\\) 의 정규직교 기저 \\(\\mathcal{B}_V\\) 에 대한 벡터 \\(u, v\\) 의 행렬표현 \\(\\boldsymbol{u} = [u]_{\\mathcal{B}_V},\\, \\boldsymbol{v} = [v]_{\\mathcal{B}_V}\\) 에 대해 \\(\\langle u, v\\rangle = \\boldsymbol{v}^T\\boldsymbol{u}\\) 이다. \\(V\\) 가 \\(\\mathbb{C}\\)-내적공간일 경우 \\(\\langle u, v\\rangle = \\boldsymbol{v}^\\ast\\boldsymbol{u}\\) 이다.\n\n\n\n명제 28 \\(\\boldsymbol{u},\\,\\boldsymbol{v}\\in \\mathcal{M}_n(\\mathbb{F})\\), \\(\\boldsymbol{A} \\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 와 \\(\\boldsymbol{A}\\) 의 수반행렬 \\(\\boldsymbol{A}^\\ast\\) 에 대해 다음이 성립한다.\n\\[\n\\langle \\boldsymbol{Au}, \\boldsymbol{v}\\rangle = \\langle \\boldsymbol{u}, \\boldsymbol{A}^\\ast \\boldsymbol{v}\\rangle\n\\]\n\n\n\n정의 18 \\(\\boldsymbol{S}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 가 모든 \\(\\boldsymbol{v}\\in \\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\|\\boldsymbol{Sv}\\| = \\|\\boldsymbol{v}\\|\\) 이면 \\(\\boldsymbol{S}\\) 를 Isometry 라고 한다. \\(\\mathbb{F} =\\mathbb{R}\\) 일 때 직교 행렬(orthogonal matrix) 이라고 하며 \\(\\mathbb{F}=\\mathbb{C}\\) 일 때 유니타리 행렬(unitary matrix) 라고 한다. 직교 행렬에 의한 닮음변환을 직교 변환 (orthogonal transformation) 이라고 하며, 유니타리 행렬에 의한 닮음변환을 유니타리 변환 (unitary transformation) 이라고 한다.\n\n\n\n명제 29 \\(\\boldsymbol{S}\\) 가 Isometry 일 때 다음이 성립한다.\n  (\\(1\\)) \\(\\{\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_n\\}\\) 이 정규직교기저일 때 \\(\\{\\boldsymbol{Sv}_1,\\ldots,\\boldsymbol{Sv}_n\\}\\) 도 정규직교기저이다.\n  (\\(2\\)) \\(\\boldsymbol{S}^{-1}= \\boldsymbol{S}^\\ast\\) 이다. 따라서 \\(\\boldsymbol{O}\\) 가 직교행렬이면 \\(\\boldsymbol{O}^{-1}=\\boldsymbol{O}\\) 이다.\n  (\\(3\\)) 두 isometry 의 곱은 isometry 이다.\n\n\n\n정의 19 정사각 행렬 \\(\\boldsymbol{A} \\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 가 \\(\\boldsymbol{AA}^\\ast = \\boldsymbol{A}^\\ast\\boldsymbol{A}\\) 일 때 이 행렬을 정규 행렬 (normal matrix) 라고 한다.\n\n\n\n명제 30 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 가 정규행렬일 때 다음이 성립한다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 가 정규행렬일 필요충분조건은 모든 \\(\\boldsymbol{v}\\in \\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\|\\boldsymbol{Av}\\|=\\|\\boldsymbol{A}^\\ast\\boldsymbol{v}\\|\\) 이다.\n  (\\(2\\)) \\(\\boldsymbol{v}\\) 가 공유값 \\(\\lambda\\) 를 갖는 \\(\\boldsymbol{A}\\) 의 고유벡터이면 고유값 \\(\\overline{\\lambda}\\) 를 갖는 \\(\\boldsymbol{A}^\\ast\\) 의 고유벡터이다.\n  (\\(3\\)) 서로 다른 고유값을 갖는 \\(\\boldsymbol{A}\\) 의 고유벡터는 직교한다.\n  (\\(4\\)) \\(\\boldsymbol{A}\\) 가 복소행렬일 때 상삼각행렬 꼴은 대각행렬이다.\\(^\\ast\\)\\(^\\ast\\) 슈어 정리 에 의해 항상 상삼각 행렬 꼴로 표현할 수 있음을 안다.\n\n\n\n명제 31 (복소수체에서 정의된 행렬의 스펙트럼 정리) \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{C})\\) 일 때 \\(\\boldsymbol{A}^\\ast = \\boldsymbol{A}\\) 인 행렬을 에르미트 행렬이라고 한다. 에르미트 행렬은 정규행렬이다. 에르미트 행렬에 대해 다음이 성립한다.\n  (\\(1\\)) 에르미트 행렬의 고유값은 실수이다.\n  (\\(2\\)) 서로 다른 고유값을 갖는 에르미트 행렬의 고유벡터는 직교한다.\n  (\\(3\\)) 에르미트 행렬의 고유벡터로 정규직교기저를 구성 할 수 있다.\n  (\\(4\\)) 에르미트 행렬은 유니타리 변환에 의해 대각행렬이 된다. 이 대각행렬의 대각성분이 고유값이다.\n\n\n\n명제 32 (실수체에서 정의된 행렬의 스펙트럼 정리) \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 일 때 \\(\\boldsymbol{A}^T= \\boldsymbol{A}\\) 인 행렬을 대칭 행렬이라고 한다. 대칭 행렬은 정규행렬이다. 대칭 행렬에 대해 다음이 성립한다.\n  (\\(2\\)) 서로 다른 고유값을 갖는 에르미트 행렬의 고유벡터는 직교한다.\n  (\\(3\\)) 에르미트 행렬의 고유벡터로 정규직교기저를 구성 할 수 있다.\n  (\\(4\\)) 정규직교행렬은 직교 변환에 의해 대각행렬이다. 이 대각행렬의 대각성분이 고유값이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-summary_of_calculus",
    "href": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-summary_of_calculus",
    "title": "수학에 관련된 표기법과 명제들",
    "section": "3 미적분학 정리",
    "text": "3 미적분학 정리\n\n\n정의 20 \\(a&lt;b\\) 일 때 아래와 같이 정의된 \\((a, b)\\) 와 \\([a, b]\\) 를 각각 열린 구간 (open interval), 닫힌 구간 (closed interval) 이라 한다.\n\\[\n\\begin{aligned}\n(a, b) & = \\{x\\in \\mathbb{R} : a&lt;x&lt;b\\}, \\\\\n[a, b] & = \\{x \\in \\mathbb{R} : a \\le x \\le b\\}.\n\\end{aligned}\n\\]\n\n\n\n정의 21 실수의 집합 \\(X\\) 에 대해 어떤 \\(M\\in \\mathbb{R}\\) 이 존재하여 \\(x\\in X \\implies x \\le M\\) 일 때 \\(X\\) 는 위로 유계 라고 한다. 어떤 \\(m\\in \\mathbb{R}\\) 이 존재하여 \\(x\\in X \\implies x \\ge m\\) 일 때 \\(X\\) 는 아래로 유계 라고 한다. \\(X\\) 가 위로도 아래로도 유계이면 유계 라고 한다.\n\n\n\n정의 22 집합 \\(A\\) 에 대해 양의 정수 \\(\\mathbb{Z}_+\\) 에서 \\(A\\) 로의 함수를 수열 (sequence) 라고 한다. \\(a:\\mathbb{Z}_+ \\to A\\) 일 때 \\(a(n)\\) 을 관례적으로 \\(a_n\\) 이라고 쓰며 \\(\\langle a_n \\rangle\\) 은 \\((a_1,\\,a_2,\\ldots,)\\) 를 의미한다.\n\n\n\n정의 23 (수열의 극한) 수열 \\(\\langle a_n\\rangle = (a_1,\\,a_2,\\ldots)\\) 이 \\(a\\) 로 수렴한다는 것은 임의의 실수 \\(\\epsilon&gt;0\\) 에 대해 어떤 자연수 \\(N\\) 이 존재하여\n\\[\nn&gt;N \\implies |a_n -a |&lt;\\epsilon\n\\]\n을 만족하는 것이며, \\((a_n)\\) 이 \\(a\\) 로 수렴 할 때\n\\[\n\\lim_{n\\to \\infty} a_n = a\n\\]\n라 표기한다. 수열이 수렴하지 않을 때는 발산한다라고 한다.\n\n\n\n정의 24 (함수의 극한과 연속성) 함수 \\(f:X\\subset \\mathbb{R} \\to \\mathbb{R}\\) 을 생각하자. 함수 \\(f\\) 가 \\(x_0 \\in X\\) 에서 \\(L\\) 로 수렴한다는 것은 임의의 \\(\\epsilon&gt;0\\) 에 대해 어떤 \\(\\delta&gt;0\\) 이 존재하여\n\\[\n|x-x_0 |&lt; \\delta \\implies |f(x)-L|&lt; \\epsilon\n\\]\n인 것이다. 이 때,\n\\[\n\\lim_{x \\to x_0} f(x) = L\n\\]\n이라 쓴다. 만약\n\\[\n\\lim_{x \\to x_0} f(x) = f(x_0)\n\\]\n이면 \\(f\\) 는 \\(x_0\\) 에서 연속이라고 하며, \\(f\\) 가 모든 \\(x\\in X\\) 에 대해 연속일 때 \\(f\\) 를 연속함수라 한다. 어떤 구간 \\(I\\) 에서 연속인 함수의 집합을 \\(C_I\\) 라고 쓴다. 특별히 닫힌 구간 \\([a,\\,b]\\) 에서 정의된 함수 \\(f\\) 에 대해 \\(f\\) 가 \\((a,\\,b)\\) 에서 연속이며 \\(\\lim_{x\\to a+} f(x)=f(a)\\) 이고 \\(\\lim_{x \\to b-} f(x) = f(b)\\) 이면 \\(f\\) 는 \\([a,\\,b]\\) 에서 연속이라고 한다.\n\n\n\n명제 33 (최대최소정리) 함수 \\(f\\) 가 닫힌 구간 \\([a,\\,b]\\) 에서 연속이라면 \\(\\{f(x):x\\in [a,\\,b]\\}\\) 는 최소값과 최대값을 가진다.\n\n\n\n정의 25 (함수의 미분) 함수 \\(f:X\\subset \\mathbb{R} \\to \\mathbb{R}\\) 에 대해 \\(x_0\\) 에서 미분가능하다는 것은 극한\n\\[\n\\lim_{h \\to 0}\\dfrac{f(a+h)-f(a)}{h}\n\\]\n이 존재한다는 것이며 위의 극한값을 \\(f'(a)\\) 라고 쓴다. 함수 \\(f\\) 가 모든 \\(x\\in X\\) 에 대해 미분 가능 할 때 \\(f\\) 를 미분가능함수라고 한다.\n\n\n\n정의 26 (도함수) 함수 \\(f:X \\subset \\mathbb{R} \\to \\mathbb{R}\\) 이 미분 가능 할 때 \\(f'(x)\\) 는 \\(X\\) 에서 정의된 함수이며 이를 \\(f\\) 의 도함수 혹은 1차 도함수라고 한다. \\(f'(x)\\) 가 미분가능한 함수 일 때 \\(f'(x)\\) 의 도함수를 \\(f''(x)\\) 혹은 \\(f^{(2)}(x)\\) 라고 쓰며 \\(f\\) 의 2차 도함수라고 한다. 같은 방법으로 \\(f\\) 함수에 대한 \\(n\\) 차 도함수를 정의할 수 있으며 \\(f^{(n)}(x)\\) 라고 쓴다. 여러 차수의 도함수를 나열할 경우 원래의 함수를 \\(f^{(0)}\\), 1 차 도함수를 \\(f^{(1)}\\) 로 쓴다.\n\n\n\n정의 27 (\\(C^n_I\\)) 구간 \\(I\\) 에서 \\(n\\) 번 미분 가능하며, 그 \\(n\\) 차 도함수가 연속인 함수의 집합을 \\(C^n_I\\) 라고 한다. 구간이 실수 전체일 경우는 \\(C^n\\) 이라고 한다. \\(e^x\\) 함수의 경우와 같이 실수 전체 영역에서 무한번 미분 가능한 함수의 집합을 \\(C^{\\infty}\\) 라고 한다.\n\n\n\n명제 34 (롤의 정리 (Roll’s theorem)) \\(f\\in C[a,\\,b]\\) 이고 \\(f\\) 가 \\((a,\\,b)\\) 구간에서 미분가능하다고 하자. \\(f(a)=f(b)\\) 이면 \\(f'(c)=0\\) 을 만족하는 \\(c\\in (a,\\,b)\\) 가 존재한다.\n\n\n\n명제 35 (일반화된 롤의 정리) \\(f\\in C^{n-2}[a,\\,b]\\) 이고 \\(f\\) 가 \\((a,\\,b)\\) 구간에서 \\(n-1\\) 번 미분 가능하며 \\(n\\) 개의 서로 다른 \\(x_1,\\ldots,\\,x_n\\) 에서 \\(f(x_i)=0\\) 일 때, \\(f^{(n-1)}(\\xi) = 0\\) 인 \\(\\xi\\in (a,\\,b)\\) 가 존재한다.\n\n\n\n명제 36 (중간값 정리 (Intermediate value theorem)) \\([a,\\,b]\\) 를 포함하는 구간에서 연속인 함수 \\(f:X\\to \\mathbb{R}\\) 에 대해 \\(d\\) 가 \\(f(a)\\) 와 \\(f(b)\\) 사이의 값이면, 즉 \\(f(a)&lt; d &lt; f(b)\\) 이거나 \\(f(b)&lt;d &lt;f(a)\\) 라면 \\[\nf(c) = d\n\\]\n인 \\(c\\) 가 \\((a,\\,b)\\) 안에 항상 존재한다.\n\n\n\n명제 37 (따름정리 : 여러 점의 경우) \\([a,\\,b]\\) 를 포함하는 구간에서 연속인 함수 \\(f:X \\to \\mathbb{R}\\) 에 대해 \\(\\{x_1,\\ldots,\\,x_n\\}\\subset [a,\\,b]\\) 일 때\n\\[\nf(c) = \\dfrac{f(x_1)+ \\cdots + f(x_n)}{n}\n\\]\n을 만족하는 \\(c\\in [a,\\,b]\\) 가 항상 존재한다.\n\n\n\n명제 38 (평균값 정리 (Mean value theorem)) 함수 \\(f:X \\subset\\mathbb{R} \\to \\mathbb{R}\\) 이 \\([a,\\,b]\\) 를 포함하는 구간에서 에서 연속이고, \\((a,\\,b)\\) 에서 미분 가능하면 \\[\n\\dfrac{f(b)-f(a)}{b-a}=f'(c)\n\\]\n를 만족하는 \\(c\\in (a,\\,b)\\) 가 존재한다.\n\n\n\n명제 39 (일변수 함수에 대한 테일러 정리) \\(a\\) 를 포함하는 열린구간 \\(I\\) 에서 정의된 함수 \\(f:I \\to \\mathbb{R}\\) 가 \\(n+1\\) 번 미분 가능한 함수일 때 임의의 \\(x\\in I\\) 에 대하여\n\\[\nf(x) = \\sum_{k=0}^{n} \\dfrac{f^{(k)}(a)}{k!} (x-a)^k + \\dfrac{f^{(n+1)}(\\xi)}{(n+1)!}(x-a)^{n+1}\n\\]\n을 만족하는 \\(\\xi \\in I\\) 가 존재한다. 이 때 \\(\\displaystyle \\sum_{k=0}^{n} \\dfrac{f^{(k)}}{k!} (x-a)^k\\) 를 \\(n\\) 차 테일러 다항식이라고 하며, \\(\\displaystyle \\dfrac{f^{(n+1)}(\\xi)}{(n+1)!}(x-a)^{n+1}\\) 를 나머지라고 한다.\n\n\n\n정의 28 구간 \\([a,\\,b]\\) 에서 정의된 함수 \\(f\\) 를 생각하자. 수열 $x_n$ 는 \\(x_1=a&lt;x_2&lt;\\cdots &lt;x_n=b\\) 를 만족하는 수열 일 때,\n\\[\n\\begin{aligned}\n&\\lim_{n \\to \\infty} \\sum_{k=2}^n \\min(\\{f(x_{i-1}),\\, f(x_{i})\\}) (x_{i}-x_{i-1})  \\\\\n&\\qquad \\qquad \\qquad = \\lim_{n \\to \\infty} \\sum_{k=2}^n \\max(\\{f(x_{i-1}),\\, f(x_{i})\\}) (x_{i}-x_{i-1})\n\\end{aligned}\n\\]\n라면 함수 \\(f\\) 는 \\([a,\\,b]\\) 구간에서 리만 적분 가능하다고 하며 위의 값을\n\\[\n\\int_{a}^b f \\, dx\n\\] 라고 쓴다.\n\n\n\n명제 40 \\([a,\\,b]\\) 구간에서 연속인 함수는 리만 적분 가능하다.\n\n\n\n명제 41 (미적분학의 제 1 기본 정리) \\(f:[a,b] \\to \\mathbb{R}\\)가 리만 적분 가능한 함수일 때, 함수 \\(g : [a,\\,b] \\to \\mathbb{R}\\) 을 다음과 같이 정의하자.\n\\[\ng(x) = \\int_a^x f(t)\\, dt.\n\\]\n이 때, \\(g(x)\\) 는 \\((a,\\,b)\\) 에서 미분 가능한 함수이며 원래 주어진 함수 \\(f(x)\\) 와는 다음의 관계를 만족힌다.\n\\[\n\\dfrac{d}{dx}g(x) = f(x).\n\\]\n이 경우 \\(g(x)\\) 를 \\(f(x)\\) 의 부정 적분(indefinite integral) 이라 한다.\n\n\n\n명제 42 \\(f[a,\\,b] \\to \\mathbb{R}\\) 이 리만적분 가능한 함수이며, \\(a'\\in [a,\\,b]\\) 라 하자. 이 때\n\\[\ng(x) = \\int_a^x f(t)\\, dt,\\qquad h(x) = \\int_{a'}^x f(t)\\, dt\n\\]\n라고 하면,\n\\[\ng(x)-h(x) = \\text{const}\n\\]\n이다.\n\n\n\n명제 43 (미적분학의 제 2 기본 정리) \\([a,\\,b]\\) 구간에서 적분가능한 함수 \\(f(x)\\) 의 부정적분이 \\(F(x)\\) 일 때 다음이 성립한다.\n\\[\n\\int_a^b f(x)\\, dx = F(b)-F(a).\n\\]\n\n\n\n명제 44 (적분에 대한 평균값 정리 (Mean value theorem for integrals)) 함수 \\(f:X \\subset\\mathbb{R} \\to \\mathbb{R}\\) 이 \\([a,\\,b]\\) 를 포함하는 구간에서 에서 연속이면 \\[\nf(c) = \\dfrac{1}{b-a}\\int_a^b f(x),\\,dx\n\\]\n를 만족하는 \\(c\\in (a,\\,b)\\) 가 존재한다.\n\n\n\n명제 45 (적분에 대한 가중 평균 정리 (Weighted mean value theorems for integrals)) 함수 \\(f:X \\subset\\mathbb{R} \\to \\mathbb{R}\\), \\(g:Y \\subset\\mathbb{R} \\to \\mathbb{R}\\) 이 \\([a,\\,b]\\) 를 포함하는 구간에서 에서 연속이면\n\\[\n\\int_a^b f(x)\\,g(x)\\, dx = f(c)\\int_a^b g(x)\\, dx\n\\]\n을 만족하는 \\(c\\in (a,\\,b)\\) 가 존재한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-transcription_ruls",
    "href": "src/numerical_analysis_using_julia/01x_notations_and_propositions.html#sec-transcription_ruls",
    "title": "수학에 관련된 표기법과 명제들",
    "section": "4 이 책에 사용할 행렬 표기의 규칙들",
    "text": "4 이 책에 사용할 행렬 표기의 규칙들\n수학과 프로그래밍 전체에서 행렬이 많이 사용된다. 여기서 행렬을 표현하는 데 사용한 몇가지 규칙을 나열한다. (J-3) 과 같은 항목은 Julia 의 규칙이며 (M-2) 와 같은 항목은 수학적인 표현에 대한 규칙이다. 두 표현의 번호가 같은 경우는 수학적인 표현에 대한 Julia 구현에 대한 규칙 혹은 설명을 의미한다.\n(J-0) 특별한 언급이 없을 경우 Julia 에서 정수형과 실수형은 각각 Int64, Float64 를 사용한다.\n(J-1) 기본적으로 코드상에서 행렬은 A, B 와 같은 대문자 혹은 A1 과 같은 대문자로 시작하는 변수명을 사용한다. Julia 에서 행렬 A 의 \\(i\\) 번째 행벡터는 A[i,:] 로, \\(j\\) 번째 열벡터는 A[:,j] 로 표현 할 수 있으므로 그대로 사용한다. 행렬 A 의 \\(i\\) 행 \\(j\\) 열 성분은 A[i, j] 이다. 벡터와 스칼라는 x, y, a, b 와 같은 소문자나 x_effective, b2 와 같이 소문자로 시작하는 변수명을 사용한다. x 가 벡터인 경우 \\(i\\) 번째 성분은 x[i] 이다.\n(J-2) 행렬 A 에 대한 전치행렬은 transpose(A), 수반행렬은 A' 나 adjoint(A) 로 얻을 수 있다.\n(J-5) Julia 에서는 Matlab의 eye() 나 numpy 의 np.identity() 혹은 np.eye() 와 같은 \\(n\\times n\\) 항등행렬을 위한 함수가 존재하지 않는다. 대신 LinearAlgebra 모듈의 uniform scaling operator I 를 임의의 크기와 임의의 원소 타입의 항등행렬로 사용할 수 있다. 타입과 크기는 다른 행렬과 계산할하는 등 필요할 때 정해진다.\nIn [1]: I+[2 3;4 2]\nOut[1]: 2×2 Matrix{Int64}:\n 3  3\n 4  3\n\nIn [2]: I-[1 2 3;3 4 5; 6 7 8]\nOut[2]: 3×3 Matrix{Int64}:\n  0  -2  -3\n -3  -3  -5\n -6  -7  -7\n필요할 경우에는 항등행렬을 아래와 같이 type을 직접 선언하여 만들 수 있다.\nMatrix{Int32}(I, 3, 3)      # Int32 타입의 3x3 항등행렬\nMatrix{Float64}(I, 5, 5)    # Float64 타입의 5x5 항등행렬\nMatrix{Bool}(I, 4, 4)       # Bool 타입의 4x4 항등행렬\n\\(\\mathbb{R}^{5 \\times 1}\\) 의 단위행렬 \\(\\boldsymbol{e}_3\\) 는 다음과 같이 얻을 수 있다.\ne_3 = Matrix{Float64}(I, 5, 5)[:,3]\n(M-6) \\(m\\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(m \\times k\\) 행렬 \\(\\boldsymbol{B}\\) 에 대해(두 행렬의 행의 갯수가 같음에 주의하라)) \\([\\boldsymbol{A}\\; \\boldsymbol{B}]\\) 는 \\(\\boldsymbol{A}\\) 행렬 옆에 \\(\\boldsymbol{B}\\) 행렬을 두는 \\(m \\times (n+k)\\) 행렬을 의미한다. \\(m\\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(l \\times n\\) 행렬 \\(\\boldsymbol{C}\\) 에 대해 (두 행렬의 열의 갯수가 동일함에 유의하라) \\([\\boldsymbol{A} \\,; \\boldsymbol{C}]\\) 는 \\(\\boldsymbol{A}\\) 행렬 아래에 \\(\\boldsymbol{C}\\) 행렬을 두는 \\((m+l)\\times n\\) 행렬이다. 아마 \\(\\begin{bmatrix} \\boldsymbol{A} \\\\ \\boldsymbol{C} \\end{bmatrix}\\) 와 동일하다고 하면 이해하기 쉬울 것이다. ; 기호는 julia 에서 열바뀜을 나타내므로 julia 와 어느정도 유사성이 있다 하겠다. 여기에 \\(l\\times k\\) 행렬 \\(\\boldsymbol{D}\\) 에 대해 \\(\\begin{bmatrix} \\boldsymbol{A} & \\boldsymbol{B} \\\\ \\boldsymbol{C} & \\boldsymbol{D} \\end{bmatrix}\\) 가 의미하는 것은 여러분이 쉽게 유츄 할 수 있을 것이다.\n(J-6) Julia 에서는 다음과 같이 사용 할 수 있다.\njulia&gt; A = [1 3;2 4];B=[3 2; 4 3];[A B]\n2×4 Matrix{Int64}:\n 1  3  3  2\n 2  4  4  3\n(M-7) \\(m\\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(m \\times k\\) 행렬 \\(\\boldsymbol{B}\\) 혹은 \\(m\\) 차원 벡터 \\(\\boldsymbol{b}\\) 에 대해 \\([\\boldsymbol{A} \\mid \\boldsymbol{B}]\\) 혹은 \\([\\boldsymbol{A} \\mid \\boldsymbol{b}]\\) 는 행렬에 대한 연산을 동시에 적용하기 위한 개념이다. 연산 \\(\\hat{L}[\\boldsymbol{A} \\mid \\boldsymbol{B}] = [\\hat{L}\\boldsymbol{A} \\mid \\hat{L}\\boldsymbol{B}]\\) 를 의미한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/02_linear_system.html",
    "href": "src/numerical_analysis_using_julia/02_linear_system.html",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "",
    "text": "이번 장에서는 본격적인 수치해석에 들어가기에 앞서 선형 시스템을 코딩을 통해 푸는 방법, 코딩에서 이루어지는 계산의 성능 분석과 다항식에 관한 객체를 만들어본다. 수학적 내용을 코드로 만들어 보고 이를 이용하여 문제를 풀어 보면서 선형대수학과 julia 언어에 대한 지식을 습득하게 된다. 그리고 다항식에 대한 객체는 이후 계속 사용하게 될 것이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/02_linear_system.html#선형-시스템과-선형-방정식",
    "href": "src/numerical_analysis_using_julia/02_linear_system.html#선형-시스템과-선형-방정식",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "1 선형 시스템과 선형 방정식",
    "text": "1 선형 시스템과 선형 방정식\n어떤 시스템이 \\(n\\) 개의 독립변수 \\(x_1,\\ldots,\\,x_n\\) 에 대해 아래와 같은 방정식으로 기술될 때 이 시스템을 선형 시스템이라고 한다. \\[\n\\begin{aligned}\nf_1 (x_1,\\ldots,\\,x_n ) &= A_{11}x_1 + \\cdots + A_{1n}x_n \\\\\n& \\vdots \\\\\nf_m (x_1,\\ldots,\\,x_n ) &= A_{m1}x_1 + \\cdots + A_{mn}x_n \\\\\n\\end{aligned}\n\\]\n이 시스템은 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(n \\times 1\\) 행렬 \\(\\boldsymbol{x}\\) 를 이용해 다음과 같은 식으로 정리 할 수 있다.\n\\[\nf_i(\\boldsymbol{x})=\\boldsymbol{Ax},\\qquad \\boldsymbol{A} = \\begin{bmatrix} A_{11} & \\cdots & A_{1n} \\\\ \\vdots & \\ddots & \\vdots \\\\ A_{m1} & \\cdots &A_{mn} \\end{bmatrix},\\qquad \\boldsymbol{x} = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_n \\end{bmatrix}\n\\]\n이 시스템이 선형시스템이라고 불리는 이유는 \\(\\boldsymbol{x}_1,\\,\\boldsymbol{x}_2 \\in \\mathcal{M}_n(\\mathbb{F})\\) 이며 \\(a\\) 가 상수 일 때,\n\\[\nf_i(\\boldsymbol{x}_1 + a \\boldsymbol{x}_2) = f_i(\\boldsymbol{x}_1) + af_i(\\boldsymbol{x}_2) = \\boldsymbol{Ax}_1 + a\\boldsymbol{Ax}_2\n\\]\n를 만족하기 때문이다.\n주어진 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 에 대해 \\(\\boldsymbol{A}\\) 의 커널 \\(\\ker (\\boldsymbol{A})\\) 와 이미지 \\(\\text{im}(\\boldsymbol{A})\\) 를 다음과 같이 정의한다.\n\\[\n\\begin{aligned}\n\\ker (\\boldsymbol{A}) &:= \\left\\{\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F}) : \\boldsymbol{Ax}=\\boldsymbol{0} \\right\\}, \\\\\n\\text{im}(\\boldsymbol{A}) &:= \\left\\{\\boldsymbol{Ax}: \\boldsymbol{x} \\in \\mathcal{M}_n(\\mathbb{F})\\right\\}\n\\end{aligned}\n\\]\n만약 \\(\\boldsymbol{b}\\in \\text{im}(\\boldsymbol{A})\\) 라면 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 가 존재하며 이 \\(\\boldsymbol{x}\\) 를 선형방정식 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 의 해(solution) 라고 한다. \\(\\boldsymbol{x}_0 \\in \\ker (\\boldsymbol{A})\\) 라면 \\(\\boldsymbol{A}(\\boldsymbol{x}+\\boldsymbol{x}_0) = \\boldsymbol{Ax}\\) 이다.\n\\(\\boldsymbol{A}\\) 가 \\(n \\times n\\) 정사각 행렬이며 \\(\\det (\\boldsymbol{A}) \\ne 0\\) 이면, 즉 \\(\\boldsymbol{A}\\) 의 역행렬이 존재한다면 선형방정식의 해는 유일하게 존재하며 \\(\\boldsymbol{x}=\\boldsymbol{A}^{-1}\\boldsymbol{b}\\) 를 통해 구할 수 있다. 역행렬이 존재하지 않는 정사각 행렬을 특이 행렬 (singular matrix) 라고 한다. \\(\\boldsymbol{A}\\) 가 특이행렬이라면 선형방정식의 해는 존재하지 않거나, 그 해가 무수히 많이 존재한다. 예를 들어\n\\[\n\\boldsymbol{A}=\\begin{bmatrix} 1 & 1 \\\\ 0 & 0 \\end{bmatrix}, \\qquad \\boldsymbol{b}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\]\n의 해는 \\(\\begin{bmatrix} x \\\\ 1-x\\end{bmatrix},\\, x\\in \\mathbb{F}\\) 인 모든 행렬이다.\n\n\n\n\n\n\n\n노트\n\n\n\n다음부터 소개할 여러가지 방법은 LinearAlgebra 모듈에 그 기능이 거의 포함되어 있기으며 아마 직접 코딩하는 것보다 처리속도가 더 빠를 것이다. 그러나 우리가 배워야 할 것은 모듈과 함수의 사용법 뿐만 아니라, 생각하는 알고리즘을 코드로 만들어 정확하게 구현하는 것이기에 앞으로 나올 여려 방법들을 직접 구현해보고자 한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/02_linear_system.html#상삼각-행렬과-하삼각-행렬과-선형방정식",
    "href": "src/numerical_analysis_using_julia/02_linear_system.html#상삼각-행렬과-하삼각-행렬과-선형방정식",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "2 상삼각 행렬과 하삼각 행렬과 선형방정식",
    "text": "2 상삼각 행렬과 하삼각 행렬과 선형방정식\n선형 시스템 가운데 비교적 단순한 상삼각 행렬과 하삼각 행렬에 대해 알아보자. 상삼각 행렬이나 하삼각 행렬의 선형방정식은 단순하지만 복잡한 선형 시스템을 푸는 기반이 된다. 이에 관련된 것은 LU 분해 에서 다루기로 한다\n\\(n\\times n\\) 정사각 행렬에 대해 상삼각 행렬(upper triangular matrix)은 (대각성분을 포함하지 않은) 대각 성분의 아랫부분이 모두 \\(0\\) 인 행렬을 말한다, 하삼각 행렬(lower triangular matrix)은 대각성분의 윗부분이 모두 \\(0\\) 인 행렬을 말한다. 예를 들어 \\[\n\\boldsymbol{U}=\\left[\\begin{array}{rrr} 1 & 3 & 4 \\\\ 0 & 2 & 1 \\\\ 0 & 0 & -1\\end{array}\\right], \\qquad \\boldsymbol{L}=\\left[\\begin{array}{rrr} 4 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ -1 & 0 & -3\\end{array} \\right]\n\\]\n에서 \\(\\boldsymbol{U}\\) 는 상삼각행렬, \\(\\boldsymbol{L}\\) 은 하삼각행렬이다. 두 삼각행렬에 대해 다음이 성립한다.\n\n명제 1 행렬 \\(\\boldsymbol{A} \\in\\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 가 상삼각 행렬 혹은 하삼각 행렬일 때 다음은 동치이다.\n\n\\(\\det (\\boldsymbol{A}) = \\prod_{i=1}^n A_{ii} \\ne 0\\)\n\\(\\boldsymbol{A}\\) 는 가역행렬이다.\n\\(\\boldsymbol{b}\\in\\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 가 유일하게 정해진다.\n\n\n\n\n하삼각 행렬에서의 선형방정식의 풀이\n\\(\\boldsymbol{L}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 과 \\(\\boldsymbol{b}\\in \\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Lx}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F})\\) 을 구해보자.\n\\[\n\\begin{bmatrix} L_{11} & & & \\\\ L_{21} & L_{22}  & & \\\\ \\vdots & & \\ddots & \\\\ L_{n1} & L_{n2} & \\cdots & L_{nn} \\end{bmatrix} \\begin{bmatrix} x_1\\\\ x_2 \\\\ \\vdots \\\\x_n \\end{bmatrix} = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n \\end{bmatrix}\n\\]\n에 대해,\n\\[\n\\begin{aligned}\nL_{11} x_1 &= b_1, \\\\\nL_{21} x_1 + L_{22} x_2 &= b_2, \\\\\n\\vdots \\\\\nL_{k1} x_k + L_{k2}x_2 + \\cdots + L_{kk}x_k &= b_k,\\\\\n\\vdots \\\\\nL_{n1}x_1 + L_{n2}x_2 + \\cdots + L_{nn}x_n &= b_n\n\\end{aligned}\n\\] 를 얻는다. 첫번째 식으로부터 \\(x_1\\) 을 구할 수 있으며, 두번째 식에서는 이미 구한 \\(x_1\\) 을 이용하여 \\(x_2\\) 를 구할 수 있다. 즉 \\(x_1,\\ldots,\\,x_k\\) 까지 구했다면 이미 알고 있는 \\(\\boldsymbol{L}\\) 과 \\(\\boldsymbol{b}\\) 의 성분을 이용하여 \\(x_{k+1}\\) 을 구할 수 있다. 이를 정리하면 다음과 같다. \\[\n\\begin{aligned}\nx_1 &= \\dfrac{b_1}{L_{11}}, \\\\\nx_k &= \\dfrac{1}{L_{kk}} \\left( b_k - \\sum_{i=1}^{k-1} L_{ki}x_{i}\\right),\\,k=2,\\ldots,\\,n\n\\end{aligned}\n\\]\n\n\n\n상삼각 행렬의 선형방정식의 풀이\n상삼각 행렬 \\(\\boldsymbol{U}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 와 \\(\\boldsymbol{b}\\in\\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Ux}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F})\\) 을 구해보자.\n\\[\n\\begin{bmatrix} U_{11} & U_{12} &\\cdots & U_{11} \\\\  & U_{22}  &\\cdots  & U_{21} \\\\  & & \\ddots & \\vdots\\\\  & &  & U_{nn} \\end{bmatrix} \\begin{bmatrix} x_1\\\\ x_2 \\\\ \\vdots \\\\x_n \\end{bmatrix} = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n \\end{bmatrix}\n\\]\n에 대해,\n\\[\n\\begin{aligned}\nU_{nn} x_n &= b_n, \\\\\nU_{n-1,n-1} x_{n-1} + U_{n-1,n} x_n &= b_{n-1}, \\\\\n\\vdots \\\\\nU_{kk} x_k + U_{k,k+1}x_{k+1} + \\cdots + U_{kn}x_n &= b_k,\\\\\n\\vdots \\\\\nU_{11}x_1 + U_{12}x_2 + \\cdots + U_{1n}x_1 &= b_1\n\\end{aligned}\n\\] 를 얻는다. 첫번째 식으로부터 \\(x_n\\) 을 구할 수 있으며, 두번째 식에서는 이미 구한 \\(x_{n}\\) 을 이용하여 \\(x_{n-1}\\) 를 구할 수 있다. 즉 \\(x_{n},\\ldots,\\,x_{k}\\) 까지 구했다면 이미 알고 있는 \\(\\boldsymbol{L}\\) 과 \\(\\boldsymbol{b}\\) 의 성분을 이용하여 \\(x_{k-1}\\) 을 구할 수 있다. 이를 정리하면 다음과 같다. \\[\n\\begin{aligned}\nx_n &= \\dfrac{b_n}{U_{nn}}, \\\\\nx_k &= \\dfrac{1}{U_{kk}} \\left( b_k - \\sum_{i=k+1}^{n} U_{ki}x_{i}\\right),\\,k=n-1,\\,n-2,\\ldots,\\,1\n\\end{aligned}\n\\]\n임을 안다.\n\n\n\n코드 분석\nJulia 의 장점중의 하나는 알고리즘을 코드로 구현 했을 때 코드에서 알고리즘을 명확히 표현할 수 있다는 것이다. 또한 Julia 의 코드 실행 속도가 빠르기 때문에 많은 경우 알고리즘을 그대로 코드화 한 경우라도 상당한 속도를 낸다는 것이다.\n상삼각행렬에 대해서는 Us(), 하삼각행렬에 대해서는 Ls() 함수로 구현하였다.\n\"\"\"\n    Ls(A, b)\n\n하삼각행렬 A 에 대해 Ax=b 의 해 x 를 구한다.\n\"\"\"\nfunction Ls(L::Matrix, b::Vector) \n    m, n = size(L)        \n    x = zeros(n)\n    x[1] = b[1]/L[1, 1]\n    for i in 2:n\n        x[i] = b[i]\n        for j in 1:1:(i-1)\n            x[i] -= L[i, j]*x[j]\n        end\n        x[i] = x[i]/L[i, i]\n    end\n    return x\nend\n\n\"\"\"\n    Us(A, b)\n\n상삼각행렬 A 에 대해 Ax=b 의 해 x 를 구한다.\n\"\"\"\nfunction Us(U::Matrix, b::Vector) \n    m, n = size(U)       \n    x = zeros(n)\n    x[n] = b[n]/U[n, n]\n\n    for i in (n-1):-1:1\n        x[i] = b[i]\n        for j in (i+1):1:n\n            x[i] -= U[i, j] * x[j]\n        end\n        x[i] = x[i]/U[i, i]\n    end\n    return x\nend\nsize(L) 은 인자로 주어지는 배열(Array) L 의 차원을 튜플(tuple) 로 반환한다.\n\n이제 \\(\\boldsymbol{L}=\\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 2 & 2 & 0 & 0 \\\\3 & 1 & -3 & 0 \\\\5 & -2 & 3 & 7 \\end{bmatrix}\\) 와 \\(\\boldsymbol{b}= \\begin{bmatrix} 3.1 \\\\ 5.3 \\\\ -2.2 \\\\ 6.0 \\end{bmatrix}\\) 에 대해 풀어보면\nL = [1. 0. 0. 0.; 2. 2. 0. 0.; 3. 1. -3. 0.; 5. -2. 3. 7.]\nb = [3.1; 5.3; -2.2; 6.0]\nx = Ls(L, b) \n를 통해 \\(\\boldsymbol{x}\\) 를 구할 수 있다. 이제 \\(\\boldsymbol{L\\cdot x}\\) 가 \\(\\boldsymbol{b}\\) 와 같은지 확인하기 위해 L*x 를 실행해보면,\n4-element Vector{Float64}:\n  3.1\n  5.3\n -2.2\n  6.0\n의 결과가 나오므로 \\(\\boldsymbol{b}\\) 를 잘 구했다.\n\n\nRoundoff 에러의 예\n이제 약간 극단적인 경우를 살펴 보자. 하삼각 행렬에서 대각성분이 0 이 아닌 다른 성분에 비해 매우 작은 경우이다.\nA1= [1.0 0 0; 1.0e8 1 0; 1.0e8 1.0e8 1]\nb1 = [1; 1; 1.0]\nx1 = Ls(A1, b1)\n이 때 구한 x1 은 다음과 같다.\n3-element Vector{Float64}:\n  1.0\n -9.9999999e7\n  9.9999998e15\n이 경우 A1*x1 을 수행하면,\n3-element Vector{Float64}:\n 1.0\n 1.0\n 0.0\n가 나와 실제 b1 값과 차이가 남을 알 수 있다. 이것은 64 비트 부동소수의 유효자리수 때문이다. 직접 손으로 계산해 보면 알겠지만 x1 은 정확히 계산이 되었다. 다만 A1*x1 의 세번째 성분은 다음 식을 통해 계산되는데\n\\[\n1.0\\times 10^8 \\times 1 - 9.9999999\\times 10^{15} + (1- 1.0\\times 10^8 \\times 1 + 9.9999999\\times 10^{15})\n\\]\n뒤의 괄호 안을 계산 할 때 \\(9.9999999\\times 10^{15}\\) 라는 숫자가 너무 커서 1 정도의 차이를 표현 할 수 없다. Float64 에서 9.9e15+1 은 9.9e15 과 구별 할 수 없다. 즉 Roundoff 에러가 발생한 것이다. 이런 문제는 BigFloat 와 같은 타입을 사용하면 어느 정도 해소되지만 여기서는 일단은 다루지 않는다.\n\n\n\n\n계산 복잡도 분석\n하삼각 행렬의 경우 \\(x_1\\) 을 계산하는데흔 한번의 나눗셈, \\(k\\ne 1\\) 일 때 \\(x_k\\) 를 계산하는데 스칼라곱이 \\(k-1\\) 번, 덧셈과 뺄셈이 \\(k\\) 번, 나눗셈 \\(1\\) 번이 필요하므로 모두 \\(2k\\) 번의 계신이 필요하다. \\(n \\times n\\) 하삼각 행렬의 행렬식에 대해서\n\\[\nT(n) = 1 + \\sum_{k=2}^n 2k = n^2 + n -1 = O(n^2)\n\\]\n이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/02_linear_system.html#sec-gauss_jordan_elimination",
    "href": "src/numerical_analysis_using_julia/02_linear_system.html#sec-gauss_jordan_elimination",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "3 가우스-요르단 소거법",
    "text": "3 가우스-요르단 소거법\n\\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(n \\times k\\) 행렬 \\(\\boldsymbol{X}\\), \\(m \\times k\\) 행렬 \\(B\\) 가 \\(\\boldsymbol{AX}=\\boldsymbol{B}\\) 를 만족하며 \\(\\boldsymbol{L}\\) 이 \\(n \\times n\\) 가역행렬 일 때 다음이 성립한다.\n\\[\n\\boldsymbol{AX}=\\boldsymbol{B} \\iff  \\boldsymbol{LAX} = \\boldsymbol{LB}\n\\]\n만약 \\(k=1\\) 이라면, 즉 \\(n \\times 1\\) 행렬 \\(\\boldsymbol{x}\\),, \\(m \\times 1\\) 행렬 \\(\\boldsymbol{b}\\) 에 대해,\n\\[\n\\boldsymbol{Ax}=\\boldsymbol{b} \\iff  \\boldsymbol{LAx} = \\boldsymbol{Lb}\n\\]\n가 성립한다. 즉 주어진 \\(\\boldsymbol{A}\\) 와 \\(\\boldsymbol{b}\\) 에 대해 가역 행렬 \\(\\boldsymbol{L}\\) 을 통해 \\(\\boldsymbol{LA}\\) 를 매우 간단하게 만든다면 \\(\\boldsymbol{LAx}=\\boldsymbol{Lb}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 를 쉽게 구할 수 있으며, 이 \\(\\boldsymbol{x}\\) 가 우리가 구하고자하는 선형방정식의 해이다.\n\n\n행 사다리꼴 행렬, 행 간소 사다리꼴 행렬과 행 기본 연산\n\n행 사다리꼴과 행 간소 사다리꼴\n행 사다리꼴 행렬(row echelon form matrix)은 다음의 조건을 만족하는 행렬이다.\n\n영벡터가 존재할 경우 이 영벡터는 영벡터가 아닌 행벡터의 아래에 위치한다.\n행렬의 행벡터가 영벡터가 아닐 때, 처음으로 나타나는 0 이 아닌 성분을 선행 성분이라 한다. 윗 행의 선행 성분은 아래 행 전체의 각각의 선행성분보다 앞서 존재한다.\n\n아래의 행렬 \\(\\boldsymbol{A}_1,\\,\\boldsymbol{A}_2\\) 는 각각 1, 2 번 조건을 거스르는 행렬이므로 행사다리꼴이 아니다. (선행 성분을 밑줄로 표시하였다.)\n\\[\n\\begin{aligned}\n\\boldsymbol{A}_1 &= \\begin{bmatrix} \\underline{1} & 2 & 0 \\\\0 & 0 & 0 \\\\ 0 & \\underline{1} & 0\\end{bmatrix}, \\\\\n\\boldsymbol{A}_2 &= \\begin{bmatrix} 0 & 0 & \\underline{1} \\\\ \\underline{1} & 0 & 2\\end{bmatrix}.\n\\end{aligned}\n\\]\n\n행 간소 사다리꼴 행렬(row-reduced echelon form matrix)은 행 사다리꼴 행렬의 조건에 더해 다음의 조건이 추가된다.\n\n각 행의 선행성분은 \\(1\\) 이다. 이를 선행 1 성분 이라 하자.\n선행 1 성분이 존재하는 열은 선행성분을 제외한 모든 성분이 \\(0\\) 이다.\n\n\n\n\n기본 행 연산\n우리는 선형대수학으로부터 모든 행렬은 세가지의 기본 행 연산(elementary row operation)을 통해 행 사다리꼴과 행 간소 사다리꼴 행렬로 만들 수 있으며, 행렬의 행 간소 사다리꼴은 유일하다는 것을 안다. 이때의 기본 행 연산은 다음과 같다.\n\n두 행의 위치를 서로 바꾼다. (\\(\\hat{L}_1\\) 연산)\n특정 행에 \\(0\\) 이 아닌 스칼라를 곱한다. (\\(\\hat{L}_2\\) 연산)\n한 행에 다른 행의 스칼라곱을 더한다. (\\(\\hat{L}_3\\) 연산)\n\n\n\\(m \\times n\\) 행렬에 대한 행 기본 연산은 \\(m \\times m\\) 행렬로 표현된다. \\(k\\) 번째 행과 \\(l\\) 번째 행의 위치를 서로 바꾸는 행렬 \\(\\boldsymbol{L}_1 (k, l)\\) 는 \\[\n[\\boldsymbol{L}_1(k,\\,l)]_{i,\\, j} = \\left\\{\\begin{array}{ll} 1 \\qquad &\\text{if } i = j \\ne k, \\text{ and }i = j \\ne l \\\\ 1 & \\text{if } i = k,\\, j = l,\\\\ 1 & \\text{if } j = k,\\, i = l, \\\\ 0 & \\text{otherwise}\\end{array} \\right.\n\\]\n이며 \\(4 \\times 4\\) 행렬에서 1 행과 3행을 교환하는 행렬 \\(\\boldsymbol{L}_1 (1, 3)\\) 은 다음과 같다.\n\\[\n\\boldsymbol{L}_1(1, 3)\n=\\begin{bmatrix}\n0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 0\\\\  0 & 0 & 0 & 1\n\\end{bmatrix} .\n\\]\n\\(k\\) 번째 행에 스칼라 \\(c\\) 를 곱하는 연산을 나타내는 행렬 \\(\\boldsymbol{L}_2(k, c)\\) 는\n\\[\n[\\boldsymbol{L}_2(k,\\, c)]_{i,\\,j}= \\left\\{\\begin{array}{ll} 1 \\qquad & \\text{if } i=j\\ne k,\\, \\\\ c &\\text{if } i=j=k,\\,\\\\ 0 &\\text{otherwise}\\end{array}\\right.\n\\]\n이며 \\(4\\times 4\\) 행렬에서 2행에 스칼라 \\(c\\) 를 곱하는 행렬은 \\(\\boldsymbol{L}_2 (2, c)\\) 는 다음과 같다.\n\\[\n[\\boldsymbol{L}_2 (2,\\,c)] = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 2 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}.\n\\]\n\\(l\\) 번째 행에 \\(c\\) 를 곱한 것을 \\(k\\) 번째 행에 더하는 행렬 \\(\\boldsymbol{L}_3 (k, l, c)\\) 은\n\\[\n[\\boldsymbol{L}_3 (k,\\,l,\\,c)]_{i,\\,j} = \\left\\{ \\begin{array}{ll}1 \\qquad & \\text{if } i=j \\,,\\\\\nc & \\text{if } i = k, j = l\\,, \\\\ 0 &\\text{oterwise}  \\end{array}\\right.\n\\]\n이며 \\(4 \\times 4\\) 행렬에서 3 행에 \\(c\\) 를 곱해 \\(1\\) 행에 더하는 행렬 \\(\\boldsymbol{R}\\) 은 다음과 같다.\n\\[\n\\boldsymbol{L}_3 (1, 3, c) = \\begin{bmatrix} 1 & 0 & c & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1\\end{bmatrix}.\n\\]\n모든 행 기본 연산은 \\(\\boldsymbol{L}_1,\\,\\boldsymbol{L}_2,\\,\\boldsymbol{L}_3\\) 가역행렬이며 그 역행렬은 다음과 같다.\n\\[\n\\begin{aligned}\n\\left[\\boldsymbol{L}_1(k, l) \\right]^{-1} &= \\boldsymbol{L}_1(k, l), \\\\\n\\left[\\boldsymbol{L}_2(k, c) \\right]^{-1} &= \\boldsymbol{L}_2(k, 1/c), \\\\\n\\left[\\boldsymbol{L}_3(k, l, c) \\right]^{-1} &= \\boldsymbol{L}_3(k, l, -c),\n\\end{aligned}\n\\]\n\n\n\n\n가우스-요르단 소거 과정 (Gauss-Jordan elimination method)\n가우스 소거법은 기본 행 연산을 유한번 시행하여 행렬을 행 사다리꼴(Row echelon form) 행렬로 변환시키는 것을 말한다. 목적이 사다리꼴이 아닌 행 간소 사다리꼴(Row-reduced echelon form) 일 경우 가우스-요르단 소거법이라 한다. 사람에 따라 가우스-요르단 소거법을 가우스 소거법이라고 하는데 여기서는 둘을 구분하기로 하자. 정사각행렬의 경우 가우스 소거법에 의해 상삼각행렬로 변환되며, 가역행렬일 경우 가우스-요르단 소거법의 결과는 단위행렬이다.\n이제 \\(m\\times n\\) 행렬 \\(\\boldsymbol{A}\\) 에 대한 가우스 소거법을 생각해보자. \\(\\boldsymbol{A}\\) 가 영행렬이면 의미가 없으므로 영행렬이 아닐 때만 생각한다.\nP1-1. 영벡터가 아닌 첫번째 열벡터를 찾는다. 그 열벡터의 첫번째 행이 \\(0\\) 이거나 절대값이 작을 경우 그 열벡터에서 적당한 \\(0\\) 이 아닌 행을 찾아 그 행과 첫번째 행을 교환한다(\\(\\hat{L}_1\\) 연산). 이것을 피보팅 (pivoting) 이라 한다. 보통 첫번째 행이 \\(0\\) 이 아니더라도 절대값이 가장 큰 값을 찾아 교환한다. 예를 들어\n\\[\n\\boldsymbol{A}=\\begin{bmatrix} 1 & 3 & 2 \\\\ 0 & 2 & 4 \\\\ 4 & 1 & 3\\end{bmatrix}\n\\]\n일 경우, 첫번째 열벡터가 영벡터가 아니며, 이 열벡터의 첫번째 행이 \\(0\\) 이 아니지만 이 열벡터에 절대값이 가장 큰 \\(4\\) 가 성분으로 존재하므로 첫번째 행과 마지막 행을 교환한다. 이를 \\(\\boldsymbol{A}_{1-1}\\) 이라 하자. 이 때 선행 성분은 \\(4\\) 이다. \\[\n\\boldsymbol{A}_{1-1}=\\begin{bmatrix} \\underline{4} & 1 & 3\\\\ 1 & 3 & 2 \\\\ 0 & 2 & 4\\end{bmatrix}\n\\]\nP1-2. 선행성분으로 첫번째 행벡터를 나누어준다(\\(\\hat{L}_2\\) 연산). 이제 첫번째 행의 첫번째 성분은 1이다(선행 1 성분). 여기까지 수행한 행렬을 \\(\\boldsymbol{A}_{1-2}\\) 라고 하면 다음과 같다.\n\\[\n\\boldsymbol{A}_{1-2}=\\begin{bmatrix} \\underline{1} & 1/4 & 3/4 \\\\ 1 & 3 & 2 \\\\ 0 & 2 & 4\\end{bmatrix}.\n\\]\nP1-3. 첫번째 행벡터의 선행 1 성분의 열 위치를 \\(l_1\\) 이라 하자. \\(j=2,\\ldots,\\,m\\) 에 대해 \\(\\hat{L}_3 (j, i, -A_{j,l_1})\\) 를 적용하면 \\(l_1\\) 열은 첫번째 성분을 제외하면 모두 \\(0\\) 이 된다. 첫번째 행에 대한 마지막 과정이므로 \\(\\boldsymbol{A}_1\\) 이라 하면 다음과 같다.\n\\[\n\\boldsymbol{A}_1=\\begin{bmatrix} \\underline{1} & 1/4 & 3/4 \\\\ 0 & 3/4 & 5/4 \\\\ 0 & 2 & 4\\end{bmatrix}.\n\\]\n\n이제 행렬 \\(\\boldsymbol{A}_k\\) 가 1) \\(1\\) 행부터 \\(k\\) 행까지는 1) 행 간소 사다리꼴 행렬이며, 2) \\(k\\) 행의 선행 1 성분의 위치가 \\(l_k\\) 열일 때 \\(k\\) 행 아래의 모든 행이 1열부터 \\(l_k\\) 열까지 \\(0\\) 이라고 하자. 이에 다음 Pk-1-1., Pk-1-2., Pk-1-1. 과정을 수행한다.\nPk+1-1. \\(k+1\\) 행부터 \\(m\\) 행까지만 생각한다. 여기서 첫번째 \\(0\\) 벡터가 아닌 열벡터를 찾는다. 당연히 이 열벡터는 \\(l_k\\) 열보다 오른쪽의 열이다. 이것을 \\(l_{k+1}\\) 열이라고 하자. 이 열에서 가장 절대값이 큰 성분의 행과 \\(k+1\\) 행을 교환한다 (\\(\\hat{L}_1\\) 연산). 만약 존재하지 않는다면 \\(k+1\\) 행부터 마지막 행 까지의 모든 행벡터가 영벡터이므로 과정을 더 이상 진행시키지 않는다.\nPk+1-2. 교환된 \\(k+1\\) 행을 가장 처음 \\(0\\) 이 아닌 성분으로 나눈다 (\\(\\hat{L}_2\\) 연산). 이제 첫번째 행의 첫번째 성분은 1이다.(선행 1 성분)\nPk+1-3. \\(k+1\\) 행이 마지막 행이라면 더 이상 진행하지 않는다. 그렇지 않다면 \\(j=1, \\ldots, \\, k, k+2,\\ldots,\\,m\\) 에 대해 \\(\\hat{L}_3 (j, k+1, -A_{j,l_1})\\) 를 적용하면 \\(l_{k+1}\\) 열 의 \\(k+2\\) 행 이하는 모두 \\(0\\) 이 된다.\n이 과정을 수행한 후 \\(1\\) 행부터 \\(k+1\\) 행까지 행 간소 사다리꼴 형태가 됨을 알 수 있다. 이제 \\(m \\times n\\) 행렬에 대해 1 행부터 \\(m\\) 행에 대해 위의 과정을 수행한다면 행렬의 행 간소 사다리꼴 형태를 얻을 수 있다.\n우리는 가역행렬의 행 간소 사다리꼴이 항등행렬임을 안다. \\(n \\times n\\) 가역행렬 \\(\\boldsymbol{A}\\) 와 \\(n\\) 차원 열벡터 \\(\\boldsymbol{b}\\) 에 대해 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 열벡터 \\(\\boldsymbol{x}\\) 를 찾는다고 하자. \\(\\boldsymbol{A}\\) 가 기본 행 연산 \\(\\boldsymbol{E}_1, \\ldots,\\,\\boldsymbol{E}_N\\) 에 대해 행 간소 사다리꼴이 된다고 하면\n\\[\n\\begin{aligned}\n&\\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 \\boldsymbol{Ax} = \\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 \\boldsymbol{b} \\\\\n\\implies &\\boldsymbol{x} = \\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 \\boldsymbol{b}\n\\end{aligned}\n\\]\n이다. 이 때 \\(\\boldsymbol{E}=\\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1\\) 라고 하면, \\(\\boldsymbol{EA}=\\boldsymbol{I}\\) 이므로,\n\\[\n\\boldsymbol{E} = \\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 = \\boldsymbol{A}^{-1}\n\\]\n이다. 즉 우리는 가우스-요르단 소거법을 통해 선형방정식을 풀 수 있을 뿐만 아니라, 역행렬도 구할 수 있다.\n이제 가우스-요르단 소거법을 수행하는 함수를 만들어 보자. 행렬 \\(\\boldsymbol{A}\\) 와 열행렬 혹은 행렬 \\(\\boldsymbol{B}\\) 에 대해 \\(\\boldsymbol{A}\\) 를 행 간소 사다리꼴로 만드는 프로세스를 \\(\\begin{bmatrix}\\boldsymbol{A} & \\boldsymbol{B}\\end{bmatrix}\\) 에 대해 수행하도록 한다. 다만 \\(\\boldsymbol{B}\\) 는 선택적으로 입력 가능하다. 함수 gauss_jordan_elimination 을 아래에 구현하였다. 여기서 eptols 는 절대값이 작은 수로 피보팅 할 때 절대값이 이 수보다 작다면 0 과 차이가 없도록 간주한다.\nfunction gauss_jordan_elimination(A::Matrix, b::Union{Nothing, Vector, Matrix}=nothing; eptols = 1.0e-10)\n    m, n = size(A)\n\n    if b ≠ nothing\n        @assert m == size(b)[1]\n        B = [A b]\n    else\n        B = A\n    end\n    \n    ld = 0 #선행 1 성분의 column index\n\n    for i in 1:m\n        termination = true # 종료 조건\n        for j in (ld+1):n\n            p = argmax(abs.(B[i:end, j])) + i -1\n            \n            if abs(B[p, j]) &gt; eptols\n                B[i,:], B[p, :] = B[p, :], B[i,:]\n                ld = j\n                termination = false\n                break\n            end\n        end\n\n        if termination \n            break\n        end\n        \n        B[i, :] .= B[i, :]./B[i, ld]\n        \n        # 선행 1 성분의 열을 자신을 제외하고는 제거\n        for k in 1:m\n            if k ≠ i \n                B[k, :] .= B[k, :] .- (B[k, ld].* B[i, :])\n            end\n        end\n    end\n\n    if b ≠ nothing \n         return B[:, 1:n], B[:,(n+1):end]\n    else \n         return B\n    end\nend\n\n\n\n계산 복잡도 분석\n우선 피보팅 없이 \\(n \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(n\\) 차원 벡터 \\(\\boldsymbol{b}\\) 에 대해 \\(\\boldsymbol{Ax}=b\\) 를 만족하는 \\(\\boldsymbol{x}\\) 를 가우스-요르단 소거법을 통해 구하는 데 필요한 계산복잡도를 알아보자. 우선 \\(n\\times (n+1)\\) 행렬 \\(\\begin{bmatrix} \\boldsymbol{A} & \\boldsymbol{b}\\end{bmatrix}\\) 에 대해 수행하므로,\n우선 \\(k\\) 번째 행에 대해\n\n\\(k\\) 행을 대각성분 \\(A_{k,k}\\) 으로 나누어 주는데 \\(n-k+2\\) 번의 연산이 필요하며,\n\\(k\\) 행 아래의 \\(n-k\\) 개의 행에 대해 \\(\\hat{L}_3\\) 연산을 통해 \\(k\\) 열의 성분을 대각성분을 제외하고 모두 \\(0\\) 으로 만드는데, 각각 나누기 한번과 빼기 한번, 두번의 연산이 소요되므로, \\(2(n-k)(n-k+2)\\) 번의 스칼라 사칙연산이 필요하다\n\n따라서\n\\[\nT(n) = \\sum_{k=1}^n (n-k+2) + 2(n-k)(n-k+2) = O\\left( \\frac{2}{3}n^3 \\right) = O(n^3)\n\\]\n이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/02_linear_system.html#sec-lu_decomposition",
    "href": "src/numerical_analysis_using_julia/02_linear_system.html#sec-lu_decomposition",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "4 LU 분해",
    "text": "4 LU 분해\n선형방정식 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 의 해를 수치해석적으로 얻는 가장 기본적인 방법이 LU 분해(LU decomposition, LU factorization) 이다. 또한 행렬의 행렬식과 역행렬을 구하는 가장 기본적인 방법이 LU 분해를 통해 구하는 것이다.\n\n\nLU 분해 (LU decomposition)\n행렬 \\(\\boldsymbol{A}\\) 를 어떤 하삼각행렬 \\(\\boldsymbol{L}\\) 과 상삼각행렬 \\(\\boldsymbol{U}\\) 의 곱으로 다음과 같이 나타내는 것을 LU 분해 (LU decomposition 혹은 LU factorization) 이라고 한다. LU 분해 자체는 정사각 행렬이 아니더라도 가능하다.\n\\[\n\\boldsymbol{A}=\\boldsymbol{LU}\n\\]\n\\(2 \\times 2\\) 행렬의 예를 보자.\n\\[\n\\boldsymbol{A}=\\begin{bmatrix} 2 & 3 \\\\ 2 & 4 \\end{bmatrix} =\\boldsymbol{LU}=\\begin{bmatrix} l_{11} & 0 \\\\ l_{21} & l_{22} \\end{bmatrix} \\begin{bmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{bmatrix}\n\\]\n이 경우,\n\\[\n\\begin{aligned}\nl_{11}u_{11} & = 2, \\\\\nl_{11}u_{12} &= 3 , \\\\\nl_{21}u_{11} &= 2 , \\\\\nl_{21}u_{12} + l_{22}u_{22} & = 4,\n\\end{aligned}\n\\]\n의 네 개의 식이 나온다. 미지수 6개에 식이 4개이므로 미지수를 결정 할 수 없다. 만약 \\(l_{11}= l_{22}=1\\) 의 제한조건을 걸어 놓고 계산을 하면,\n\\[\n\\boldsymbol{L} = \\begin{bmatrix} 1 & 0 \\\\ 1 & 1\\end{bmatrix},\\qquad \\boldsymbol{U} = \\begin{bmatrix} 2 & 3 \\\\ 0 &1\\end{bmatrix}\n\\]\n이라는 것을 알 수 있다. 일반적인 LU 분해에서도 하삼각행렬 \\(\\boldsymbol{L}\\) 의 대각성분을 1로 고정시켜 구한다.\n다음 행렬에 대한 \\(LU\\) 분해를 생각하자.\n\\[\n\\boldsymbol{B}=\\begin{bmatrix} 0 & 3 \\\\ 2 & 4 \\end{bmatrix} =\\boldsymbol{LU}=\\begin{bmatrix} l_{11} & 0 \\\\ l_{21} & l_{22} \\end{bmatrix} \\begin{bmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{bmatrix}\n\\]\n이 경우,\n\\[\n\\begin{aligned}\nl_{11}u_{11} & = 0, \\\\\nl_{11}u_{12} &= 3 , \\\\\nl_{21}u_{11} &= 2 , \\\\\nl_{21}u_{12} + l_{22}u_{22} & = 4,\n\\end{aligned}\n\\]\n이며, \\(u_{11}=0\\) 이므로 \\(l_{21}\\) 값을 정할 수 없다. \\(l_{11}=l_{22}=1\\) 이라는 제한조건을 푼다고 해도 마찬가지 이다. 이 경우 우리가 가우스 소거법에서 수행했던 행 교환 연산인 피보팅을 한다. 1행과 2행을 바꾼 행렬을 \\(\\boldsymbol{B}\\) 라고 하면,\n\\[\n\\boldsymbol{B}'=\\begin{bmatrix} 2 & 4 \\\\ 0 & 3 \\end{bmatrix} =\\boldsymbol{LU}=\\begin{bmatrix} l_{11} & 0 \\\\ l_{21} & l_{22} \\end{bmatrix} \\begin{bmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{bmatrix}\n\\]\n이 경우,\n\\[\n\\begin{aligned}\nl_{11}u_{11} & = 2, \\\\\nl_{11}u_{12} &= 4 , \\\\\nl_{21}u_{11} &= 0 , \\\\\nl_{21}u_{12} + l_{22}u_{22} & = 3,\n\\end{aligned}\n\\]\n이므로\n\\[\n\\boldsymbol{L} =  \\begin{bmatrix}1 &  0 \\\\ 0 & 1 \\end{bmatrix},\\qquad \\boldsymbol{U} =  \\begin{bmatrix} 2 & 4 \\\\ 0 & 3 \\end{bmatrix}\n\\]\n로 LU 분해가 가능하다. 즉 \\(\\boldsymbol{P} =\\begin{bmatrix} 0 & 1 \\\\ 1 & 0\\end{bmatrix}\\) 에 대해 \\(\\boldsymbol{PB}\\) 가 LU 분해가 가능하다. 이렇게 피보팅까지 포함하여 LU 분해를 수행하는 것을 PLU 분해라고 하며 보통 LU 분해를 구현하는 경우 PLU 분해를 포함하여 구현할 수 밖에 없다. 이제부터는 LU 분해는 항상 PLU 분해를 의미한다.\n\n\n\nLU 분해를 이용한 선형방정식의 풀이 및 행렬식\n\\(\\boldsymbol{A}\\) 가 LU 분해 가능이고 \\(\\boldsymbol{PA}=\\boldsymbol{LU}\\) 로 분해되었다고 하자. \\(\\boldsymbol{A}\\) 가 가역행렬이 아니라면 분해가 의미가 없으므로 가역행렬일 때만 생각한다. 치환행렬 \\(\\boldsymbol{P}\\) 는 가역행렬이므로\n\\[\n\\boldsymbol{Ax}=\\boldsymbol{b} \\iff \\boldsymbol{PAx}=\\boldsymbol{Pb} \\iff \\boldsymbol{LUx}=\\boldsymbol{Pb}\n\\]\n가 성립한다. 여기서 우리는 \\(\\boldsymbol{y}=\\boldsymbol{Ux}\\) 라고 놓고 우선 \\(\\boldsymbol{Ly}=\\boldsymbol{Pb}\\) 를 통해 \\(\\boldsymbol{y}\\) 를 구한 후, \\(\\boldsymbol{Ux}=\\boldsymbol{y}\\) 를 풀어서 우리가 구하고자 하는 \\(\\boldsymbol{x}\\) 를 구한다. 가우스-요르단 소거법으로 선형 시스템을 풀기 위해서는 \\(\\boldsymbol{b}\\) 값이 바뀔 때마다 소거법을 수행해야 하지만, LU 분해나 PLU 분해는 \\(\\boldsymbol{A}\\) 에 대해서만 분해 한 후 삼각행렬에 대한 식을 풀면 되기 때문에 훨씬 간단하다. 또한 뒤에 보겠지만 대각성분으로 나눠주는 항이 없기 때문에 roundoff 에러로부터 더 안전하다.\n행렬식 \\(\\det\\) 를 구하는 데도 사용된다. LU 분해 시 \\(\\boldsymbol{L}\\) 의 모든 대각성분을 \\(1\\) 로 고정시키기 때문에,\n\\[\n\\det(\\boldsymbol{A}) = \\det (\\boldsymbol{P}) \\det(\\boldsymbol{U}) = (-1)^n(P) \\prod_{i=1}^n U_{ii}\n\\]\n이다. 여기서 \\(n(P)\\) 는 \\(\\boldsymbol{P}\\) 에 나타나는 치환의 횟수이다.\n\n\n\nPLU 분해\n\\(n \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 가 어떤 행교환 행렬 \\(\\boldsymbol{P}\\) 와 하삼각 행렬 \\(\\boldsymbol{L}\\), 상삼각 행렬 \\(\\boldsymbol{U}\\) 에 대해 \\(\\boldsymbol{PA} = \\boldsymbol{LU}\\) 라 하자. \\(\\boldsymbol{P}\\), \\(\\boldsymbol{L}\\), \\(\\boldsymbol{U}\\) 는 모두 \\(n \\times n\\) 행렬이다. \\(\\boldsymbol{A}\\) 의 첫번째 열벡터에서 절대값이 최대값인 행과 1행을 교환하는 행교환 행렬을 \\(\\boldsymbol{P}_1\\) 이라고 하고 \\(\\boldsymbol{B}_1=\\boldsymbol{P}_1\\boldsymbol{A}\\) 라 하자. 행렬 \\(\\boldsymbol{B}_1\\) 과 \\(\\boldsymbol{L},\\,\\boldsymbol{U}\\) 를 1행, 1열과 나머지 부분행렬로 아래와 같이 구분한다.\n\\[\n\\boldsymbol{B}_1=\\left[\\begin{array}{cc} b_1 & \\boldsymbol{r}_1^T \\\\ \\boldsymbol{c}_1 & \\boldsymbol{C}_1\\end{array}\\right],\\qquad \\boldsymbol{L}=\\begin{bmatrix} 1 & 0 \\\\ \\boldsymbol{l}_1 & \\boldsymbol{L}_1\\end{bmatrix}, \\qquad \\boldsymbol{U} = \\begin{bmatrix} v_1 & \\boldsymbol{u}_1^T \\\\ 0 & \\boldsymbol{U}_1\\\\\\end{bmatrix}\n\\]\n\\(\\boldsymbol{P}_1\\boldsymbol{A} =\\boldsymbol{B}_1=\\boldsymbol{LU}\\) 라 하면 다음을 얻는다. \\[\n\\begin{aligned}\nv_1 & = b_1, \\\\\n\\boldsymbol{u}_1 &= \\boldsymbol{r}_1, \\\\\nu_1 \\boldsymbol{l}_1 &= \\boldsymbol{c}_1, \\\\\n\\boldsymbol{l}_1 \\cdot \\boldsymbol{u}_1^T + \\boldsymbol{L}_1 \\boldsymbol{U}_1 &= \\boldsymbol{C}_1\n\\end{aligned}\n\\]\n이를 통해 \\(\\boldsymbol{L}\\) 과 \\(\\boldsymbol{U}\\) 의 1행과 1열이 결정되며, \\((n-1)\\times (n-1)\\) 행렬인 \\(\\boldsymbol{L}_1\\boldsymbol{U}_1\\) 이 결정된다. \\(\\boldsymbol{A}\\) 의 첫번째 열벡터가 영벡터라면 \\(b_1=0,\\, \\boldsymbol{c}_1=\\boldsymbol{0}\\) 이며, 따라서 \\(u_1=0\\) 으로 \\(\\boldsymbol{l}_1\\) 은 어떤 벡터를 놓아도 계산에 영향을 주지 않기 때문에 가장 간단하게 \\(\\boldsymbol{0}\\) 으로 놓는다.\n이제 \\(\\boldsymbol{A}_1=\\boldsymbol{L}_1\\boldsymbol{U}_1 = \\boldsymbol{C}-\\boldsymbol{l} \\cdot \\boldsymbol{u}^T\\) 이라 놓고, \\(\\boldsymbol{A}_1\\) 에 대해 행교환 행렬 \\(\\boldsymbol{Q}_2\\) 위의 과정을 똑같이 수행하여\n\\[\n\\boldsymbol{Q}_2\\boldsymbol{A}_1=\\boldsymbol{B}_2 = \\left[\\begin{array}{cc} b_2& \\boldsymbol{r}_2^T \\\\ \\boldsymbol{c}_2 & \\boldsymbol{C}_2\\end{array}\\right] = \\begin{bmatrix} 1 & 0 \\\\ \\boldsymbol{l}_2 & \\boldsymbol{L}_2\\end{bmatrix}\\begin{bmatrix} v_2 & \\boldsymbol{u}_2^T \\\\ 0 & \\boldsymbol{U}_2\\\\\\end{bmatrix}\n\\]\n을 얻는다. 여기서 \\(\\boldsymbol{l}_2,\\, v_2,\\, \\boldsymbol{u}_2\\) 와 \\(\\boldsymbol{L_2}\\boldsymbol{U}_2 = \\boldsymbol{C}_2-\\boldsymbol{l}_2 \\cdot \\boldsymbol{u}_2^T\\) 라는 것을 안다. \\(\\boldsymbol{P}_2 = \\begin{bmatrix} 1 & \\boldsymbol{0}^T \\\\ \\boldsymbol{0} & \\boldsymbol{Q}_2\\end{bmatrix}\\) 라고 하면,\n\\[\n\\boldsymbol{P}_2 \\boldsymbol{P}_1 \\boldsymbol{A} = \\begin{bmatrix} 1 &  &  \\\\\\vdots  & 1 &  \\\\ \\boldsymbol{Q}_2 \\boldsymbol{l}_1 & \\boldsymbol{l}_2 & \\boldsymbol{L}_2\\end{bmatrix} \\begin{bmatrix} v_1 & \\cdots & \\boldsymbol{u}_1^T \\\\  & v_2 & \\boldsymbol{u}_2^T \\\\ & & \\boldsymbol{U}_2 \\end{bmatrix}\n\\] 이 된다. 여기서 행렬의 \\(~\\vdots~\\) 는 \\(\\boldsymbol{Q}_2 \\boldsymbol{l}_2\\) 의 연장이며 , \\(\\cdots\\) 는 \\(\\boldsymbol{u}_1^T\\) 의 연장이다. \\(\\boldsymbol{L}_1\\boldsymbol{U}_1\\) 에 대해 위의 과정을 반복적으로 수행하면, 결국 \\(\\boldsymbol{P}\\), \\(\\boldsymbol{L}\\), \\(\\boldsymbol{U}\\) 를 얻을 수 있다. 이것을 수행하는 코드는 다음과 같다.\nfunction PLU(A::Matrix{T}; eptols = 1.0e-10) where T&lt;:Real\n    M, N = size(A)\n    @assert M == N\n\n    L, P, U = one(A), one(A), zero(A)\n    B = copy(A)\n    \n    for i in 1:(M-1)\n        p = argmax(abs.(B[i:end, i])) + i -1\n        \n        if abs(B[p, i]) &lt; eptols\n            error(\"Singularity error\")    \n        end\n\n        P[i,:], P[p, :] = P[p, :], P[i, :]\n        B[i,:], B[p, :] = B[p, :], B[i, :]\n        \n        if i&gt;1\n            L[i,1:i-1], L[p, 1:i-1] = L[p, 1:i-1], L[i, 1:i-1]\n        end\n        \n        U[i, i] = B[i, i]\n        U[i, (i+1):end] = B[i, (i+1):end]\n        L[(i+1):end, i] = B[(i+1):end, i] / B[i, i]\n        B[(i+1):end, (i+1):end] = B[(i+1):end, (i+1):end] - (L[(i+1):end, i:i] * U[i:i, (i+1):end])\n    end\n    U[M, M] = B[M, M]\n    return P, L, U\nend\n\n\n\n\n\n\n경고\n\n\n\n이 코드는 이해를 돕기 위한 코드로, PLU 를 정상적으로 계산 해 주지만 효율적인 코드는 아니다.\n\n\n\n\n\n복잡도 분석\n피봇을 고려하지 않은 복잡도를 분석해보자. \\(m\\times m\\) 행렬에 대해 첫번째 열의 각 열에 대한 연산은 \\(m\\) 번의 곱하기(코딩상으로는 나누기) 와 \\(m\\) 번의 더하기(코딩상으로는 빼기) 가 이루어지며 총 \\(m-1\\) 번의 행에 대해 이루어지기 때문에 \\(2m(m-1)\\) 번의 연산이 이루어진다. \\(n\\times n\\) 행렬에 대해서라면 \\(m\\) 값이 \\(2\\) 부터 \\(n\\) 까지 변할때의 합이므로\n\\[\nT(n) = \\sum_{m=2}^{n} 2m(m-1) = \\sum_{m=1}^n 2m(m-1)= O\\left(\\dfrac{2n^3}{3}\\right)\n\\]\n이다. 즉 가\n\n\n\n왜 LU 인가?\n가우스 소거법과 LU 분해는 복잡도가 같다. 그러나 많은 경우 선형시스템을 푼다는 것은 시스템 행렬 \\(\\boldsymbol{A}\\) 가 주어진 상태에서 \\(\\boldsymbol{b}\\) 가 변함에 따라 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 를 찾는다. 가우스 소거법을 이용하는 경우라면 매번 \\(O(n^3)\\) 복잡도의 계산을 해 주어야 한다. LU 분해의 경우 \\(\\boldsymbol{A}=\\boldsymbol{LU}\\) (혹은 \\(\\boldsymbol{A}=\\boldsymbol{P}^{-1}\\boldsymbol{LU}\\)) 에 대해 \\(\\boldsymbol{L}\\), \\(\\boldsymbol{U}\\) 가 정해져 있기 때문에 각각 한번의 상삼각행렬과 하삼각행렬에 대해 풀어주면 된다. 상삼각 행렬과 하삼각 행렬의 복잡도는 \\(O(n^2)\\) 이므로 주어진 시스템 행렬에 대해 많은 계산을 할 때는 LU 분해가 훨씬 유리하다.\n\n\n\nLDU 분해\nLU 분해에서 상삼각해렬 \\(\\boldsymbol{U}\\) 를 대각행렬 \\(\\boldsymbol{D}\\) 와 대각성분이 \\(1\\) 인 상삼각행렬 \\(\\boldsymbol{U}'\\) 의 곱으로 나타 낼 수 있다. 이를 LDU 분해라고 한다. \\[\n\\underbrace{\\begin{bmatrix} U_{11} & U_{12} & \\cdots & U_{1n} \\\\ 0 & U_{22} & \\cdots & U_{2n} \\\\ & & \\ddots & \\\\ 0 & 0 & \\cdots & U_{nn}\\end{bmatrix}}_{\\Large\\boldsymbol{U}} = \\underbrace{\\begin{bmatrix} U_{11} &  &  & 0 \\\\   & U_{22} &  &  \\\\ & & \\ddots & \\\\ 0& & & U_{nn}\\end{bmatrix}}_{\\Large{\\boldsymbol{D}}} \\underbrace{\\begin{bmatrix} 1 & U_{12}/U_{11}& \\cdots & U_{1n}/U_{11} \\\\ 0 & 1 & \\cdots & U_{2n}/U_{22} \\\\ & & \\ddots & \\\\ 0 & 0 & \\cdots & 1\\end{bmatrix}}_{\\Large\\boldsymbol{U}'}\n\\]"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/02_linear_system.html#qr-분해-qr-factorization",
    "href": "src/numerical_analysis_using_julia/02_linear_system.html#qr-분해-qr-factorization",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "5 QR 분해 (QR-Factorization)",
    "text": "5 QR 분해 (QR-Factorization)\n\\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 을 \\(m \\times m\\) 행렬 \\(\\boldsymbol{Q}\\) 와 \\(m\\times n\\) 상 삼각행렬 \\(\\boldsymbol{R}\\) 분해하여 \\(\\boldsymbol{A}=\\boldsymbol{QR}\\) 로 나타내는 것을 QR 분해라 한다. 이 때 \\(\\boldsymbol{Q}\\) 행렬의 각 열벡터는 서로 직교하며, 그 크기가 \\(1\\) 이다. \\(m=n\\) 이면 \\(\\boldsymbol{Q}\\) 가 유니터리행렬(unitary matrix) 로 \\(\\boldsymbol{Q}\\boldsymbol{Q}^\\ast = \\boldsymbol{I}\\) 가 된다. 행렬 \\(\\boldsymbol{A}\\) 가 실수체에서 정의되었다면 \\(\\boldsymbol{Q}\\) 행렬은 직교행렬로 \\(\\boldsymbol{Q}\\boldsymbol{Q}^T = \\boldsymbol{I}\\) 이다.\n보통 이론적으로 QR 분해를 설명할 때는 그람-슈미트 과정(Gram-Schmidt process)을 사용하지만, 실제 수치해석적으로 구할 때는 Householder reflection 방법을 사용하거나 기븐스 회전(Givens rotation)을 사용한다.\n\n\n정사영 (Projection)\n\\(\\mathbb{F}\\) 에서 정의된 내적 벡터공간 \\(V\\) 의 기저 \\(\\{\\boldsymbol{u}_1,\\,\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_n\\}\\) 이 \\(\\langle \\boldsymbol{u}_i,\\,\\boldsymbol{u}_j \\rangle=\\delta_{ij}\\) 를 만족할 때 이 기저를 정규직교기저 (orthonormal basis) 라 한다. 내적이 정의되면 임의의 기저로부터 항상 정규직교기저를 구할 수 있으며, 이중 가장 유명한 방법이 그람-슈미트 방법이다.\n벡터 \\(\\boldsymbol{v}\\) 의 \\(\\boldsymbol{u}\\) 에 대한 정사영 \\(\\textrm{Proj}_\\boldsymbol{u} \\boldsymbol{v}\\) 는 다음과 같이 정의된다.\n\\[\n\\textrm{Proj}_{\\boldsymbol{u}}\\boldsymbol{v} := \\dfrac{\\langle\\boldsymbol{v},\\, \\boldsymbol{u}\\rangle}{\\langle \\boldsymbol{u,\\, u}\\rangle} \\boldsymbol{u}\n\\]\n\\(\\text{Proj}_\\boldsymbol{u}\\boldsymbol{v}\\) 는 \\(\\boldsymbol{u}\\) 에 평행하며 \\(\\boldsymbol{v}-\\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v}\\) 는 \\(\\boldsymbol{u}\\) 에 수직하다. 즉\n\\[\n\\langle  \\boldsymbol{u} , \\,\\boldsymbol{v}-\\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v} \\rangle  = \\boldsymbol{0}\n\\]\n이다. \\(\\boldsymbol{v} = \\text{Proj}_\\boldsymbol{u}\\boldsymbol{v} + (\\boldsymbol{v} - \\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v})\\) 이므로 \\(\\boldsymbol{v}\\) 를 \\(\\boldsymbol{u}\\) 와 평행한 성분과 \\(\\boldsymbol{u}\\) 에 수직한 성분으로 분리할 수 있다는 것을 알게 되었다. 단위벡터 \\(\\boldsymbol{e} = \\dfrac{\\boldsymbol{u}}{\\|\\boldsymbol{u}\\|}\\) 를 생각하면,\n\\[\n\\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v} = \\langle \\boldsymbol{v },\\,\\boldsymbol{e}\\rangle\\, \\boldsymbol{e}\n\\]\n이다.\n\n\n\n그람-슈미트 과정\n그람-슈미트 과정을 통해 유한차원 내적 벡터공간에서 주어진 독립 벡터를 이용하여 같은 갯수의 정규 직교 벡터를 얻을 수 있다. \\(N\\) 차원 내적 벡터 공간 \\(V\\) 에서 \\(M\\) 개의 독립벡터 \\(\\{\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_M\\}\\) 가 주어졌다고 하자. (당연히 \\(M \\le N\\) 이다). 다음을 이용하여 \\(\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_M\\) 을 얻을 수 있다. 이를 그람-슈미트 과정이라고 한다.\n\\[\n\\begin{aligned}\n\\boldsymbol{u}_1 &=  \\boldsymbol{v}_1, \\hat{\\boldsymbol{u}}_1 = \\dfrac{\\boldsymbol{u}_1}{\\|\\boldsymbol{u}_1\\|}, \\\\\n\\boldsymbol{u}_i &= \\boldsymbol{v}_{i} - \\sum_{j=1}^{i-1} \\text{Proj}_{\\boldsymbol{u}_j} \\boldsymbol{v}_i = \\boldsymbol{v}_i-\\sum_{j=1}^{i-1} \\left\\langle \\boldsymbol{v}_i,\\,\\hat{\\boldsymbol{u}}_j \\right\\rangle\\hat{\\boldsymbol{u}}_j,\\qquad \\hat{\\boldsymbol{u}}_i = \\dfrac{\\boldsymbol{u}_i}{\\|\\boldsymbol{u}_i\\|}\n\\end{aligned}\n\\]\n그람 슈미트 과정에 대해 다음 명제가 성립함을 안다.\n\n연습문제 1 독립벡터의 집합 \\(\\{\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_M\\}\\) 로부터 그람 슈미트 과정을 통해 얻은 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_M\\}\\) 는 각각 단위행렬이며 서로 직교한다. 즉 \\(\\hat{\\boldsymbol{u}}_i \\cdot \\hat{\\boldsymbol{u}}_j = \\delta_{ij}\\) 이다.\n\n\n연습문제 2 벡터의 집합 \\(\\{\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_M\\}\\) 에서 \\(\\boldsymbol{v}_k\\) 를 \\(\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_{k-1}\\) 의 선형결합으로 표현할 수 있을 때 그람-슈미트 과정을 통해 얻은 벡터는 영벡터이다.\n\n\n\n\n그람 슈미트 과정을 이용한 QR 분해 (QR decomppsition)\n이제 우리는 주어진 독립벡터들로 정규직교벡터를 구성하는 법을 배웠다. 여기서는 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 의 열벡터 \\(\\boldsymbol{A}_{:1},\\ldots\\), \\(\\boldsymbol{A}_{:n}\\) 에 대해 그람-슈미트 과정을 수행한다고 하자. \\[\n\\begin{aligned}\n\\boldsymbol{u}_1 &=  \\boldsymbol{A}_{:1},\\qquad \\hat{\\boldsymbol{u}}_1 = \\dfrac{\\boldsymbol{u}_1}{\\|\\boldsymbol{u}_1\\|}, \\\\\n\\boldsymbol{u}_j &= \\boldsymbol{A}_{:j} - \\sum_{k=1}^{j-1} \\text{Proj}_{\\boldsymbol{u}_k} \\boldsymbol{A}_{:j} = \\boldsymbol{A}_{:j}-\\sum_{k=1}^{j-1} \\left\\langle \\boldsymbol{A}_{:j},\\,\\hat{\\boldsymbol{u}}_k \\right\\rangle\\hat{\\boldsymbol{u}}_k,\\qquad \\hat{\\boldsymbol{u}}_j = \\dfrac{\\boldsymbol{u}_j}{\\|\\boldsymbol{u}_j\\|}\n\\end{aligned}\n\\] 라 하면,\n\\[\nA_{ij}=(\\boldsymbol{A}_{:j})_i = \\sum_{k=1}^n \\left(\\langle \\boldsymbol{A}_{:j},\\,\\hat{\\boldsymbol{u}}_k\\rangle \\hat{\\boldsymbol{u}}_k \\right)_i\n\\] 이다. 이 때 \\(\\boldsymbol{Q},\\, \\boldsymbol{R}\\) 을 다음과 같이 정의하면 \\(\\boldsymbol{A}= \\boldsymbol{QR}\\) 이 된다.\n\\[\nQ_{ik} := (\\hat{\\boldsymbol{u}}_k)_i,\\qquad R_{kj} := \\langle \\boldsymbol{A}_{:j},\\,\\hat{\\boldsymbol{u}}_k\\rangle\n\\]\n즉 \\(\\boldsymbol{Q}\\) 의 \\(i\\) 번째 열벡터는 \\(\\boldsymbol{A}\\) 의 각각의 열벡터에 대해 그람-슈미트 과정을 수행했을 때의 단위벡터 혹은 영벡터(연습문제 2) 이며 \\(\\boldsymbol{R}\\) 은 그람-슈미트 과정에서의 계수이다. 아래는 그람-슈미트 과정에 의한 QR 분해를 구현한 코드이다.\nfunction qr_gram_schmidt(A::AbstractMatrix{T}, normeps=1.0e-14) where T&lt;:Number\n    M, N = size(A)\n    Q = zeros(Float64, (M, N))\n    R = zeros(Float64, (N, N))\n    \n    Q[:,1] = A[:,1]/norm(A[:,1])\n    R[1,1] = dot(A[:,1], Q[:,1])\n\n    for j = 2:N\n        Uj = A[:,j] \n        for k = 1:j-1\n            R[k, j] = dot(A[:,j], Q[:, k])\n            Uj = Uj .- R[k, j] .* Q[:,k]\n        end\n        if norm(Uj)&gt;normeps\n            Q[:,j]= Uj/norm(Uj)\n            R[j, j] = dot(A[:,j], Q[:, j])\n        end \n    end\n    return Q, R\n\nend\n\n여기서 norm(A) 는 벡터의 노름을 구하는데 사용되었으며, 정확히는 norm(A, p::Real=2) 의 형태로 벡터, 혹은 행렬의 \\(p\\)-노름을 구하는데 사용되는 함수이다. 앞선 벡터들의 선형결합인 벡터는 영벡터가 되어야 하지만 Roundoff 에러로 인해 0 이 아닌 작은 노름을 가질 수 있으므로, 함수의 normeps 보다 작은 값을 가질 경우 영벡터로 간주한다.\n실제로는 그람-슈미트 방법을 이용한 QR-분해는 잘 사용되지 않는데, round-off 에러가 발생하여 수치해석적으로 불안정하기 때문이다. 보통은 밀집 행렬의 경우 하우스홀더 변환을 통한 방법을 사용한다. 하우스홀더 변환을 통한 QR 분해는 –to be done– 를 참고하라."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03I_polynomial.html",
    "href": "src/numerical_analysis_using_julia/03I_polynomial.html",
    "title": "일변수 다항식의 Julia 구현",
    "section": "",
    "text": "수치해석에서는 다항식을 아주 많이 사용한다. 2023년 9월 현재 Julia 언어의 생태계에서는 Polynomials.jl 이 다항식을 다루는 패키지로 널리 사용되지만 아직 표준적인 라이브러리라고는 볼 수 없다. 이것을 사용해도 되지만 일단 수치해석과 julia 언어에 대한 연습으로 다항식을 표현하는 복합 타입(struct type) 을 만들어보자. 그 이름은 일단 SimplePolynomial 로 하도록 하자. 전체 파일은 simplepolynomials.jl 로 제공된다.\nJulia 는 객체 지향 언어가 아니기 때문에 클래스와 클래스의 상속이라는 개념이 존재하지 않으며 대부분 복합 타입이 그 역할을 대신한다. 복합 타입에 대해서는 복합 타입 과 공식 매뉴얼의 Types 를 참고하라. 복합 타입의 가장 큰 장점중의 하나는 타입 변수를 함수처럼 사용 할 수 있다는 것이다. 만약 우리가 계수로 SimpliePolynomial 복합 타입을 만들었다면, 이 복합 타입 변수를 함수처럼 사용 할 수 있다. 여기서는 그것을 사용한다.\n다항식 함수값의 계산을 위해 julia 는 evalpoly 함수를 제공한다. evalpoly(1.0, [2.0, 3.0]) 은 다항식 \\(p(x)=2.0+3.0x\\) 에 대해 p(1.0) 을 계산해준다. 자세한 것은 evalpoly 에 대한 자체 설명을 확인하라. 일변수 다항식을 구현하는 이유는 단순히 다항식의 함수값을 계산하는 것 이외에 다항식의 덧셈, 뺄셈, 곱셈, 미분, 적분과 기타 앞으로 배울 다항식에 관련된 여러 기능이 필요해서이다. evalpoly 는 이것까지 제공하지는 않는다.\n\n\n\n일단 다음의 조건을 만족하도록 뼈대를 만들자.\n\n계수를 입력하면 그에 맞는 다항식 복합타입 객체가 생성되도록 한다. 예를 들어 SimpliePolynomial([1, 2, 3]) 은 \\(1+2x+3x^3\\) 에 해당하는 다항식 객체를 생성하도록 한다.\n계수의 타입을 타입 매개변수로 받는 복합타입으로 한다.\n복합타입을 함수처럼 사용할 수 있도록 한다.\nBase.show 함수가 SimplePolynomial 객체를 보기 좋게 출력 할 수 있도록 한다.\n\nusing LinearAlgebra\nexport SimplePolynomial, derivative, integrate, monic, definite_integrate\n\nstruct SimplePolynomial{T}\n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(a[1:a_last])\n        end\n    end\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Number\n    return evalpoly(x, p.coeffs)\nend\n\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n\nfunction Base.show(io::IO, p::SimplePolynomial{T}) where T&lt;:Number\n    result = \"\"\n    n = length(p)\n    if n == 1 && iszero(p.coeffs[1])\n        result = \"0\"\n    else \n        for (i, v) in enumerate(p.coeffs[end:-1:1])\n            vp = string(abs(v))\n            if v &gt; zero(T) && i&gt;1\n                result *= \" + \" * vp * \" x^$(n-i)\"\n            elseif v&lt; zero(T) && i &gt; 1\n                result *= \" - \" * vp * \" x^$(n-i)\"\n            elseif v &gt; zero(T)\n                result *= vp * \" x^$(n-i)\"\n            elseif v&lt;zero(T)\n                result *= \" -\"*vp * \" x^$(n-i)\"\n            end\n\n            if i == n\n                if !iszero(v)\n                    result = result[1:end-4]\n                else \n                    result = result\n                end\n            end\n        end\n    end\n    println(io, \"SimplePolynomial($(result[1:end]))\")\nend\nSimplePolynomial 은 immutable 한 복합타입으로 구현되었다. 즉 멤버인 coeffs 는 변경 될 수 없다. 7번째 줄부터 시작하는 라인은 복합타입 객체를 생성하는 생성자로 내부생성자 (inner constructor) 를 사용하였다. 여기서 where P &lt;: Number 는 T 의 타입을 Number 의 하위타입 으로 제한한다. 17 번째 줄부터 시작하는 함수 SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number} 는 계수의 타입을 T 로 지정한다. 즉 생성할 때 사용하는 계수의 타입을 T 로 변환한다. 아래 코드의 In [5] 를 확인해보라.\n28 번째 라인 이후는 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수이다. 예를 들어 CompType 이라는 복합타입을 정의하고 comp 라는 CompType 변수를 할당했다면, 필요할 경우 comp(x) 나 comp(x, y) 처럼 복합타입의 변수를 함수로 정의 할 수 있다. 함수의 정의는 일반적인 함수 이름에 (p::CompType) 이 들어가는 것과, 함수 정의 내부에서 CompType 변수의 필드를 사용 할 수 있다는 것을 제외하면 일반적인 함수의 정의와 같다. 여기서 p 는 CompType 변수를 대신하는 함수 내부의 변수이다.\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Number\n    return evalpoly(x, p.coeffs)\nend\n를 보자. p 는 SimplePolynomial 타입이므로 coeffs 필드를 가지고 있다. 예를 들어 mypoly=SimplePolynomial([1.0, 2.0]) 이라고 정의했으면 mypoly 는 다항식 \\(1+2x\\) 를 의미하며 mypoly(1.0) 은 evalpoly(1.0, [1, 2]), 즉 \\(1 + 2.0 \\times 1.0\\) 을 반환한다. 이렇게 정의해주면 우리는 도트 연산자를 사용해 줄 수 있다. 아래의 In [4] 와 In [6] 을 보라.\n33번째 줄부터는 행렬에 대한 다항식을 구현하였으며 이를 위해 맨 앞에 LinearAlgebra 모듈을 임포트 했다. 행렬에 대한 다항식의 경우 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 이 필요하다.\n이제 실제 사용해보자 simplepolynomials.jl 이 존재하는 파일 경로를 include 해 준다. 그리고 나서 다음과 같이 사용 할 수 있다.\nIn [1]: include(\"simplepolynomials.jl\"); # 실제로는 simplepolynomials.jl 의 경로 전체를 절대경로, 혹은 상대경로로 입력한다\n\nIn [2]: p1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[2]: SimplePolynomial(3.0 x^2 + 2.0 x^1 + 1.0)\n\n\nIn [3]: p1(1.0)\nOut[3]: 6.0\n\nIn [4]: p1.([1.0, 2.0, 3.0])\nOut[4]: 3-element Vector{Float64}:\n  6.0\n 17.0\n 34.0\n\nIn [5]: p2=SimplePolynomial{Float32}([1,2,3,4])\nOut[5]: SimplePolynomial(4.0 x^3 + 3.0 x^2 + 2.0 x^1 + 1.0)\n\nIn [6]: p2.([-1.0, 0.0, 1.0])\nOut[6]: 3-element Vector{Float64}:\n -2.0\n  1.0\n 10.0\n\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자. 보통 다항식의 차수를 order 혹은 degree 라고 하는데 여기서는 계수의 길이에서 1을 뺀 값과 같다. 이것도 함수로 작성한다.\nBase.length(p::SimplePolynomial) = length(p.coeffs)\n\norder(p::SimplePolynomial) = length(p)-1\ndegree(p::SimplePolynomial) = order(p)\n\nJulia 에서는 많은 타입에 zero 와 one 함수가 구현되어 있다. zero(p) 는 p 타입의 덧셈에한 항등원을 반환하며, one(p) 는 p 와 같은 타입의 곱셈에 대한 항등원을 반환한다. 다항식의 zero 와 one 을 다음과 같이 구현한다.\nfunction Base.zero(a::P) where P&lt;:SimplePolynomial\n    return SimplePolynomial([zero(eltype(a.coeffs)), ])\nend\n\nfunction Base.one(a::P) where P&lt;:SimplePolynomial\n    return SimplePolynomial([one(eltype(a.coeffs)), ])\nend\n\n\n\n\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산과 단항연산(-) 을 정의하자. 단항 연산 - 는 -3 과 같이 덧셈에 대한 역원으로 변경시키는 연산을 말한다. 다항식과 연산되는 것은 다항식, 혹은 기본 수(number) 타입의 변수로 한다. 다만 나누기 / 의 경우 일단은 다항식/상수 만을 정의한다. 각각의 연산은 Base.:+, Base.:-, Base.:*, Base.:/ 연산자를 다중 디스패치 함으로서 구현한다.\nfunction Base.:-(b::P) where {P&lt;: SimplePolynomial}\n    coeffs = -b.coeffs\n    return SimplePolynomial(coeffs)\nend\n\nfunction Base.:+(a::T, b::SimplePolynomial{P}) where {T &lt;: Number, P &lt;: Number} \n    rT = promote_type(T, P)\n    coeffs = rT.(b.coeffs)\n    coeffs[1] += a\n    return SimplePolynomial(coeffs)\nend\n\nfunction Base.:+(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return a+b\nend\n\nfunction Base.:+(a::SimplePolynomial{P1}, b::SimplePolynomial{P2}) where {P1 &lt;: Number, P2 &lt;: Number} \n    rT = promote_type(P1, P2)\n    if length(b) &gt; length(a)\n        coeffs = zeros(rT, length(b))\n        coeffs[1:length(a)] = a.coeffs[:]\n        coeffs += b.coeffs\n    else \n        coeffs = zeros(rT, length(a))\n        coeffs[1:length(b)] = b.coeffs[:]\n        coeffs += a.coeffs\n    end\n    return SimplePolynomial(coeffs)\nend\n\nfunction Base.:-(a::SimplePolynomial{P1}, b::SimplePolynomial{P2}) where {P1 &lt;: Number, P2 &lt;: Number} \n    return a + (-b)\nend\n\nfunction Base.:-(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return b+(-a)\nend\n\nfunction Base.:-(a::T, b::SimplePolynomial{P}) where {T &lt;: Number, P &lt;: Number} \n    return a+(-b)\nend\n\nfunction Base.:*(a::T, b::SimplePolynomial{P}) where {T &lt;: Number, P &lt;: Number} \n    return SimplePolynomial(b.coeffs*a)\nend\n\nfunction Base.:*(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return SimplePolynomial(b.coeffs*a)\nend\n\nfunction Base.:*(a::SimplePolynomial{P1}, b::SimplePolynomial{P2}) where {P1 &lt;: Number, P2 &lt;:Number} \n    rT = promote_type(P1, P2)\n    ord1, ord2 = degree(a), degree(b)\n    ord = ord1*ord2\n    coef = zeros(rT, ord+2)\n    \n    for i in 0:ord1, j in 0:ord2\n        @inbounds coef[i+j+1] += a.coeffs[i+1]*b.coeffs[j+1]\n    end\n    return SimplePolynomial(coef)\nend\n\nfunction Base.:/(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return SimplePolynomial(b.coeffs/a)\nend\n\n최고차항의 계수가 1인 다항식을 monic 이라고 한다. 이에 대해서도 구현한다. monic 함수는 다항식의 최고차항의 계수가 a 일 때 전체 계수를 a 로 나누어주어 최고차 항의 계수를 1 로 만든다.\nfunction monic(p::P) where P&lt;:SimplePolynomial\n    return p/p.coeffs[end]\nend\n\n\n\n\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 derivative 와 정적분 함수 integrate 함수를 구현하였다. integrate 함수의 경우, 다항식만 입력되면 상수항이 0 인 부정적분, 다항식과 수(number) 하나가 입력되면 이 수가 상수항인 부정적분을 반환하며, 다항식과 수 두개가 입력되면 첫번째 수에서 두번째 수 까지의 정적분값을 반환하도록 하였다.\nfunction derivative(p::SimplePolynomial)\n    if length(p) &lt; 2 \n        return SimplePolynomial([one(eltype(p.coeffs)), ])\n    else\n        coeffs = p.coeffs[2:end] .* (1:(length(p)-1))\n        return SimplePolynomial(coeffs)\n    end\nend\n\nfunction integrate(p::SimplePolynomial, a::Union{Nothing, Number}=nothing, b::Union{Nothing, Number}=nothing) \n\n    if eltype(p.coeffs) &lt;: Integer\n        coeffs = zeros(Float64, length(p)+1)\n    else \n        coeffs = zeros(eltype(p.coeffs), length(p)+1)\n    end\n    \n    for i in 1:length(p.coeffs)\n        coeffs[i+1] = p.coeffs[i]/(i)\n    end\n    \n    if a === nothing && b === nothing # 상수항이 0 인 부정적분\n        coeffs[1] = zero(eltype(coeffs))\n        return SimplePolynomial(coeffs)\n    elseif a === nothing || b === nothing # 상수항이 a 혹은 b 로 주어진 부정적분\n        coeffs[1] = a\n        return SimplePolynomial(coeffs)\n    else # a 에서 b 구간 까지의 정적분\n        return evalpoly(b, coeffs) - evalpoly(a, coeffs)\n    end\nend\n\n\n\n\nmonic 다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n이다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다.\nfunction polynomial_from_roots(xp::AbstractVector{T}) where T&lt;:Number \n    return prod([SimplePolynomial([-x0, 1]) for x0 in xp])\nend\n그렇다면,\nIn [1]: include(\"simplepolynomials.jl\")\nOut[1]: newton_polynomial (generic function with 1 method)\n\nIn [2]: pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nOut[2]: SimplePolynomial(1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0)\n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다. 이 다항식 복합타입은 앞으로도 계속 개선되며 사용 될 것이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03I_polynomial.html#뼈대",
    "href": "src/numerical_analysis_using_julia/03I_polynomial.html#뼈대",
    "title": "일변수 다항식의 Julia 구현",
    "section": "",
    "text": "일단 다음의 조건을 만족하도록 뼈대를 만들자.\n\n계수를 입력하면 그에 맞는 다항식 복합타입 객체가 생성되도록 한다. 예를 들어 SimpliePolynomial([1, 2, 3]) 은 \\(1+2x+3x^3\\) 에 해당하는 다항식 객체를 생성하도록 한다.\n계수의 타입을 타입 매개변수로 받는 복합타입으로 한다.\n복합타입을 함수처럼 사용할 수 있도록 한다.\nBase.show 함수가 SimplePolynomial 객체를 보기 좋게 출력 할 수 있도록 한다.\n\nusing LinearAlgebra\nexport SimplePolynomial, derivative, integrate, monic, definite_integrate\n\nstruct SimplePolynomial{T}\n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(a[1:a_last])\n        end\n    end\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Number\n    return evalpoly(x, p.coeffs)\nend\n\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n\nfunction Base.show(io::IO, p::SimplePolynomial{T}) where T&lt;:Number\n    result = \"\"\n    n = length(p)\n    if n == 1 && iszero(p.coeffs[1])\n        result = \"0\"\n    else \n        for (i, v) in enumerate(p.coeffs[end:-1:1])\n            vp = string(abs(v))\n            if v &gt; zero(T) && i&gt;1\n                result *= \" + \" * vp * \" x^$(n-i)\"\n            elseif v&lt; zero(T) && i &gt; 1\n                result *= \" - \" * vp * \" x^$(n-i)\"\n            elseif v &gt; zero(T)\n                result *= vp * \" x^$(n-i)\"\n            elseif v&lt;zero(T)\n                result *= \" -\"*vp * \" x^$(n-i)\"\n            end\n\n            if i == n\n                if !iszero(v)\n                    result = result[1:end-4]\n                else \n                    result = result\n                end\n            end\n        end\n    end\n    println(io, \"SimplePolynomial($(result[1:end]))\")\nend\nSimplePolynomial 은 immutable 한 복합타입으로 구현되었다. 즉 멤버인 coeffs 는 변경 될 수 없다. 7번째 줄부터 시작하는 라인은 복합타입 객체를 생성하는 생성자로 내부생성자 (inner constructor) 를 사용하였다. 여기서 where P &lt;: Number 는 T 의 타입을 Number 의 하위타입 으로 제한한다. 17 번째 줄부터 시작하는 함수 SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number} 는 계수의 타입을 T 로 지정한다. 즉 생성할 때 사용하는 계수의 타입을 T 로 변환한다. 아래 코드의 In [5] 를 확인해보라.\n28 번째 라인 이후는 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수이다. 예를 들어 CompType 이라는 복합타입을 정의하고 comp 라는 CompType 변수를 할당했다면, 필요할 경우 comp(x) 나 comp(x, y) 처럼 복합타입의 변수를 함수로 정의 할 수 있다. 함수의 정의는 일반적인 함수 이름에 (p::CompType) 이 들어가는 것과, 함수 정의 내부에서 CompType 변수의 필드를 사용 할 수 있다는 것을 제외하면 일반적인 함수의 정의와 같다. 여기서 p 는 CompType 변수를 대신하는 함수 내부의 변수이다.\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Number\n    return evalpoly(x, p.coeffs)\nend\n를 보자. p 는 SimplePolynomial 타입이므로 coeffs 필드를 가지고 있다. 예를 들어 mypoly=SimplePolynomial([1.0, 2.0]) 이라고 정의했으면 mypoly 는 다항식 \\(1+2x\\) 를 의미하며 mypoly(1.0) 은 evalpoly(1.0, [1, 2]), 즉 \\(1 + 2.0 \\times 1.0\\) 을 반환한다. 이렇게 정의해주면 우리는 도트 연산자를 사용해 줄 수 있다. 아래의 In [4] 와 In [6] 을 보라.\n33번째 줄부터는 행렬에 대한 다항식을 구현하였으며 이를 위해 맨 앞에 LinearAlgebra 모듈을 임포트 했다. 행렬에 대한 다항식의 경우 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 이 필요하다.\n이제 실제 사용해보자 simplepolynomials.jl 이 존재하는 파일 경로를 include 해 준다. 그리고 나서 다음과 같이 사용 할 수 있다.\nIn [1]: include(\"simplepolynomials.jl\"); # 실제로는 simplepolynomials.jl 의 경로 전체를 절대경로, 혹은 상대경로로 입력한다\n\nIn [2]: p1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[2]: SimplePolynomial(3.0 x^2 + 2.0 x^1 + 1.0)\n\n\nIn [3]: p1(1.0)\nOut[3]: 6.0\n\nIn [4]: p1.([1.0, 2.0, 3.0])\nOut[4]: 3-element Vector{Float64}:\n  6.0\n 17.0\n 34.0\n\nIn [5]: p2=SimplePolynomial{Float32}([1,2,3,4])\nOut[5]: SimplePolynomial(4.0 x^3 + 3.0 x^2 + 2.0 x^1 + 1.0)\n\nIn [6]: p2.([-1.0, 0.0, 1.0])\nOut[6]: 3-element Vector{Float64}:\n -2.0\n  1.0\n 10.0\n\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자. 보통 다항식의 차수를 order 혹은 degree 라고 하는데 여기서는 계수의 길이에서 1을 뺀 값과 같다. 이것도 함수로 작성한다.\nBase.length(p::SimplePolynomial) = length(p.coeffs)\n\norder(p::SimplePolynomial) = length(p)-1\ndegree(p::SimplePolynomial) = order(p)\n\nJulia 에서는 많은 타입에 zero 와 one 함수가 구현되어 있다. zero(p) 는 p 타입의 덧셈에한 항등원을 반환하며, one(p) 는 p 와 같은 타입의 곱셈에 대한 항등원을 반환한다. 다항식의 zero 와 one 을 다음과 같이 구현한다.\nfunction Base.zero(a::P) where P&lt;:SimplePolynomial\n    return SimplePolynomial([zero(eltype(a.coeffs)), ])\nend\n\nfunction Base.one(a::P) where P&lt;:SimplePolynomial\n    return SimplePolynomial([one(eltype(a.coeffs)), ])\nend"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03I_polynomial.html#다항식의-사칙연산",
    "href": "src/numerical_analysis_using_julia/03I_polynomial.html#다항식의-사칙연산",
    "title": "일변수 다항식의 Julia 구현",
    "section": "",
    "text": "이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산과 단항연산(-) 을 정의하자. 단항 연산 - 는 -3 과 같이 덧셈에 대한 역원으로 변경시키는 연산을 말한다. 다항식과 연산되는 것은 다항식, 혹은 기본 수(number) 타입의 변수로 한다. 다만 나누기 / 의 경우 일단은 다항식/상수 만을 정의한다. 각각의 연산은 Base.:+, Base.:-, Base.:*, Base.:/ 연산자를 다중 디스패치 함으로서 구현한다.\nfunction Base.:-(b::P) where {P&lt;: SimplePolynomial}\n    coeffs = -b.coeffs\n    return SimplePolynomial(coeffs)\nend\n\nfunction Base.:+(a::T, b::SimplePolynomial{P}) where {T &lt;: Number, P &lt;: Number} \n    rT = promote_type(T, P)\n    coeffs = rT.(b.coeffs)\n    coeffs[1] += a\n    return SimplePolynomial(coeffs)\nend\n\nfunction Base.:+(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return a+b\nend\n\nfunction Base.:+(a::SimplePolynomial{P1}, b::SimplePolynomial{P2}) where {P1 &lt;: Number, P2 &lt;: Number} \n    rT = promote_type(P1, P2)\n    if length(b) &gt; length(a)\n        coeffs = zeros(rT, length(b))\n        coeffs[1:length(a)] = a.coeffs[:]\n        coeffs += b.coeffs\n    else \n        coeffs = zeros(rT, length(a))\n        coeffs[1:length(b)] = b.coeffs[:]\n        coeffs += a.coeffs\n    end\n    return SimplePolynomial(coeffs)\nend\n\nfunction Base.:-(a::SimplePolynomial{P1}, b::SimplePolynomial{P2}) where {P1 &lt;: Number, P2 &lt;: Number} \n    return a + (-b)\nend\n\nfunction Base.:-(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return b+(-a)\nend\n\nfunction Base.:-(a::T, b::SimplePolynomial{P}) where {T &lt;: Number, P &lt;: Number} \n    return a+(-b)\nend\n\nfunction Base.:*(a::T, b::SimplePolynomial{P}) where {T &lt;: Number, P &lt;: Number} \n    return SimplePolynomial(b.coeffs*a)\nend\n\nfunction Base.:*(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return SimplePolynomial(b.coeffs*a)\nend\n\nfunction Base.:*(a::SimplePolynomial{P1}, b::SimplePolynomial{P2}) where {P1 &lt;: Number, P2 &lt;:Number} \n    rT = promote_type(P1, P2)\n    ord1, ord2 = degree(a), degree(b)\n    ord = ord1*ord2\n    coef = zeros(rT, ord+2)\n    \n    for i in 0:ord1, j in 0:ord2\n        @inbounds coef[i+j+1] += a.coeffs[i+1]*b.coeffs[j+1]\n    end\n    return SimplePolynomial(coef)\nend\n\nfunction Base.:/(b::SimplePolynomial{P}, a::T) where {P &lt;: Number, T &lt;: Number} \n    return SimplePolynomial(b.coeffs/a)\nend\n\n최고차항의 계수가 1인 다항식을 monic 이라고 한다. 이에 대해서도 구현한다. monic 함수는 다항식의 최고차항의 계수가 a 일 때 전체 계수를 a 로 나누어주어 최고차 항의 계수를 1 로 만든다.\nfunction monic(p::P) where P&lt;:SimplePolynomial\n    return p/p.coeffs[end]\nend"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03I_polynomial.html#다항식의-미분과-적분",
    "href": "src/numerical_analysis_using_julia/03I_polynomial.html#다항식의-미분과-적분",
    "title": "일변수 다항식의 Julia 구현",
    "section": "",
    "text": "다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 derivative 와 정적분 함수 integrate 함수를 구현하였다. integrate 함수의 경우, 다항식만 입력되면 상수항이 0 인 부정적분, 다항식과 수(number) 하나가 입력되면 이 수가 상수항인 부정적분을 반환하며, 다항식과 수 두개가 입력되면 첫번째 수에서 두번째 수 까지의 정적분값을 반환하도록 하였다.\nfunction derivative(p::SimplePolynomial)\n    if length(p) &lt; 2 \n        return SimplePolynomial([one(eltype(p.coeffs)), ])\n    else\n        coeffs = p.coeffs[2:end] .* (1:(length(p)-1))\n        return SimplePolynomial(coeffs)\n    end\nend\n\nfunction integrate(p::SimplePolynomial, a::Union{Nothing, Number}=nothing, b::Union{Nothing, Number}=nothing) \n\n    if eltype(p.coeffs) &lt;: Integer\n        coeffs = zeros(Float64, length(p)+1)\n    else \n        coeffs = zeros(eltype(p.coeffs), length(p)+1)\n    end\n    \n    for i in 1:length(p.coeffs)\n        coeffs[i+1] = p.coeffs[i]/(i)\n    end\n    \n    if a === nothing && b === nothing # 상수항이 0 인 부정적분\n        coeffs[1] = zero(eltype(coeffs))\n        return SimplePolynomial(coeffs)\n    elseif a === nothing || b === nothing # 상수항이 a 혹은 b 로 주어진 부정적분\n        coeffs[1] = a\n        return SimplePolynomial(coeffs)\n    else # a 에서 b 구간 까지의 정적분\n        return evalpoly(b, coeffs) - evalpoly(a, coeffs)\n    end\nend"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03I_polynomial.html#근을-이용하여-다항식을-만들기",
    "href": "src/numerical_analysis_using_julia/03I_polynomial.html#근을-이용하여-다항식을-만들기",
    "title": "일변수 다항식의 Julia 구현",
    "section": "",
    "text": "monic 다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n이다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다.\nfunction polynomial_from_roots(xp::AbstractVector{T}) where T&lt;:Number \n    return prod([SimplePolynomial([-x0, 1]) for x0 in xp])\nend\n그렇다면,\nIn [1]: include(\"simplepolynomials.jl\")\nOut[1]: newton_polynomial (generic function with 1 method)\n\nIn [2]: pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nOut[2]: SimplePolynomial(1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0)\n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다. 이 다항식 복합타입은 앞으로도 계속 개선되며 사용 될 것이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_matrix_algebra.html",
    "href": "src/numerical_analysis_using_julia/03_matrix_algebra.html",
    "title": "Julia 에서의 행렬 계산",
    "section": "",
    "text": "지금까지는 Julia 의 기본적인 벡터와 행렬, 그리고 연산을 이용하여 일반적인 행렬에 대한 가우스 소거법과 LU 분해를 구현하였다. Julia 는 큰 벡터와 행렬을 다루기 위한 SparseArrays 모듈과 행렬 및 벡터 계산을 위한 LinearAlgebra 모듈을 기본으로 제공한다. 또한 다양한 형태의 행렬에 대한 특별한 연산도 제공한다. 이제 이런 기능들을 적극적으로 알아보도록 하자."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_matrix_algebra.html#sec-norm_and_condition_number",
    "href": "src/numerical_analysis_using_julia/03_matrix_algebra.html#sec-norm_and_condition_number",
    "title": "Julia 에서의 행렬 계산",
    "section": "1 노름(norm) 과 조건수",
    "text": "1 노름(norm) 과 조건수\n\n벡터의 노름\n벡터의 노름(norm) 은 벡터의 크기에 대한 척도로서 실수, 혹은 복소수의 절대값과 비슷한 역할을 한다. 보통 \\(n\\) 차원 공간에서 사용하는 피타고라스 정리에 의한 거리도 노름의 일종이다. 벡터공간에서의 노름은 특정한 성질을 만족하는 함수 가운데 선택된다.\n\n\n\n\n\n\n\n정의 1 (벡터공간의 노름) \\(\\mathbb{F}\\)-벡터공간 \\(V\\) 에서 정의된 함수 \\(\\|\\cdot\\| : V \\to \\mathbb{R}\\) 가 \\(\\boldsymbol{v},\\,\\boldsymbol{u}\\in V\\) 와 \\(\\alpha \\in \\mathbb{F}\\) 에 대해 다음을 만족할 때 이 함수는 벡터공간의 노름이 될 수 있다.\n  (\\(1\\)) \\(\\|\\boldsymbol{v}\\| \\ge 0\\),\n  (\\(2\\)) \\(\\|\\boldsymbol{v}\\| = 0 \\iff \\boldsymbol{v}=\\boldsymbol{0}\\),\n  (\\(3\\)) \\(\\|\\alpha \\boldsymbol{v} \\| = |\\alpha| \\|\\boldsymbol{v}\\|\\),\n  (\\(4\\)) \\(\\|\\boldsymbol{u}+\\boldsymbol{v}\\| \\le \\|\\boldsymbol{u}\\| + \\|\\boldsymbol{v}\\|\\)\n노름이 주어진 공간을 노름 벡터 공간 (normed vector space) 라고 하며, 가능한 노름 가운데 하나가 주어진다.\n\n\n\n\n\n벡터의 노름에 대한 성질을 알기 위해 다음 부등식을 알 필요가 있다.\n\n명제 1 (횔더부등식(Hölder’s inequality) 과 민코프스키 부등식(Minkowski’s ineqality)) \\(p\\ge 1\\) 이며 \\(1/p+1/q =1\\) 일 때 다음이 성립한다. \\[\n\\begin{aligned}\n\\text{H\\\"older's inequality} & \\sum_{i=1}^n |u_i v_i| \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}, \\\\\n\\text{Mincowski's inequality} & \\left(\\sum_{i=1}^n |u_i+v_i|^p\\right)^{1/p} \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p}.\n\\end{aligned}\n\\]\n\n\n(증명). 수학적 증명 의 Hölder 부등식 를 참고하라.\n\n\n\n\n\n\n\n\n\n정의 2 (\\(L_p\\)-노름 과 \\(\\infty\\)-노름) \\(p\\ge 1\\) 에 대해 다음과 같이 \\(L_p\\)-노름 \\(\\|\\cdot \\|_p\\) 를 정의한다.\n\\[\n\\|\\boldsymbol{v}\\|_p := \\left( \\sum_{i=1} |v_i|^p \\right)^{1/p}.\n\\]\n\n\n\n\n\n\\(p=1,\\,2,\\,\\infty\\) 인 경우가 많이 사용된다. \\(p=1\\) 인 경우는 맨해튼 노름(Manhattan norm) 혹은 taxicab norm 이라고 하며,\n\\[\n\\|\\boldsymbol{v}\\|_1 = \\sum_i |v_i|\n\\]\n이다. \\(p=2\\) 인 경우는 우리가 많이 사용하는 유클리드 노름(Euclidean norm) 으로\n\\[\n\\|\\boldsymbol{v}\\|_2 = \\sqrt{\\sum_i |v_i|^2}\n\\]\n이다. \\(p=\\infty\\) 인 경우는 상한 노름(maximum norm) 이라고 하며\n\\[\n\\|\\boldsymbol{v}\\|_{\\infty} = \\max_{i=1,\\ldots} |x_i|\n\\]\n이다. 혹은 단순히 \\(L_1,\\,L_2,\\,L_\\infty\\) 노름 이라고도 한다.\n\n다음은 쉽게 증명 할 수 있다.\n\n명제 2 \\(p=\\infty\\) 를 포함하여 \\(p \\ge 1\\) 일 때, 유한차원 벡터공간에서의 \\(L_p\\)-노름은 노름의 정의를 만족한다.\n\n\nJulia 에서는 LinearAlgebra 모듈의 norm(v, p=2) 로 정의되는 함수를 이용하여 계산 할 수 있으며 p 는 1, 2, Inf 가 가능한데 각각 \\(L_1,\\,L_2,\\,L_\\infty\\) 노름을 의미한다. 노름이 정의된 벡터공간에서 벡터를 그 크기로 나누는 것 (\\(\\boldsymbol{v}/\\|\\boldsymbol{v}\\|\\)) 을 정규화(normalization) 라고 하며 역시 LinearAlgebra 모듈에 normalize(v, p=2) 함수로 구현되어 있다. norm(v, p=2) 에서 p=2 는 p 의 기본값이 2 라는 의미이다. 즉, norm(v) 로 벡터만을 인자로 하여 함수를 호출했을 경우는 p=2 일 경우를 계산한다.\nIn [1]: using LinearAlgebra\n\nIn [2]: v=[1, 2, 3];\n\nIn [3]: norm(v, 1)\nOut[3]: 6.0\n\nIn [4]: norm(v, Inf)\nOut[4]: 3.0\n\nIn [5]: norm(v, 2)\nOut[5]: 3.7416573867739413\n\nIn [6]: normalize(v)\nOut[6]: 3-element Vector{Float64}:\n 0.2672612419124244\n 0.5345224838248488\n\n\n\n행렬의 노름\n행렬의 노름(norm) 역시 행렬의 크기에 대한 척도로서 특정한 성질을 만족하는 함수 가운데 선택된다.\n\n\n\n\n\n\n\n정의 3 행렬의 노름 \\(\\|\\cdot \\|: \\mathcal{M}_{m\\times n}(\\mathbb{F}) \\to \\mathbb{R}\\) 은 행렬 \\(\\boldsymbol{A},\\, \\boldsymbol{B}\\) 와 스칼라 \\(\\alpha\\) 에 대해 다음의 성질을 만족한다.\n\n\\(\\|\\boldsymbol{A}\\| \\ge 0\\),\n\\(\\|\\boldsymbol{A}\\| = 0 \\iff \\boldsymbol{A} = 0\\),\n\\(\\|\\alpha \\boldsymbol{A}\\| = |\\alpha| \\|\\boldsymbol{A}\\|\\),\n\\(\\|\\boldsymbol{A}+\\boldsymbol{B}\\| \\le \\|\\boldsymbol{A}\\|+\\|\\boldsymbol{B}\\|\\).\n\n또한 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m\\times n}(\\mathbb{F}),\\, \\boldsymbol{B} \\in \\mathcal{M}_{n\\times p}(\\mathbb{F})\\) 에 대해 다음이 성립한다.\n\n\\(\\|\\boldsymbol{AB}\\| \\le \\|\\boldsymbol{A}\\| \\cdot\\|\\boldsymbol{B}\\|\\).\n\n\n\n\n\n\n위의 정의 중 5번을 제외한 나머지 성질은 벡터에 대해서 성립하며, 5번은 행렬의 노름에만 성립하는 고유한 성질이다.\n\n\n프로베니우스 노름\n프로베니우스 노름은 힐버트-슈미트 노름(Hilbert-Schmidt norm), 혹은 슈어 노름(Schur norm) 으로도 불린다.\n선형대수학에서 배웠다시피 \\(\\mathcal{M}_{m\\times n}(\\mathbb{F})\\) 은 벡터공간을 이루며 각각의 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m\\times n}(\\mathbb{F})\\) 도 벡터므로, 벡터에 대한 노름 처럼 행렬에 대한 노름도 정의 할 수 있다. 대표적으로 프로베니우스 노름(Frobenius norm) \\(\\|\\cdot \\|_F\\) 은 행렬을 벡터처럼 간주했을 때의 \\(L_2\\) 노름이다.\n\n\n\n\n\n\n\n정의 4 (프로베니우스 노름) \\(m \\times n\\) 행렬에 대한 프로베니우스 노름(Frobenius norm) 은 다음과 같이 정의된다. \\[\n\\|\\boldsymbol{A}\\|_F := \\left(\\sum_{i=1}^m \\sum_{j=1}^n |A_{ij}|^2\\right)^{1/2} = \\sqrt{\\text{tr}(\\boldsymbol{AA}^\\dagger)}\n\\]\n\n\n\n\n\n예제 1 프로베니우스 노름이 행렬의 노름의 정의에 나열된 5가지의 성질을 만족한다는 것을 보여라.\n\n\n\n\n자연스러운 노름\n행렬은 벡터공간에서 정의된 선형 함수로서의 의미가 더 중요하기 때문에, 벡터가 연산되었을 때 그 크기가 어떻게 되는지가 더 중요한 경우가 많다. 이런 의미에서 행렬의 노름을 벡터와의 연산에 대해 정의할 수 있는데 이렇게 정의된 행렬의 노름은 유도된 행렬 노름 (induced matrix norm), 자연스러운 행렬 노름(natural matrix norm) 혹은 종속된 노름(subordinate norm) 이라고 하며 정사각 행렬의 경우는 연산자 노름(operator norm) 이라고도 한다. 앞으로 행렬의 노름을 이야기할 때는 별다른 언급이 없다면 자연스러운 노름을 의미한다.\n\n\n\n\n\n\n\n\n정의 5 (행렬의 노름) \\(\\mathcal{M}_n(\\mathbb{F})\\) 에서의 노름이 \\(\\|\\cdot \\|_\\alpha\\), \\(\\mathcal{M}_m(\\mathbb{F})\\) 에서의 노름이 \\(\\| \\cdot \\|_\\beta\\) 로 정의되었다고 하자. \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대한 연산자 노름은 다음과 같이 정의된다.\n\\[\n\\|\\boldsymbol{A}\\|_{\\alpha,\\,\\beta} := \\sup \\{\\|\\boldsymbol{Av}\\|_\\beta : \\|\\boldsymbol{v}\\|_\\alpha=1\\} = \\sup_{\\|\\boldsymbol{v}\\|_\\alpha = 1} \\|\\boldsymbol{Av}\\|_\\beta\n\\]\n위의 정의와 다음의 정의는 같다. \\[\n\\|\\boldsymbol{A}\\|_{\\alpha,\\,\\beta} = \\sup \\left\\{\\dfrac{\\|\\boldsymbol{Av}\\|_\\beta}{\\|\\boldsymbol{v}\\|_\\alpha} : \\boldsymbol{v}\\in \\mathbb{F}^n,\\, \\boldsymbol{v}\\ne \\boldsymbol{0} \\right\\} = \\sup_{\\|\\boldsymbol{v}\\|_\\alpha \\ne 0}\\dfrac{\\|\\boldsymbol{Av}\\|_\\beta}{\\|\\boldsymbol{v}\\|_\\alpha}.\n\\]\n\n\n\n\n\n\n명제 3 자연스러운 노름은 행렬의 노름의 정의에 나열된 5 가지 성질을 만족한다.\n\n\n(증명). \\(1\\), \\(2\\), \\(3\\), \\(4\\)는 쉽게 보일 수 있다. 각각의 벡터공간에서 노름을 상징하는 아래첨자는 생략해도 이해하는데 무리가 없을 것이다.\n\\(\\text{5}\\). 우선 \\(\\|\\boldsymbol{Av}\\| \\le \\|\\boldsymbol{A}\\| \\cdot \\|\\boldsymbol{v}\\|\\) 임을 보이자. \\(\\boldsymbol{v}=\\boldsymbol{0}\\) 일 때는 자명하다. \\(\\boldsymbol{v}\\ne \\boldsymbol{0}\\) 이라면,\n\\[\n\\|\\boldsymbol{A}\\| = \\sup_{\\|\\boldsymbol{v}\\|\\ne 0} \\left\\{ \\dfrac{\\|\\boldsymbol{Av}\\|}{\\|\\boldsymbol{v}\\|} \\right\\} \\ge \\dfrac{\\|\\boldsymbol{Av}\\|}{\\|\\boldsymbol{v}\\|}\n\\]\n이므로 \\(\\|\\boldsymbol{Av}\\| \\le \\|\\boldsymbol{A}\\|\\cdot \\|\\boldsymbol{v}\\|\\) 이다. 이를 이용하면 \\[\n\\|\\boldsymbol{ABv}\\| \\le \\|\\boldsymbol{A}\\| \\cdot \\|\\boldsymbol{Bv}\\| \\le \\| \\boldsymbol{A}\\| \\cdot \\|\\boldsymbol{B}\\| \\cdot \\|\\boldsymbol{v}\\|\n\\]\n이므로 \\(\\dfrac{\\|\\boldsymbol{ABv}\\|}{\\|\\boldsymbol{v}\\|} \\le \\|\\boldsymbol{A}\\|\\|\\boldsymbol{B}\\|\\) 이다. 따라서,\n\\[\n\\|\\boldsymbol{AB}\\| =\\sup \\left\\{ \\dfrac{\\|\\boldsymbol{ABv}\\|}{\\|\\boldsymbol{v}\\|}\\right\\} \\le \\|\\boldsymbol{A}\\| \\|\\boldsymbol{B}\\|\n\\]\n이다. \\(\\square\\)\n\n\n다음은 증명 과정에서 보였지만 별도로 언급할 가치가 있다.\n\n따름정리 1 \\(\\|\\boldsymbol{Av}\\|\\le \\|\\boldsymbol{A}\\|\\cdot \\|\\boldsymbol{v}\\|\\) 이다.\n\n이것이 의미하는 것은 행렬 \\(\\boldsymbol{A}\\) 의 노름은 \\(\\boldsymbol{A}\\) 에 의해 변환되는 벡터의 노름이 변화하는 최대값을 규정한다는 것으로, 앞으로 매우 많이 나올 내용이다.\n행렬의 정의역(domain)과 공역(codomain)에서의 노름이 동일할 때 \\(\\|\\boldsymbol{A}\\|_\\alpha\\) 와 같이 노름에 대한 첨자를 하나만 표기한다. 또한 노름을 계산할 때 \\(L_p\\) 벡터 노름, 그중에서도 \\(p=1, 2, \\infty\\) 를 많이 사용한다. 즉\n\\[\n\\|\\boldsymbol{A}\\|_p = \\sup \\left\\{ \\dfrac{\\|\\boldsymbol{Av}\\|_p}{\\|\\boldsymbol{v}\\|_p}\\right\\}\n\\]\n이다.\n\n\n명제 4 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 일 때, \\[\n\\begin{aligned}\n\\|\\boldsymbol{A}\\|_\\infty &= \\max_{i=1,\\ldots,\\,m} \\sum_{j=1}^n |A_{ij}|,\\\\\n\\|\\boldsymbol{A}\\|_1 &= \\max_{j=1,\\ldots,\\,n} \\sum_{i=1}^m |A_{ij}|,\\\\\n\\end{aligned}\n\\]\n이다.\n\n\n(증명). 벡터 \\(L_p\\)-노름의 정의로부터, \\[\n\\|\\boldsymbol{Av}\\|_\\infty = \\sup \\left\\{ \\left|\\sum_{j=1}^n A_{ij}v_j\\right| : i=1,\\ldots,\\,m,\\, \\|\\boldsymbol{v}\\|_\\infty = 1 \\right\\}\n\\] 이다. \\(\\|\\boldsymbol{v}\\|_\\infty=1\\) 이면 \\(|v_j|\\le 1,\\, i=1,\\ldots,\\,n\\) 이므로 \\[\n\\left| \\sum_{j=1}^n A_{ij}v_j\\right| \\le \\sum_{j=1}^n |A_{ij}|\\cdot |v_j| \\le \\sum_{j=1}^n |A_{ij}|\n\\] 인데 \\(v_j = \\text{sign}(A_{ij})\\) 일 때 등호가 성립한다. 따라서, \\(\\displaystyle \\|\\boldsymbol{A}\\|_\\infty = \\max_{i=1,\\ldots,\\,m} \\sum_{j=1}^n |A_{ij}|\\) 이다.\n\\(\\|\\boldsymbol{A}\\|_1 = \\displaystyle \\sup_{\\|\\boldsymbol{v}\\|_1=1} \\|\\boldsymbol{Av}\\|_1\\) 이며, \\(\\displaystyle \\|\\boldsymbol{v}\\|_1 = \\sum_{j=1}^n |v_j|\\) 이다.\n\\[\n\\begin{aligned}\n\\|\\boldsymbol{Av}\\|_1 &= \\sum_{i=1}^m \\left| \\sum_{j=1}^n A_{ij}v_j\\right| \\le \\sum_{i=1}^m \\sum_{j=1}^n |A_{ij}| \\cdot |v_j| = \\sum_{j=1}^n |v_j| \\left(\\sum_{i=1}^n |A_{ij}|\\right) \\\\\n&\\le \\max_{j=1,\\ldots,n} \\left(\\sum_{i=1}^n |A_{ij}|\\right) \\\\\n\\end{aligned}\n\\]\n이다. \\(\\displaystyle \\sum_{i=1}^n |A_{ij}|\\) 이 최대가 되는 \\(j\\) 인덱스를 찾아 \\(j_M\\) 이라 하면\n\\[\n\\|\\boldsymbol{Ae}_{j_M}\\|_1 = \\sum_{i=1}^m |A_{i,j_M}| = \\max_{j=1,\\ldots,n} \\sum_{i=1}^m |A_{ij}|\n\\]\n이다. 따라서 \\(\\displaystyle \\|\\boldsymbol{A}\\|_1 = \\max_{j=1,\\ldots,\\,n}\\sum_{i=1}^m |A_{ij}|\\) 이다. \\(\\square\\)\n\n\nJulia 에서 행렬의 \\(L_p\\) 노름은 opnorm(A, p=2) 로 구현되었으며 가능한 p 값은 1, 2 와 Inf 로 각각 \\(L_1,\\, L_2,\\,L_\\infty\\) norm을 계산한다. Frobenius 노름은 norm(A, 2) 로 벡터의 norm 처럼 계산 할 수 있다.\nIn [7]: A = [1 3 2; 4.0 2.0 -3.0];\n\nIn [8]: opnorm(A, 1), opnorm(A, 2), opnorm(A, Inf)\nOut[8]: (5.0, 5.47722557505166, 9.0)\n\nIn [9]: norm(A, 2) # Frobenius norm\nOut[9]: 6.557438524302"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_matrix_algebra.html#다양한-행렬들",
    "href": "src/numerical_analysis_using_julia/03_matrix_algebra.html#다양한-행렬들",
    "title": "Julia 에서의 행렬 계산",
    "section": "2 다양한 행렬들",
    "text": "2 다양한 행렬들\n\n성긴행렬과 밀집행렬\n수학적으로 성긴행렬(혹은 희소행렬, sparse matrix) 은 행렬 성분의 대다수가 0 인 행렬을 의미하며, 반대의 경우를 밀집 행렬(dense matrix) 이라고 한다. 우리가 지금까지 다룬 행렬들은 행렬의 모든 성분을 컴퓨터가 저장하였다. 그러나 행렬이 매우 큰 경우, 예를 들면 Float64 타입의 \\(100K \\times 100K\\)(\\(1K=1,000\\)) 행렬은 성분을 저장하는 데만 80 Gbytes 의 저장공간을 차지하므로 개인 컴퓨터에서는 처리가 거의 불가능하며, 실제로 많이 다루는 시스템은 이것보다 훨씬 클 수 가 있다. 다행히 우리가 관심있는 시스템 가운데 상당수는 행렬의 대부분의 성분이 \\(0\\) 인데, 이 경우 행렬의 모든 성분을 저장하는 것이 아니라 \\(0\\) 이 아닌 성분만을 그 인덱스와 함께 저장하여 더 작은 저장공간에서 더 빠르게 계산 할 수 있다. 수치해석에서는 이렇게 행렬의 인덱스와 값을 저장하고, 인덱스가 지정되지 않은 행렬을 \\(0\\) 으로 간주하는 행렬을 성긴 행렬이라 하며, 우리가 지금 까지 다뤘던, 인덱스에 따라 순차적으로 성분을 저장하는 행렬을 밀집 행렬 (dense matrix) 이라 한다.\n다차원 배열에 대해서도 성긴 배열을 생각 할 수 있으며 Julia 의 표준 라이브러리에 포함된 SparseArrays 모듈을 이용하여 1차원 배열인 성긴 벡터와, 2차원 배열인 성긴 행렬을 지원한다. Julia 에서의 희소행렬은 내부적으로 아래와 같이 구현되어 있다. 5개의 멤버를 갖는 구조체이며 행렬의 크기와, 행, 열, 값을 갖는다. SmarseMatrixCSC 의 CSC 는 희소행렬을 내부적으로 저장할 때 쓰는 일종의 압축 방식을 표현한다.\nstruct SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}\n    m::Int                  # Number of rows\n    n::Int                  # Number of columns\n    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)\n    rowval::Vector{Ti}      # Row indices of stored values\n    nzval::Vector{Tv}       # Stored values, typically nonzeros\nend\n가장 기본적인 생성 방법은 sparse() 함수를 이용하는 것이다. 아래의 예에서 A 는 밀집행렬이며 이것을 sparse 함수를 통해 희소행렬로 만들었다. 혹은 sparse(I, J, V) 를 통해서도 생성할 수 있는데, I 는 행 인덱스를 나타내는 벡터, J 는 열 인덱스를 나타내는 벡터, V 는 값을 나타내는 벡터이다. 즉, B=sparse(I, J, V) 라면,\n\\[\nB_{I[i], J[i]}=V[i], \\, i=1,\\,2,\\ldots\n\\]\n이다.\nIn [1]: using LinearAlgebra, SparseArrays\n\nIn [2]: A = Matrix(1.0I, 3, 3)\nOut[2]: 3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\nIn [3]: sparse(A)\nOut[3]: 3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 1.0   ⋅    ⋅ \n  ⋅   1.0   ⋅ \n  ⋅    ⋅   1.0\n\nIn [4]: B = sparse([1, 1, 2, 3], [1, 3, 2, 3], [-1.0, 2.0, 0.0, 4.0])\nOut[4]: 3×3 SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n -1.0   ⋅   2.0\n   ⋅   0.0   ⋅ \n   ⋅    ⋅   4.0\n\nIn [5]: dropzeros(B)\nOut[5]: 3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n -1.0   ⋅   2.0\n   ⋅    ⋅    ⋅ \n   ⋅    ⋅   4.0\n마지막의 dropzeros() 함수는 희소 행렬 내의 \\(0\\) 을 제거하여 저장공간을 줄인다. B=sparse(I, J, V) 형식으로 생성하면, B 행렬의 크기는 I 와 J 벡터의 최대값으로 정해지지만, 행렬의 크기를 정할 수 있다. 예를 들어,\nIn [6]: sparse([1, 2], [1, 3], [1, -1], 4, 4)\nOut[6]: 4×4 SparseMatrixCSC{Int64, Int64} with 2 stored entries:\n 1  ⋅   ⋅  ⋅\n ⋅  ⋅  -1  ⋅\n ⋅  ⋅   ⋅  ⋅\n와 같이 sparse(I, J, V, m, n) 형식으로 생성하면 이 희소행렬은 \\(m \\times n\\) 행렬이 된다. 희소벡터는 sparsevec(I, V, m) 형식으로 생성 할 수 있다.\nIn [7]: sparsevec([1, 4], [2, -1], 5)\nOut[7]: 5-element SparseVector{Int64, Int64} with 2 stored entries:\n  [1]  =  2\n  [4]  =  -1\n영행렬 혹은 영벡터는 spzeros() 함수를 통해 생성한다. 성긴 단위행렬은 sparse(I, 4, 4) 와 같이 생성한다. 단 I 는 LinearAlgebra 모듈에 정의되어 있으므로 using LinearAlgebra 를 한 후 사용할 수 있다.\nusing LinearAlgebra, SparseArrays\nsm1 = spzeros(Float32, 10, 10) # Float32 타입의 값을 갖는 10x10 성긴행렬\nsm2 = spzeros(5, 5) # 타입이 지정되지 않으면 Float64 타입의 값을 갖는다.\nsv = spzeros(4) #Float64 타입의 4 차원 벡터\nsI = sparse(I, 4, 4) # 4xt 단위행렬\n\n\n\n타입으로 정의된 행렬\nLinearAlgebra.jl 은 선형대수학에서 사용되는 특별한 명칭이 붙은 행렬중 일부를 특별히 별도의 타입으로 지정하였다. 아주 단순한 예를 들자면 선형 시스템 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 풀 때, \\(\\boldsymbol{A}\\) 가 대각성분을 제외한 성분이 모두 \\(0\\) 인 대각행렬이라면 쉽게 풀 수 있으며, 상삼각행렬이나, 하삼각행렬이라도 일반적인 행렬에 비해서도 훨씬 쉽게 풀 수 있다. 그러나 컴퓨터가 임의로 \\(\\boldsymbol{A}\\) 가 어떤 행렬인지 결정하게 하기는 힘들며, 때때로 바람직 하지 않은 오류를 낼 수 있다. Julia 에서는 다중 디스패치를 이용할 수 있으므로 행렬 \\(\\boldsymbol{A}\\) 를 각각의 형태에 맞는 타입으로(대각행렬이라든가, 상삼각행렬이라든가) 정해 줄 수 있다면 이에 맞춰서 선형 시스템을 푸는 함수를 공통적으로 정의 할 수 있다. 즉 solve_linearsystem_diagonal, solve_linearsystem_uppertriangula 등을 따로 정의 할 필요 없이 solve_linearsystem(A::Diatonal), solve_linearsystem(A::UpperTriangula) 와 같이 할 수 있다는 뜻이다.\nLinearAlgebra.jl 에 정의된 특수한 타입으로서의 행렬의 목록은 아래와 같다.\n\n\n\n\n\n\n경고\n\n\n\n아래의 목록에 정의된 행렬의 타입들 가운데 상당수는 성긴행렬이다. 굳이 밀집행렬로 바꾸고 싶다면 Matrix(A) 를 사용한다.\n\n\n\n\n\n\n\n\n\n\n\n타입\n명칭\n설명\n\n\n\n\nUniformScaling\nUniform scaling operator\nc\\(\\boldsymbol{I}\\)\n\n\nDiagonal\n대각행렬 (Diagonal matrix)\n\n\n\nBidiagonal\n상/하 쌍대각 행렬 (Upper/lower bidiagonal matrix)\n\n\n\nTridiagonal\n삼중 대각 행렬 (Tridiagonal matrix)\n\n\n\nSymTridiagonal\n대칭 삼중 대각 행렬 (Symmetric tridiagonal matrix)\n\n\n\nUpperTriangular\n상삼각행렬 (Upper triangular matrix)\n\\(i&gt;j \\implies A_{ij}=0\\)\n\n\nUnitUpperTriangular\n단위 상삼각행렬 (Upper triangular matrix with unit diagonal)\n상삼각행렬이며 대각성분이 \\(1\\)\n\n\nLowerTriangular\n하삼각행렬 (Lower triangular matrix)\n\\(i&lt;j \\implies A_{ij}=0\\)\n\n\nUnitLowerTriangular\n단위 하삼각행렬 (Lower triangular matrix with unit diagonal)\n하삼각행렬이며 대각성분이 \\(1\\)\n\n\nUpperHessenberg\n상 헤센베르크 행렬 (Upper Hessenberg matrix)\n\n\n\nSymmetric\n대칭 행렬 (Symmetric matrix)\n\\(\\boldsymbol{A} =\\boldsymbol{A}^T\\)\n\n\nHermitian\n에르미트 행렬 (Hermitian matrix)\n\\(\\boldsymbol{A} =\\boldsymbol{A}^\\ast\\)\n\n\n\n\n\nUniformScaling\nUniformScaling 은 단위행렬에 상수를 곱한것을 말한다. UniformScaling(2.0) 은 (2.0 이 Float64 타입의 부동소수이므로) Float64 타입의 성분을 갖는 단위행렬이다. 다만 아직까지는 차원이 정해지지 않으며 다른 행렬과 연산될 때 적절한 차원을 갖게 된다. 단위행렬을 나타내는 I 를 대신 사용 할 수 있으며, UniformScaling(2.0)==2.0I 이다.\nIn [1]: using LinearAlgebra, SparseArrays\n\nIn [2]: 2.0I + 3\nOut[2]: 5.0\n\nIn [3]: 2.0I + [0  1; 2 3]\nOut[3]: 2×2 Matrix{Float64}:\n 2.0  1.0\n 2.0  5.0\n\n\n\nDiagonal\n대각행렬을 나타내는 타입이다. \\(n\\) 차원 벡터를 입력하면 차례로 대각성분이 되는 대각행렬을 만든다.\nIn [4]: Diagonal([1, 10, 100])\nOut[4]: 3×3 Diagonal{Int64, Vector{Int64}}:\n 1   ⋅    ⋅\n ⋅  10    ⋅\n ⋅   ⋅  100\nDiagonal 타입의 행렬에 UniformScaling 을 더하면, 아마 여러분이 예상한 결과가 나올 것이다.\nIn [5]: Diagonal([1, 10, 100]) + 3.0I\nOut[5]: 3×3 Diagonal{Float64, Vector{Float64}}:\n 4.0    ⋅      ⋅ \n  ⋅   13.0     ⋅ \n  ⋅     ⋅   103.0\n\n\n\nBidiagonal, Tridiagonal, SymTridiagonal\n\\(m\\times n\\) 행렬 \\(A_{ij}\\) 에서 \\(A_{ii},\\, i=1,\\ldots,\\, \\min \\{m,\\,n\\}\\) 을 대각(diagonal) 성분이라 한다. 대각 성분의 바로 오른쪽 성분, 즉 \\(A_{i,\\, i+1}\\) 을 상대각 (superdialgonal) 성분이라 하며, 왼쪽 성분, 즉 \\(A_{i+1,\\,i}\\) 을 하대각(subdiagonal) 성분이라 한다.(적절한 번역어를 못찾아서 임의로 붙인 이름이다.)\n대각행렬과 대각성분 근처의 일부만을 제외한 모든 성분이 \\(0\\) 인 행렬을 띠행렬 (Band matrix)이라 한다. 대각성분과 상대각 성분/하대각 성성분 가운데 하나를 제외한 모든 성분이 \\(0\\) 인 행렬을 각각 상쌍대각 행렬/하쌍대각 행렬이라 한다. 아래의 보기에서 \\(\\boldsymbol{B}_U\\) 는 상쌍대각행렬, \\(\\boldsymbol{B}_L\\) 은 하쌍대각행렬이다.\n\\[\n\\boldsymbol{B}_U = \\begin{bmatrix} 4 & 1 & 0 &0  \\\\ 0 & 3 & 1 & 0 \\\\ 0 & 0 & 2 &  2 \\\\ 0 & 0 & 0 & 5 \\end{bmatrix} ,\\qquad \\boldsymbol{B}_L = \\begin{bmatrix} 4 & 0 & 0 &0  \\\\ 1 & 3 & 0 & 0 \\\\ 0 & 1 & 2 &  0 \\\\ 0 & 0 & 2 & 5 \\end{bmatrix}\n\\]\n쌍대각 행렬은 Bidiagonal 객체로 표현되며, 두가지 방법으로 구성 할 수 있다. 첫번째 방법은 생성자에(객체의 생성자이므로 객체와 같은 이름을 가진다.) 첫번째 인자로 대각성분을, 두번째 인자로 \\(0\\) 이 아닌 대각성분의 위/아래 성분을, 세번째 인자로 상쌍대각행렬이면 :U 를 하쌍대각행렬이면 :L 을 입력하는 방법이다.\nIn [6]: Bu = Bidiagonal([4, 3, 2, 5], [1, 1, 0], :U)\nOut[6]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 4  1  ⋅  ⋅\n ⋅  3  1  ⋅\n ⋅  ⋅  2  0\n ⋅  ⋅  ⋅  5\n\nIn [7]: Bl = Bidiagonal([4, 3, 2, 5], [1, 1, 2], :L)\nOut[7]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 4  ⋅  ⋅  ⋅\n 1  3  ⋅  ⋅\n ⋅  1  2  ⋅\n ⋅  ⋅  2  5\nBidiangoal 타입 행렬을 구성하는 두번째 방법은 이미 존재하는 행렬로부터 대각성분을 포함한 \\(0\\) 이 아닌 성분을 가져오는 방법이다. 다음을 보면 쉽게 이해 할 수 있을 것이다.\nIn [9]: A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]; Bidiagonal(A, :U)\nOut[9]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 1  1  ⋅  ⋅\n ⋅  2  2  ⋅\n ⋅  ⋅  3  3\n ⋅  ⋅  ⋅  4\n\nIn [10]: Bidiagonal(A, :L)\nOut[10]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅  ⋅\n 2  2  ⋅  ⋅\n ⋅  3  3  ⋅\n ⋅  ⋅  4  4\n\n대각성분, 상대각성분, 하대각성분을 제외한 성분이 모두 \\(0\\) 인 성분을 삼중대각행렬 (Tridiagonal matrix) 라 하며 LinearAlgebra.jl 에서는 Tridiagonal 타입으로 정의된다. 아래의 행렬 \\(\\boldsymbol{C}\\) 는 삼중 대각행렬이다.\n\\[\n\\boldsymbol{C} = \\begin{bmatrix} 4 & 1 & 0 & 0 & 0 \\\\ 2 & 3 & 1 & 0 & 0 \\\\ 0 & 3 &1& 2 &  0 \\\\ 0 & 0 & 2& 5 & 1 \\\\ 0 & 0 & 0 &3 & 6 \\end{bmatrix}\n\\]\n삼중대각행렬을 구성하는 방법은 쌍대각행렬을 구성하는 방법과 비슷하게 두가지 방법이다. 하나는 대각행렬 아래 성분들을 나타내는 벡터, 대각성분벡터, 대각성분 위의 성분들을 나타내는 벡터를 차례로 입력하는 것이다.\n위의 행렬 \\(\\boldsymbol{C}\\) 를 구성한다면\nIn [11]: C = Tridiagonal([2, 3, 2, 3], [4, 3, 1, 5, 6], [1, 1, 2, 1])\nOut[11]: 5×5 Tridiagonal{Int64, Vector{Int64}}:\n 4  1  ⋅  ⋅  ⋅\n 2  3  1  ⋅  ⋅\n ⋅  3  1  2  ⋅\n ⋅  ⋅  2  5  1\n ⋅  ⋅  ⋅  3  6\n와 같이 할 수 있다.\n다른 방법은 이미 존재하는 행렬로부터 구성하는 것이다.\nIn [13]: D = [1 2 3 4 5]' *ones(Int64, 5)'\nOut[13]: 5×5 Matrix{Int64}:\n 1  1  1  1  1\n 2  2  2  2  2\n 3  3  3  3  3\n 4  4  4  4  4\n 5  5  5  5  5\n\nIn [13]: Tridiagonal(D)\nOut[13]: 5×5 Tridiagonal{Int64, Vector{Int64}}:\n 1  1  ⋅  ⋅  ⋅\n 2  2  2  ⋅  ⋅\n ⋅  3  3  3  ⋅\n ⋅  ⋅  4  4  4\n ⋅  ⋅  ⋅  5  5\nSymTridiagonal 은 대칭인 삼중대각행렬을 나타내는 타입이다. 대칭행렬이므로 대각행렬의 위 띠와 아래띠가 같다. 이것은 어떻게 구성할까? 여러분이 짐작할 수 있듯이 대각성분과, 띠 성분을 벡터로 입력하면 된다.\nIn [14]: SymTridiagonal([1,2, 3, 4, 5], [-1, -2, -3, -4])\nOut[14]: 5×5 SymTridiagonal{Int64, Vector{Int64}}:\n  1  -1   ⋅   ⋅   ⋅\n -1   2  -2   ⋅   ⋅\n  ⋅  -2   3  -3   ⋅\n  ⋅   ⋅  -3   4  -4\n  ⋅   ⋅   ⋅  -4   5\n\n\n\nUpperTriangular, LowerTriangular\n상삼각행렬과 하삼각행렬을 다루기 위한 타입은 각각 UpperTriangular, LowerTriangular 이다. 거기에 대각성분이 \\(1\\) 인 행렬로 특별히 UnitUpperTriangular, UnitLowerTriangular 타입이 준비되어 있다. 이미 존재하는 행렬로부터 필요한 만큼의 행렬 원소를 취하여 행렬을 구성 할 수 있다.\nIn [15]: A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\nOut[15]: 3×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\nIn [16]: UpperTriangular(A)\nOut[16]: 3×3 UpperTriangular{Float64, Matrix{Float64}}:\n 1.0  2.0  3.0\n  ⋅   5.0  6.0\n  ⋅    ⋅   9.0\n\nIn [17]: LowerTriangular(A)\nOut[17]: 3×3 LowerTriangular{Float64, Matrix{Float64}}:\n 1.0   ⋅    ⋅ \n 4.0  5.0   ⋅ \n 7.0  8.0  9.0\n\nIn [18]: UnitUpperTriangular(A)\nOut[18]: 3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  2.0  3.0\n  ⋅   1.0  6.0\n  ⋅    ⋅   1.0\n\nIn [19]: UnitLowerTriangular(A)\nOut[19]: 3×3 UnitLowerTriangular{Float64, Matrix{Float64}}:\n 1.0   ⋅    ⋅ \n 4.0  1.0   ⋅ \n 7.0  8.0  1.0\n\n\n\n헤센베르그 행렬\n헤센베르그 행렬은 상헤센베르그 행렬(Upper Hessenberg matrix) 과 하헤센베르그 행렬(Lower Hessenberg matrix) 로 이루어진다. 상헤센베르그 행렬(Upper Hessenberg matrix) 은 정사각행렬이며 행렬의 좌하단 모서리 부근이 모두 \\(0\\) 인 행렬이다. 하헤센베르그 행렬(Lower Hessenberg matrix) 는 정사각 행렬이며 행렬의 우하단 모서리 부근이 모두 \\(0\\) 인 행렬이다. 아래의 보기에서 \\(\\boldsymbol{H}_U\\) 는 상헤센베르그 행렬, \\(\\boldsymbol{H}_L\\) 은 하헤센베르그 행렬이다.\n\\[\n\\boldsymbol{H}_U = \\begin{bmatrix} 3 & 4 & 2 & 3\\\\ 1 & 4 & 2 & 3\\\\ 0 & 2 & 3 & 5 \\\\ 0 & 0 & 1 & 1\\\\\\end{bmatrix}\n,\\qquad \\boldsymbol{H}_L = \\begin{bmatrix} 1 & 2 & 0 & 0 \\\\ 7 & 2 & 3 & 0 \\\\ 3 & 4 & 3 & 7 \\\\ 5 & 3 & 1 &2 \\end{bmatrix}\n\\]\nJulia 에서는 상헤센베르그 행렬 가운데 첫번째 subdiagonal elements 아래의 성분을 0 으로 하는 행렬만 따로 UpperHessenberg 타입으로 정의한다. 임의의 정사각 행렬에 대해 UpperHessenberg 생성자를 취하면 다음과 같다.\nIn [20]: HH = [3  4  2  3; 1  4  2  3; 1  2  3  5 ; 1  2  1  1]\nOut[20]: 4×4 Matrix{Int64}:\n 3  4  2  3\n 1  4  2  3\n 1  2  3  5\n 1  2  1  1\n\nIn [21]: HU = UpperHessenberg(HH)\nOut[21]: 4×4 UpperHessenberg{Int64, Matrix{Int64}}:\n 3  4  2  3\n 1  4  2  3\n ⋅  2  3  5\n ⋅  ⋅  1  1\n\n\n\n대칭행렬과 에르미트 행렬\n어떤 행렬 \\(\\boldsymbol{A}\\) 의 행과 열을 바꾼 행렬을 그 행렬의 전치행렬 (transposed matrix) 라 하고 \\(\\boldsymbol{A}^T\\) 이라 한다. 즉 \\((\\boldsymbol{A}^T)_{ij} = (\\boldsymbol{A})_{ji}\\) 이다. 행렬 \\(\\boldsymbol{A}\\) 행과 열을 바꾸고 켤레복소수를 취한것을 켤레전치 행렬(conjugate transpose matrix) 혹은 에르미트 전치 행렬(Hermite transpose matrix)라 하고 \\(\\boldsymbol{A}^\\ast\\) 나 \\(\\boldsymbol{A}^\\dagger\\) 라 쓴다. 전자는 수학에서, 후자는 물리학에서 주로 쓰는 표현이다. \\(\\boldsymbol{A}=\\boldsymbol{A}^T\\) 이면 대칭행렬 이라 한다. \\(\\boldsymbol{A}=\\boldsymbol{A}^\\ast\\) 이면 에르미트 행렬(Hermitian matrix), 혹은 자기수반 행렬(Self-adjoint matrix) 라 한다. 예를 들어 \\(\\boldsymbol{A} =\\begin{bmatrix} 2+3i & i \\\\ 2i & 3\\end{bmatrix}\\) 에 대해,\n\\[\n\\boldsymbol{A}^T =\\begin{bmatrix} 2+3i & 2i \\\\ i & 3\\end{bmatrix},\\qquad \\boldsymbol{A}^\\ast = \\begin{bmatrix} 2-3i & -i \\\\ -2i & 3\\end{bmatrix}\n\\]\n이다. 행렬 \\(\\boldsymbol{A}\\) 가 실수 성분만을 가진다면 \\(\\boldsymbol{A}^T = \\boldsymbol{A}^\\ast\\) 이다.\n대칭행렬에 대한 타입은 Symmetric 이다. 이미 존재 하는 행렬에서 하삼각부분이나 상삼각부분을 취하여 대칭행렬로 만든다.\nIn [22]: A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]\nOut[22]: 5×5 Matrix{Int64}:\n 1  0  2  0  3\n 0  4  0  5  0\n 6  0  7  0  8\n 0  9  0  1  0\n 2  0  3  0  4\n\nIn [23]: Supper = Symmetric(A, :U)\nOut[23]: 5×5 Symmetric{Int64, Matrix{Int64}}:\n 1  0  2  0  3\n 0  4  0  5  0\n 2  0  7  0  8\n 0  5  0  1  0\n 3  0  8  0  4\n\nIn [24]: Slower = Symmetric(A, :L)\nOut[24]: 5×5 Symmetric{Int64, Matrix{Int64}}:\n 1  0  6  0  2\n 0  4  0  9  0\n 6  0  7  0  3\n 0  9  0  1  0\n 2  0  3  0  4\n행렬 A 의 하삼각 부분을 취하여 대칭행렬로 만들 때는 Symmetric(A, :U) 라 하고, 하삼각 부분을 취하여 대칭행렬로 만들 때는 Symmetric(A, :L) 라 한다. 이 때 :U 나 :L 을 입력하지 않으면 :U 를 기본값으로 하여 대칭행렬을 만든다.\n에르미트 행렬에 대한 타입은 Hermite 이며 마찬가지로 Hermite(A, :U) 나 Hermite(A, :L) 로 에르미트행렬을 만든다. 역시 기본값은 :U 이다.\nIn [25]: A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];\n\nIn [26]: Hupper = Hermitian(A)\nOut[26]: 5×5 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  0+0im  2+2im  0+0im  3-3im\n 0+0im  4+0im  0+0im  5+0im  0+0im\n 2-2im  0+0im  7+0im  0+0im  8+8im\n 0+0im  5+0im  0+0im  1+0im  0+0im\n 3+3im  0+0im  8-8im  0+0im  4+0im\n\nIn [27]: Hlower = Hermitian(A, :L)\nOut[27]: 5×5 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  0+0im  6+6im  0+0im  2-2im\n 0+0im  4+0im  0+0im  9+0im  0+0im\n 6-6im  0+0im  7+0im  0+0im  3+3im\n 0+0im  9+0im  0+0im  1+0im  0+0im\n 2+2im  0+0im  3-3im  0+0im  4+0im"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_matrix_algebra.html#linearalgebra.jl-의-기본-연산자와-함수",
    "href": "src/numerical_analysis_using_julia/03_matrix_algebra.html#linearalgebra.jl-의-기본-연산자와-함수",
    "title": "Julia 에서의 행렬 계산",
    "section": "3 LinearAlgebra.jl 의 기본 연산자와 함수",
    "text": "3 LinearAlgebra.jl 의 기본 연산자와 함수\n우리는 앞서 가우스 소거법과 LU 분해 그리고 그람-그람 슈미트 과정을 통한 QR 분해를 구현하였다. 그러나 앞으로는 이것을 버리고 Julia 에서 제공하는 LinearAlgebra 모듈을 사용하도록 하자. Julia 의 LinearAlgebra 모듈은 선형대수학에서 사용하는 많은 기능을 포함하고 있다. 여기서는 중요한 것만 설명할 것이며 자세한 것은 LinearAlgbra.jl 공식 문서 를 참고하자. LinearAlgebra 를 우리가 지금껏 작성한 함수와 그 속도를 비교해보면 LinearAlgebra 쪽이 훨씬 빠르다. 그리고 LinearAlgebra module 은 많은 프로그래밍 언어에서 사용중이며, 수십년의 역사를 가진 BLAS(Basic Linear Algebra Subprograms) 과 LAPACK(Linear Algebra PACKage) 에 기반하여 만들어졌으므로 믿을만 하다. 많은 함수는 희소행렬과 밀집행렬에 대해 공통적으로 사용 할 수 있다.(다중 디스패치!!!)\n\n\n기본 연산자와 함수\nLininearAlgebra.jl 은 행렬 A(\\(\\boldsymbol{A}\\)), B(\\(\\boldsymbol{B}\\)) 와 벡터 u(\\(\\boldsymbol{u}\\)), v(\\(\\boldsymbol{v}\\)), 스칼라 a(\\(a\\)), b(\\(b\\)) 에 대해 다음과 같은 함수를 지원한다. (LinearAlgebra.jl 이 지원하는 함수중 일부이다.)\n\n연산자\n\n\n\n\n\n\n\n연산자\n설명\n\n\n\n\n+, -, *\n수학적으로 정의된 스칼라, 벡터, 행렬 사이의 더하기, 빼기, 곱하기 연산\n\n\n\\\nA \\ B 일 경우 AX==B 를 만족하는 행렬 A 를 구한다. 구하는 방법은 A 가 어떤 행렬인지에 따라 달라진다.\n\n\n/\n행렬간의 연산일 경우 (B' / A') 를 구한다.\n\n\nu⋅v (\\cdot+[tab])\n\\(\\boldsymbol{u} \\cdot \\boldsymbol{v}\\)\n\n\n×(u, v) (\\times+[tab])\n\\(\\boldsymbol{u \\times v}\\)\n\n\n\n\n\n\n기본적인 함수\n\n\n\n함수\n설명\n비고\n\n\n\n\ntr(A)\n\\(\\text{tr}(\\boldsymbol{A})\\)\n\n\n\ndet(A)\n\\(\\det(\\boldsymbol{A})\\)\n\n\n\ninv(A)\n\\(\\boldsymbol{A}^{-1}\\)\nA 가 정사각행렬일 경우\n\n\ntranspose(A)\n\\(\\boldsymbol{A}^{T}\\)\nA 의 전치행렬\n\n\nA' or adjoint(A)\n\\(\\boldsymbol{A}^\\dagger\\)\nA 의 에르미트 전치행렬\n\n\ndiag(A)\n\\([A_{11},\\,A_{22},\\ldots]\\)\n대각성분\n\n\ndot(u, v)\nu⋅v 와 같다\n\n\n\ndot(u, A, v)\ndot(u, A*v) 와 같다\n\n\n\ncross(u, v)\n×(u, v) 와 같다\n벡터의 외적\n\n\nnorm(u, p) or norm(A, p)\n벡터의 \\(L_p\\)-노름\n노름과 조건수 참고\n\n\nopnorm(A, p::Real=2)\n행렬의 \\(L_p\\)-노름\n노름과 조건수 참고\n\n\nnormalize(a, p::Real=2)\n벡터, 행렬의 정규화\nnorm(a, p)==1 되도록 normalize 한다.\n\n\nexp(A)\nexponential of \\(\\boldsymbol{A}\\)\n\\(\\displaystyle \\sum_{k=1}^\\infty \\dfrac{\\boldsymbol{A}^k}{k!}\\)"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_matrix_algebra.html#선형-시스템",
    "href": "src/numerical_analysis_using_julia/03_matrix_algebra.html#선형-시스템",
    "title": "Julia 에서의 행렬 계산",
    "section": "4 선형 시스템",
    "text": "4 선형 시스템\n우리는 앞서 LU 분해를 통해 선형 시스템을 푸는 코드를 작성하였다. 이제는 LinearAlgebra.jl 이 제공하는 \\ 연산자를 이용하면 쉽게 풀 수 있다. 일반적인 정사각 행렬에 대해서는 성긴 행렬이든 밀집 행렬이든 LU 분해를 통해 선형 시스템을 쉽게 풀 수 도록 해 준다. 예를 들어,\nIn [1]: using LinearAlgebra\n\nIn [2]: A=[4 2 3;3 1 2;3 3 4];b=[2; 1 ;-1]\nOut[2]: 3-element Vector{Int64}:\n  2\n  1\n -1\n\nIn [3]: A\\b\nOut[3]: 3-element Vector{Float64}:\n  2.0\n  3.0000000000000013\n -4.000000000000001\n와 같이 풀 수 있다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04I_interpolation_struct.html",
    "href": "src/numerical_analysis_using_julia/04I_interpolation_struct.html",
    "title": "보간법의 구현",
    "section": "",
    "text": "보간법의 구현\n우리는 앞의 다항식의 구현에서 복합타입을 함수처럼 사용하였다. 보간법의 경우 원래의 데이터와 보간 방식을 입력하면 어떠한 값에 대해서도 보간된 값을 계산 할 수 있다. 우리는 이것을 역시 복합 타입으로 구현하고자 한다.\n복합 타입의 정의는 다음과 같다.\nmutable struct Interpolator1D{T}\n    xp :: Vector{T}\n    yp :: Vector{T}\n    kind :: Symbol\n    bc :: Union{Vector{T}, Nothing}\n    coeffs ::Union{Vector{T}, Nothing}\n\n    function Interpolator1D(\n        xp::AbstractVector{T}, \n        yp::Vector{S}, \n        kind::Symbol, \n        bc::Union{Nothing, Vector}=nothing, \n        ) where {T &lt;: Real, S&lt;: Real}\n        @assert kind ∈ (:nearest, :linear, :cubic, :cubic_spline_naturalbc, :cubic_spline_clampedbc)\n        @assert length(xp) == length(yp)\n        \n        N = promote_type(T, S)\n        xp = convert.(N, xp)\n        yp = convert.(N, yp)\n\n        if kind ∈ (:cubic_spline_naturalbc, :cubic_spline_clampedbc)\n            coeffs = get_cubic_spline_coefficients(xp, yp, kind, bc)\n        else \n            bc = nothing\n            coeffs = nothing\n        end\n        new{N}(Vector(xp), Vector(yp), kind, bc, coeffs)\n    end\nend\nInterpolator1D 자료형의 xp 와 yp 는 보간법에 사용될 원래의 데이터이며, kind 는 보간 방법으로 :nearest(최근접 보간법), :linear (선형 보간법), :cubic (삼차함수 보간법), :cubic_spline_naturalbc (cubic spline with natural boundary condition), :cubic_spline_clampedbc (cubic spline with clamped boundary condition) 을 의미한다. bc 는 경계조건을 의미하며, cubic spline 방법이 아닐 경우 필요가 없으므로, 벡터 혹은 nothing 의 Union 이다.\nCubinc Spline 보간법의 경우 경계조건을 계산하는 함수 get_cubic_spline_coefficients 를 다음과 같이 구현하였다.\n\nfunction get_cubic_spline_coefficients(xp, yp, bc_kind = :cubic_spline_naturalbc, bc=nothing)\n    @assert length(xp) == length(yp)\n    @assert bc_kind ∈ (:cubic_spline_clampedbc, :cubic_spline_naturalbc)\n    @assert (bc === nothing) || (length(bc) == 2)\n    T = eltype(xp)\n    N = length(xp)\n    M = spzeros(T, (4*N-4, 4*N-4))\n    Y = zeros(T, (4*N-4, 1))\n    for i in 1:N-2 \n        M[4*(i-1)+1, (4*(i-1)+1):4*i] = [one(T) xp[i] (xp[i])^2 (xp[i])^3]\n        M[4*(i-1)+2, 4*(i-1)+1:4*i] = [one(T) xp[i+1] (xp[i+1])^2 (xp[i+1])^3]\n        M[4*(i-1)+3, 4*(i-1)+2:4*(i+1)] = [1 2*xp[i+1] 3*(xp[i+1])^2 0 -1 -2*xp[i+1] -3*(xp[i+1])^2]\n        M[4*(i-1)+4, 4*(i-1)+3:4*(i+1)] = [2 6*(xp[i+1]) 0 0 -2 -6*(xp[i+1])]\n        \n        Y[4*(i-1)+1] = yp[i]\n        Y[4*(i-1)+2] = yp[i+1]\n        \n        if i == N-2\n            println(4*N-4, \", \", 4*(i-1)+4)\n        end\n    end\n    \n    M[end-3, end-3:end] = [one(T) xp[end-1] (xp[end-1])^2 (xp[end-1])^3] \n    M[end-2, end-3:end] = [one(T) xp[end] (xp[end])^2 (xp[end])^3] \n    \n    if bc_kind == :cubic_spline_naturalbc\n        \n        M[end-1, 3:4] = [2 6*xp[1]]\n        M[end, end-1:end] = [2 6*xp[end]]\n        Y[end-3] = yp[end-1]\n        Y[end-2]=  yp[end]\n    else\n        M[end-3, end-3:end] = [one(T) xp[end-1] (xp[end-1])^2 (xp[end-1])^3] \n        M[end-2, end-3:end] = [one(T) xp[end] (xp[end])^2 (xp[end])^3] \n        M[end-1, 2:4] = [1 2*xp[1] 3(xp[1])^2]\n        M[end, end-2:end] = [1 2*xp[end] 3(xp[end])^2]\n        Y[end-3] = yp[end-1]\n        Y[end-2]=  yp[end]\n        Y[end-1] = bc[1]\n        Y[end] = bc[2]\n    end\n\n    return (M\\Y)[:,1]\n\nend"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_interpolation.html",
    "href": "src/numerical_analysis_using_julia/04_interpolation.html",
    "title": "다항식을 이용한 보간법",
    "section": "",
    "text": "이산적인 데이터 \\((x_1,\\,y_1),\\,(x_2,\\,y_2),\\ldots,\\, (x_N,\\, y_N)\\) 가 주어졌으며 \\(x_1&lt;x_2&lt;\\cdots &lt;x_N\\) 으로 정렬되어 있다고 하자. 이 때 주어진 데이터를 바탕으로 임의의 \\(x\\) 값을 추측할 경우, \\(x_1 \\le x \\le x_N\\) 의 \\(x\\) 값에 대해 추측하는 것을 보간법(interpolation) 이라 하고, \\(x&lt;x_1\\) 이거나 \\(x &gt;x_N\\) 일 경우 추축하는것을 외삽법(extrapolation) 이라 한다. 여기서는 보간법에 대해 다루기로 한다. 기본적으로 여기서 다루는 보간법은 데이터를 다항식으로 근사시키는데, 이 방법은 아래의 바이어스트라스 근사 정리(Weierstrass approximation theorem)로 정당화된다.\n\n정리 1 (바이어슈트라스 근사 정리) 함수 \\(f : X \\subset \\mathbb{R} \\to \\mathbb{R}\\) 가 \\([a,\\,b] \\subset I\\) 구간에서 연속일 때, 임의의 \\(\\varepsilon &gt; 0\\) 에 대해\n\\[\n|f(x)-P(x)|&lt;\\varepsilon,\\qquad \\forall x\\in [a,\\,b]\n\\]\n인 다항식 \\(P(x)\\) 가 항상 존재한다.\n\n이 정리에 대한 증명은 해석학(Analysis) 교과서(예를 들면, Terrence Tao의 해석학 교과서 2권) 를 참고하라."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_interpolation.html#바이어슈트라스-근사정리",
    "href": "src/numerical_analysis_using_julia/04_interpolation.html#바이어슈트라스-근사정리",
    "title": "다항식을 이용한 보간법",
    "section": "",
    "text": "이산적인 데이터 \\((x_1,\\,y_1),\\,(x_2,\\,y_2),\\ldots,\\, (x_N,\\, y_N)\\) 가 주어졌으며 \\(x_1&lt;x_2&lt;\\cdots &lt;x_N\\) 으로 정렬되어 있다고 하자. 이 때 주어진 데이터를 바탕으로 임의의 \\(x\\) 값을 추측할 경우, \\(x_1 \\le x \\le x_N\\) 의 \\(x\\) 값에 대해 추측하는 것을 보간법(interpolation) 이라 하고, \\(x&lt;x_1\\) 이거나 \\(x &gt;x_N\\) 일 경우 추축하는것을 외삽법(extrapolation) 이라 한다. 여기서는 보간법에 대해 다루기로 한다. 기본적으로 여기서 다루는 보간법은 데이터를 다항식으로 근사시키는데, 이 방법은 아래의 바이어스트라스 근사 정리(Weierstrass approximation theorem)로 정당화된다.\n\n정리 1 (바이어슈트라스 근사 정리) 함수 \\(f : X \\subset \\mathbb{R} \\to \\mathbb{R}\\) 가 \\([a,\\,b] \\subset I\\) 구간에서 연속일 때, 임의의 \\(\\varepsilon &gt; 0\\) 에 대해\n\\[\n|f(x)-P(x)|&lt;\\varepsilon,\\qquad \\forall x\\in [a,\\,b]\n\\]\n인 다항식 \\(P(x)\\) 가 항상 존재한다.\n\n이 정리에 대한 증명은 해석학(Analysis) 교과서(예를 들면, Terrence Tao의 해석학 교과서 2권) 를 참고하라."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_interpolation.html#sec-global_interpolation_using_polynomial",
    "href": "src/numerical_analysis_using_julia/04_interpolation.html#sec-global_interpolation_using_polynomial",
    "title": "다항식을 이용한 보간법",
    "section": "2 다항식을 이용한 전역적 보간법",
    "text": "2 다항식을 이용한 전역적 보간법\n전역적 보간법은 전체 데이터를 하나의 다항식으로 표현하는 방법이며, 후술할 국소적 보간법은 구하고자 하는 값 주위의 몇개의 데이터만을 이용하여 국소적으로 다항식으로 표현한다. 여기서는 \\(n+1\\) 개의 데이터 \\(\\{ (x_i,\\, y_i): i=1,\\ldots,\\,n\\}\\) 이 주어졌으며 \\(i\\ne j \\implies x_i \\ne x_j\\) 일 때, 즉 어떤 두 \\(x_i,\\,x_j\\) 도 같지 않을 경우에 대해, 이 점을 모두 지나는 \\(n-1\\) 차 다항식은 유일하게 정해진다는 사실을 이용하여 \\(n-1\\) 차 다항식을 구하는 방법을 설명한다. 이 다항식을 구하는 방법은 방데르몽드(Vandermond) 방법, 라그랑쥬(Lagrange) 방법, 뉴턴(Newton) 방법 등이 있다\n\n\n발데르몽드 방법\n다항식을 다음과 같이 놓는다. \\[\nV_{n} (x) = a_0 + a_1 x + \\cdots + a_{n-1}x^{n-1}\n\\]\n이 때 \\(V_{n} (x_i)= y_i\\) 이므로 아래와 같은 선형방정식 \\(\\boldsymbol{Va}=\\boldsymbol{y}\\) 을 통해 계수 \\(a_0,\\ldots,\\,a_{n-1}\\) 을 구할 수 있다.\n\\[\n\\underbrace{\\begin{bmatrix} 1 & x_1 & x_1^2 & \\cdots & x_1^{n-1} \\\\ 1 & x_2 & x_2^2 & \\cdots & x_2^{n-1} \\\\ \\vdots & & & & \\vdots \\\\ 1 & x_n & x_n^2 & \\cdots & x_n^{n-1}\\end{bmatrix}}_{{\\Large \\boldsymbol{V}}} \\underbrace{\\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{n-1}\\end{bmatrix}}_{{\\Large \\boldsymbol{a}}} = \\underbrace{ \\begin{bmatrix}y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n\\end{bmatrix}}_{{\\Large\\boldsymbol{y}}}\n\\tag{1}\\]\n\n\n연습문제 1 위의 \\(\\boldsymbol{V}\\) 와 같이 주어진 발데르몽드 행렬의 행렬식은 다음과 같음이 잘 알려져 있다.\n\\[\n\\det(\\boldsymbol{V}) = \\prod_{1\\le i&lt;j\\le n} (x_j-x_i)\n\\]\n즉 어떤 두 \\(x_i,\\,x_j\\) 같지 않으면 행렬식은 \\(0\\) 이 아니므로 가역행렬이다.\n\n\n데이터로 부터 행렬 \\(\\boldsymbol{V}\\) 와 벡터 \\(\\boldsymbol{y}\\) 를 구할 수 있으며, 어떤 두 \\(x_i,\\,x_j\\) 도 같지 않으므로 선형방정식의 풀이를 통해 다항식의 계수 벡터 \\(\\boldsymbol{a}\\) 를 구할 수 있다.\n\n\n코드\n발데르몽드 행렬을 생성하는 가장 직관적이고 이해하기 쉬은 코드는 다음과 같다. xp 가 배열 \\(x_1,\\ldots,\\,x_n\\) 에 대한 변수라고 하자.\nV = Array{Float64}(undef, length(xp), length(xp))\n\nfor (i, x) in enumerate(xp), j in eachindex(xp)\n    V[i, j] = x^(j-1)\nend\n그러나 가장 효율적인 코드, 특히 xp 의 크기가 클 때 효율적인 코드는 array comprehension 을 사용하는 것이다.\nV = [x^(j-1) for x in xp, j in 1:length(xp)]\n이렇게 생성된 V 와 데이터로 알고 있는 \\(y_1,\\ldots,\\, y_n\\) 에 대한 배열 yp 에 대해 다항식은\nSimplePolynomial(V\\yp)\n로 구할 수 있다. 이것은 simplepolynomials.jl 의 valdermond_polynomial 함수로 구현되었다.\nfunction valdermond_polynomial(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}\n    ) where {T1&lt;:Number, T2&lt;:Number}\n    \n    N = length(xp)\n    @assert length(xp) == length(yp)\n    V = [x^(j-1) for x in xp, j in 1:length(xp)]\n    return SimplePolynomial(V\\yp)\nend\n\n\n\n\n라그랑쥬 다항식을 이용한 보간법\n가장 직관적으로 이해하기 쉬운 라그랑쥬 방법을 알아보자. \\(n\\) 개의 데이터 \\(\\{(x_i,\\,y_i):i=1,\\ldots\\, n\\}\\) 에 대해 함수 \\(l_k(x)\\) 를 다음과 같이 정의하자.\n\\[\n\\begin{aligned}\nl_k (x) &:= \\prod_{i=1,\\, i \\ne k}^n \\dfrac{(x-x_i)}{(x_k-x_i)} \\\\\n&= \\dfrac{(x-x_1)\\cdots (x-x_{k-1})(x-x_{k+1})\\cdots (x-x_n)}{(x_k-x_1)\\cdots (x_k-x_{k-1})(x_k-x_{k+1})\\cdots (x_k-x_n)}.\n\\end{aligned}\n\\tag{2}\\]\n이 다항식은 다음을 만족한다.\n\\[\nl_k (x_j) = \\delta_{xj} = \\left\\{ \\begin{array}{ll} 1 \\qquad & j=k,\\\\ 0 \\qquad &\\text{otherwise} \\end{array}\\right.\n\\]\n다항식 \\(L_n(x)\\) 를 다음과 같이 정의하자.\n\\[\nL_{n}(x) := \\sum_{k=1}^n y_k \\, l_k(x)\n\\tag{3}\\]\n그렇다면 \\(i=1,\\ldots,\\,n\\) 에 대해 \\(L_{n}(x_i)=y_i\\) 인 것은 쉽게 알 수 있다. 즉 \\(L_{n} (x)\\) 는 주어진 점들을 모두 지나는 다항식이다. 이 다항식 \\(L_{n}(x)\\) 를 라그랑쥬 다항식이라고 한다.\n\n코드\n라그랑쥬 다항식은 다음과 같이 구현 할 수 있다.\nfunction lagrange_polynomial(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}) where {T1&lt;:Number, T2&lt;:Number}\n\n    N = length(xp)\n    @assert length(xp) == length(yp)\n    \n    r = SimplePolynomial([zero(T2), ])\n    for i in 1:N\n        coef = yp[i]\n        rt = one(T2)\n        for j in 1:N\n            if i ≠ j\n                @inbounds coef = coef/(xp[i]-xp[j])\n                @inbounds rt = rt*SimplePolynomial([-xp[j], 1.0])\n            end\n        end\n        r += rt*coef\n    end\n    return r\nend\n\n\n\n\n뉴턴 보간법\n뉴턴 보간법은 \\(n\\) 개의 데이터 \\(\\{ (x_i,\\, y_i): i=1,\\ldots,\\,n\\}\\) 를 지나는 \\(n-1\\) 차 다항식을 \\[\n\\begin{aligned}\nN_{n}(x) & = a_0 + a_1 (x-x_1)+ a_2 (x-x_1)(x-x_2)+ \\cdots \\\\\n& \\qquad + a_{n-1}(x-x_1)\\cdots (x-x_{n-1})\n\\end{aligned}\n\\tag{4}\\]\n으로 두고 그 계수 \\(a_0,\\,a_1,\\ldots,\\,a_{n-1}\\) 을 찾는다. 우선 \\(n_k(x)\\) 를 아래와 같이 정의하자. \\[\nn_k (x) := \\left\\{ \\begin{array}{ll} 1 & \\text{if }k=0 \\\\ \\displaystyle \\prod_{i=1}^k (x-x_i) &\\text{if }k\\ne 0\\end{array}\\right.\n\\tag{5}\\]\n이 \\(n_k(x)\\) 를 뉴턴 기저 다항식 이라 한다. 뉴턴 다항식 \\(N_n (x)\\) 는 다음과 같다.\n\\[\nN_{n}(x) = \\sum_{k=0}^{n-1} a_k n_k (x).\n\\]\n이 때 \\(N_n(x_1)=a_1= y_1\\) 이며, \\(k=1,\\ldots,\\, n-1\\) 에 대해\n\\[\na_k = \\dfrac{y_{k+1} - a_1 - a_2(x_{k+1}-x_1) - \\cdots - a_{k-1}(x_{k+1}-x_1)\\cdots (x_{k+1}-x_k)}{(x_{k+1}-x_1)\\cdots (x_{k+1}-x_k)}\n\\]\n임을 알 수 있다. 이것을 아래와 같은 선형방정식 \\(\\boldsymbol{Na}=\\boldsymbol{y}\\) 를 통해 표현 할 수 있다.\n\\[\n\\underbrace{\\begin{bmatrix} 1 & 0 & 0 & \\cdots & 0 \\\\ 1 & n_1(x_2) & 0 & \\cdots & 0 \\\\ 1 & n_1(x_3) & n_2(x_3) & \\cdots & 0 \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & n_{n-1}(x_n) & \\cdots & \\cdots & n_{n-1}(x_n)  \\end{bmatrix}}\n_{{\\Large \\boldsymbol{N}}}\n\\underbrace{\\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1}\\end{bmatrix}}_{{\\Large \\boldsymbol{a}}} =\n\\underbrace{\\begin{bmatrix} y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\y_n \\end{bmatrix}}_{{\\Large \\boldsymbol{y}}}.\n\\tag{6}\\]\n뉴턴 보간법을 행렬로 표현하는 \\(\\boldsymbol{N}\\) 은 하삼각행렬로 방데르몽드 방법이나, 라그랑쥬 방법에 의한 보간법보다 그 계수를 구하는 것이 빠르고 수치해석적으로 안정적이다.\n\n\n코드\nfunction newton_polynomial(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}) where {T1&lt;:Number, T2&lt;:Number}\n    n = length(xp)    \n    @assert n == length(yp)\n    T = promote_type(T1, T2)\n    N = LowerTriangular(ones(T, n, n))\n    for j in 2:n, i in j:n\n        @inbounds N[i, j] = N[i, j-1]*(xp[i] - xp[j-1]) \n    end\n    a = N\\yp\n    r = SimplePolynomial([a[1], ])\n    for i in 2:(n)\n        @inbounds r += a[i] * polynomial_from_roots(xp[1:i-1])\n    end\n    return r\n\nend\n\n\n\n세 방법의 비교\n주어진 점에 대해 보간하는 세가지 방법은 수학적으로 동등하지만 수치해석적으로는 뉴턴 방법을 권장하는데 그 이유는 다음과 같다.\n\n일반적으로 라그랑쥬 다항식보다 뉴턴 다항식을 빠르게 계산 할 수 있다.\n\\(n\\) 개의 데이터에 대해 다항식을 구한 후 데이터를 추가할 때 라그랑쥬 다항식은 모든 계수를 다시 계산해야 하지만 뉴턴 다항식은 위의 이미 알고 있는 계수와 점들을 를 이용하여 계산할 수 있다. 여기서는 새로운 점을 추가하는 것을 구현하지는 않았다.\n데이터가 어느 정도 많이 주어졌을 때 라그랑쥬 다항식보다 뉴턴 다항식이 수치해석적으로 안정하다.\n\n\n\n\n\n다항식을 이용한 보간법의 오차\n\n명제 1 \\(f\\in C^{n}[a,\\,b]\\) 이고 \\(\\{x_1,\\ldots,\\,x_n\\}\\subset [a,\\,b]\\) 이며 \\(i\\ne j \\implies x_i \\ne x_j\\) 라고 하자. \\(P_{n-1}(x)\\) 가 \\(P_{n-1}(x_i) = f(x_i)\\) (\\(i=1,\\ldots,\\,n\\)) 인 \\(n-1\\) 차 다항식이라면\n\\[\nf(x) - P_{n-1}(x) = \\dfrac{f^{(n)}(\\xi)}{n!} \\prod_{j=1}^n (x-x_j)\n\\]\n를 만족하는 \\(\\xi \\in [a,\\,b]\\) 가 존재한다.\n\n\n(증명). \\(F(t)\\) 를 다음과 같이 정의하자.\n\\[\nF(t) = f(t) - P_{n-1} (t) - (f(x)-P_{n-1} (x)) \\prod_{i=1}^n \\dfrac{(t-x_i)}{(x-x_i)} \\tag{1}\n\\]\n이 때 \\(t=x_k,\\, k=1,\\ldots,\\, n\\) 에 대해 \\(F(x_k)=0\\) 이다. 또한\n\\[\nF(x) = f(x)-P_{n-1}(x) - (f(x)-P_{n-1}(x)) = 0\n\\]\n이므로 \\(x,\\,x_1,\\ldots,\\,x_n\\) 의 \\(n+1\\) 개의 점에서 \\(F(t)=0\\) 이 된다. 일반화된 롤의 정리 를 이용하면 \\(n\\) 개의 점에서 \\(F'(t)=0\\) 이며, 이것을 반복하면 \\(F^{(n)}(\\xi)=0\\) 을 만족하는 \\(\\xi\\in [a,\\,b]\\) 가 존재한다. 그런데 \\(P_{n-1}(x)\\) 는 \\(n-1\\) 차 다항식이므로 \\(P_{n-1}^{(n)} (x)=0\\) 이며 (\\(1\\)) 의 \\(\\displaystyle \\prod_{i=1}^n \\dfrac{(t-x_i)}{(x-x_i)}\\) 에 대한 \\(n\\) 차 미분은\n\\[\n\\dfrac{d^n}{dt^n} \\left(\\prod_{i=1}^n \\dfrac{(t-x_i)}{(x-x_i)}\\right) = \\dfrac{n!}{\\prod_{i=1}^n (x-x_i)}\n\\]\n이므로,\n\\[\nF^{(n)}(\\xi) = f^{(n)}(\\xi) - (f(x)-P_{n-1} (x))\\dfrac{n!}{\\prod_{i=1}^n (x-x_i)} = 0\n\\]\n이다. 즉\n\\[\nf(x) = P_{n-1}(x) + \\dfrac{f^{(n)}(\\xi)}{n!}\\prod_{i=1}^n (x-x_i)\n\\]\n를 만족하는 \\(\\xi \\in [a,\\,b]\\) 가 존재한다. \\(\\square\\)\n\n\n\n\n전역적 보간법의 문제점\n데이터 갯수가 많을 경우 고차다항식으로 보간을 하게 되는데, 이 경우 다항식이 심하게 진동하는 경우가 있을 수 있다. 아래 그림의 데이터는 15개의 포인트로 가우스 분포 \\(e^{-(x-x_0)/2\\sigma^2}\\) 를 그린 것이며, 라그랑쥬나 뉴턴 방법을 통해 14차 다항식으로 보간한 결과를 같이 보여준다.\n\n\n\nOscilating behavior\n\n\n게다가 데이터 갯수가 상당히 많으면 수치적으로 불안정해 진다. 예를 들어, 25개의 데이터에 대한 가우스 분포를 다항식으로 보간하면 아래와 같이 더 이상 사용할 수 없는 결과가 발생한다.\n\n\n\nOscilating behavior2"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_interpolation.html#sec-Neville_method",
    "href": "src/numerical_analysis_using_julia/04_interpolation.html#sec-Neville_method",
    "title": "다항식을 이용한 보간법",
    "section": "3 네빌 방법 (Neville’s Method)",
    "text": "3 네빌 방법 (Neville’s Method)\n다항식을 이용한 전역적인 보간법에서의 세 방법이 \\(\\{(x_i,\\,y_i): i=1,\\ldots,\\,n\\}\\) 를 모두 지나는 \\(n-1\\) 차 다항식을 구하는 방법이라면 네빌 방법은 다항식을 직접 구한다기 보다는 다항식으로 보간했을 때의 값만을 구하는 방법이다.\n\\(n\\) 개의 데이터 \\(\\{(x_i,\\,y_i): i=1,\\ldots,\\,n\\}\\) 가 주어졌을 때 한 다항식 \\(P_{1,\\ldots,\\,n-1}(x)\\) 는 \\(i=1,\\ldots,\\,n-1\\) 에서 데이터와 일치하며, 다른 다항식 \\(P_{2,\\ldots,\\,n}\\) 은 \\(i=2,\\ldots,\\,n\\) 에서 데이터가 일치한다고 하자. 이 때\n\\[\nP_{1,\\ldots,\\,n}(x) = \\dfrac{(x-x_1)P_{2,\\ldots,n}(x) - (x-x_n)P_{1,\\ldots,\\,n-1}(x)}{x_n-x_1}\n\\]\n은 모든 \\(i=1,\\ldots,\\,n\\) 에 대해 \\(P_{1,\\ldots,\\,n}(x_i) = y_i\\) 이다.\n4 개의 점으로 이루어진 데이터를 다항식으로 보간한다고 생각하자. 각 \\(P_i(x)\\) 는 \\(y_i\\) 의 값을 갖는 상수함수로 놓는다. \\(P_1,\\,P_2,\\,P_3,\\,P_4\\) 를 이용하여 \\(P_{1,\\,2}\\), \\(P_{2,\\,3}\\), \\(P_{3,4}\\) 를 계산하며, 이를 이용하여 \\(P_{1,2,3}\\) 와 \\(P_{2,3,4}\\) 를 계산한다. 마지막으로 이를 이용하여 \\(P_{1,2,3,4}\\) 를 계산하면 종료된다.\n\n\n\n\n\n\n\n\n\n\n\n회차\n1\n2\n3\n4\n\n\n\n\n\\(x_1\\)\n\\(P_1 (x)\\)\n\n\n\n\n\n\n\n\\(P_{1, 2} (x)\\)\n\n\n\n\n\\(x_2\\)\n\\(P_2 (x)\\)\n\n\\(P_{1, 2, 3} (x)\\)\n\n\n\n\n\n\\(P_{2, 3} (x)\\)\n\n\\(P_{1, 2, 3, 4} (x)\\)\n\n\n\\(x_3\\)\n\\(P_3 (x)\\)\n\n\\(P_{2, 3, 4} (x)\\)\n\n\n\n\n\n\\(P_{3, 4} (x)\\)\n\n\n\n\n\\(x_4\\)\n\\(P_4 (x)\\)\n\n\n\n\n\n\n\n\n코드\n네빌 방법에 대한 코드는 아래와 같다. Julia 의 배열 comprehension 방법을 사용하였기 때문에 한번에 이해하기 어려울 수 있다는 것에 주의하라.\nfunction neville(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}, \n    x::Real) where {T1&lt;:Real, T2&lt;:Real}\n    @assert length(xp) == length(yp)\n    P = copy(yp)\n    for i in 1:(length(xp)-1)\n        P = [((x-xp[j+i])*P[j] - (x-xp[j])*P[j+1])/(xp[j]-xp[j+i]) for j in 1:(length(xp)-i)]\n    end\n    return P[1]\nend"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_interpolation.html#sec-local_interpolation_using_polynomial",
    "href": "src/numerical_analysis_using_julia/04_interpolation.html#sec-local_interpolation_using_polynomial",
    "title": "다항식을 이용한 보간법",
    "section": "4 다항식을 이용한 구간별 보간법",
    "text": "4 다항식을 이용한 구간별 보간법\n앞서의 전역적 보간법은 주어진 전체 데이터를 이용한 보간법인데 반해 지금 소개하는 보간법은 구하고자 하는 독립변수값 근처의 소수의 점만을 이용하여 다항식으로 보간한다. 따라서 전역적 보간법에서 보이는 진동이 없으며, 데이터가 많더라도 사용 할 수 있다.\n\n\n최근접 보간법 (Nearest Neighbor Interpolation)\n가장 간단한 보간법 은 최근접 보간법 (nearest neighbor interpolation) 으로 \\(x_1,\\ldots,\\,x_N\\) 가운데 \\(x\\) 값에 가장 가까운 값을 취하는 방법이다. 즉 \\(x_i\\le x&lt;x_{i+1}\\) 일 때 \\(x_i\\) 와 \\(x_{i+1}\\) 중 \\(x\\) 와의 거리가 더 가까운 값을 \\(f(x)\\) 로 선택하는 방법이다. 가장 단순하면서도 빠르지만 보간법의 결과로 나온 함수는 연속함수가 아니다.\n\n\n\n선형 보간법 (Linear Interpolation)\n\\(x_{i}\\le x &lt; x_{i+1}\\) 일 때 \\((x_i,\\,y_i)\\) 와 \\((x_{i+1},\\, y_{i+1})\\) 의 두 점을 지나는 직선 \\(l_i (x)\\) 는 다음과 같다.\n\\[\nl_i (x) = \\dfrac{y_{i+1}-y_i}{x_{+1}-x_i} (x-x_i) + y_i\n\\tag{7}\\]\n이 직선 \\(l_i(x)\\) 값으로 \\(f(x)\\) 값을 추산하는 것을 선형보간법이라 한다. 선형 보간법으로 구한 함수는 연속이지만 일반적으로 미분가능하지 않다.\n\n\n\n삼차함수 보간법 (Cubic interpolation)\n\\(x_{i}\\le x&lt; x_{i+1}\\) 일 때 \\((x_{i-1},\\, y_{i-1})\\), \\((x_i,\\,y_{i})\\), \\((x_{i+1},\\,y_{i+1})\\), \\((x_{i+2},\\, y_{i+2})\\) 를 이용하여 3차함수를 구하여 보간한다. 보간하는 함수는 앞서 언급한 발데르몽드, 라그랑쥬, 뉴턴 방식중에 사용할 수 있으며, 여기서는 뉴턴 다항식을 이용하여 보간하도록 한다. \\((x_{i-1},\\, y_{i-1})\\), \\((x_i,\\,y_{i})\\), \\((x_{i+1},\\,y_{i+1})\\), \\((x_{i+2},\\, y_{i+2})\\) 를 이용하여 구한 3차 다항식을 \\(N_i(x)\\) 라고 하면 \\(x_1\\le x&lt;x_2\\) 일 경우에는 \\(x_0\\) 가 없으므로 \\(N_1(x)\\) 를 이용하며, \\(x_{N-1}\\le x \\le x_{N}\\) 일 경우에는 \\(N_{N-2}\\) 를 이용하여 보간한다. 삼차함수 보간법을 사용하여 구한 함수는 연속이며 선형 보간법보다 나은 결과를 보여주지만 역시 미분 가능하지 않다.\n일단 위의 세가지를 julia 로 구현해 보자. \\(x_1,\\ldots,\\,x_n\\) 과 \\(y_1,\\ldots,\\,y_n\\) 이 각각 벡터 xp, yp 라고 하고 \\(x_1 &lt; x_2 &lt; \\cdots &lt; x_n\\) 임을 가정하자.\n\"\"\"\n    nearest neighbor interpolation\n\"\"\"\nfunction interp_nearest(\n    xp::AbstractVector{T}, \n    yp::Vector{S}, \n    x::AbstractVector{R}\n    ) where {T&lt;:Real, S&lt;:Real, R&lt;:Real}\n    \n    @assert length(xp) == length(yp)\n    N = length(xp)\n    result = zeros(x)\n    for (i, v) in enumerate(x)\n        if v&lt;xp[1] || v&gt;xp[end]\n            result[i] = zero(T)\n        else \n            ind = findfirst(xs-&gt;(xs&gt;=v), xp)-1\n            if ind == 0\n                result[i]=yp[1]\n            elseif v-xp[ind] &gt; xp[ind+1]-v\n                result[i] = yp[ind+1]\n            else \n                result[i] = yp[ind]\n            end\n        end\n    end\n    return result\nend\n\n\"\"\"\n    linear interpolation\n\"\"\"\nfunction interp_linear(xp::AbstractVector{T}, yp::Vector{S}, x::AbstractVector{R}) where {T&lt;:Real, S&lt;:Real, R&lt;:Real}\n    @assert length(xp) == length(yp)\n    N = length(xp)\n    result = zero(x)\n    for (i, v) in enumerate(x)\n        if v&lt;xp[1] || v&gt;xp[end]\n            result[i] = zero(T)\n        else \n            ind = findfirst(xs-&gt;(xs&gt;=v), xp)-1\n            if ind == 0\n                result[i] = yp[1]\n            else\n                result[i] = (yp[ind+1]-yp[ind])/(xp[ind+1]-xp[ind])*(v-xp[ind]) + yp[ind]\n            end\n        end\n    end\n    return result\nend\n\n\"\"\"\n    cubic interpolation\n\"\"\"\nfunction interp_cubic(xp::AbstractVector{T}, yp::Vector{S}, x::AbstractVector{R}) where {T&lt;:Real, S&lt;:Real, R&lt;:Real}\n    @assert length(xp) == length(yp)\n    N = length(xp)\n    result = zero(x)\n    for (i, v) in enumerate(x)\n        \n        if v&lt;xp[1] || v&gt;xp[end]\n            result[i] = zero(T)\n        else \n            ind = findfirst(xs-&gt;(xs&gt;=v), xp)-1\n            if ind ∈ (0, 1)\n                xs, ys = xp[1:4], yp[1:4]\n            elseif ind ∈ (N, N-1)\n                xs, ys = xp[end-3:end], yp[end-3:end]\n            else \n                xs, ys = xp[ind-1:ind+2], yp[ind-1:ind+2]\n            end\n            result[i] = newton_polynomial(xp, yp)(v)\n        end\n    end\n    return result\nend\n\n이것을 다음 코드로 확인해 보았다.\nusing Plots\nxp = 0.0:1.0:15.0 \nyp = cos.(xp) .* exp.(-xp/10.0)\nxt = collect(0.0:0.1:15.0) \nscatter(xp, yp, label = L\"\\cos \\theta\", dpi=300)\nplot!(xt, interp_nearest(xp, yp, xt), lw=2, lc=:red, label=L\"\\mathrm{Nearest}\")\nplot!(xt, interp_linear(xp, yp, xt), lw=2, lc=:blue, label=L\"\\mathrm{Linear}\")\nplot!(xt, interp_cubic(xp, yp, xt), lw=2, lc=:green, label=L\"\\mathrm{Cubic}\")\n\n\n\n\nInterpolation\n\n\n\n\n\nCubic Spline Interpolation\n위에서 설명한 세가지 보간법은 연속이 아니거나 미분 가능하지 않았다. Spline 보간법은 보간하고자 하는 구간 내에서 미분가능한 함수를 구해준다.\n\\(n\\) 개의 데이터 \\(\\{(x_i,\\,y_i): i=1,\\ldots,\\,n\\}\\) 에 대해 \\([x_i,\\,x_{i+1}]\\) 구간을 보간하는 다항식을 \\(s_i(x)\\) 라 하자. 이 때 각각의 \\(s_i(x)\\) 를 3차 다항식으로 하고\n\\[\n\\begin{aligned}\ns_i(x_{i}) & = y_{i}\\\\\ns_i(x_{i+1}) &= y_{i+1}\\\\\ns'_i(x_{i+1}) &= s'_{i+1}(x_{i+1}) \\\\\ns''_i(x_{i+1}) &= s''_{i+1}(x_{i+1})\n\\end{aligned}\n\\tag{8}\\] 을 만족하도록 보간하는 것을 cubic spline interpolation 이라 한다. \\([x_i,\\,x_{i+1}]\\) 구간에서의 삼차함수 \\(s_i(x)\\) 를 \\[\ns_{i}(x) = a_i + b_i x + c_ix^2 + d_i x^3\n\\]\n이라 하자. \\(s_i(x)\\) 에 대한 일차 도함수와 이차 도함수는\n\\[\n\\begin{aligned}\ns'_i (x) &= b_i + 2c_i x + 3d_i x^2,\\\\\ns''_{i}(x) &= 2c_i + 6d_ix\n\\end{aligned}\n\\]\n이므로, \\(a_{i-1},\\,b_{i-1},\\, c_{i-1},\\, d_{i-1}\\) 로부터\n\\[\n\\begin{array}{c}\na_i + b_i x_{i}+ c_i(x_{i})^2+ d_{i} (x_{i})^3 = y_{i} \\\\\na_i + b_i x_{i+1}+ c_i(x_{i+1})^2+ d_{i} (x_{i+1})^3 = y_{i+1} \\\\\nb_i + 2c_i (x_{i+1})+ 3d_i (x_{i+1})^2 =b_{i+1} + 2c_{i+1} (x_{i+1})+ 3d_{i+1} (x_{i+1})^2 \\\\\n2c_i + 6d_ix_{i+1} = 2c_{i+1}+ 6d_{i+1}x_{i+1}\n\\end{array}\n\\tag{9}\\]\n의 조건을 얻었으며, 이를 통해 \\(a_i,\\,b_i,\\,c_i,\\,d_i\\) 를 구할 수 있다. 위 식에서 아래의 두 식은 \\(i=1\\) 일 때 사용 할 수 없으므로 우리는 추가로 조건을 두어야 한다. 이 때 보통 아래와 같은 2가지의 경계조건 가운데 선택한다.\n\nFree or natural boundary: \\(s''_1 (x_1) = s''_{n-1} (x_n) = 0\\)\nClamped boundary: \\(s'_1(x_1) = f'(x_0),\\, s'_{n-1} (x_n) = f'(x_n)\\)\n\nClampled boundary 일 경우 \\(f'(x_0),\\, f'(x_n)\\) 값은 주어져야 한다.\n\n\\(n-1\\) 개의 구간에 대해 각각 4 개의 변수를 결정해야 하므로 미지수 행렬을 \\(4(n-1)\\times 1\\) 행렬 \\(\\boldsymbol{a}\\) 으로 두자. \\(j=1,\\ldots,\\,n-1\\) 에 대해\n\\[\na_{4j-3} = a_j, \\, a_{4j-2} = b_j, \\, a_{4j-1} = c_j,\\, a_{4j} = d_j\n\\]\n라고 하면 미지수 전체에 대한 행렬이다. 이제 주어진 데이터와 미지수와의 관계를 이용하여 선형방정식 \\(\\boldsymbol{Ma}=\\boldsymbol{b}\\) 를 만들자. 이 때 \\(\\boldsymbol{M}\\) 은 \\(4(n-1) \\times 4(n-1)\\) 행렬이다. \\(j=1,\\ldots,\\, n-1\\) 에 대해 \\(\\boldsymbol{M}\\) 의 \\(4(j-1)+1\\) 행부터 \\(4(j-1)+4\\) 행까지, \\(4(j-1)+1\\) 열부터 \\(4(j-1)+8\\) 열까지의 \\(4 \\times 8\\) 부분행렬을 \\(\\boldsymbol{M}_j\\) 라고 하자. 위의 조건 식 9 으로부터 \\(\\boldsymbol{M}_j\\) 가 포함하지 않는 성분은 모두 \\(0\\) 임을 알 수 있다. \\(i=1,\\ldots, n-2\\) 에 대해 \\(\\boldsymbol{M}_i\\) 는 다음과 같다. \\[\n\\boldsymbol{M}_j = \\begin{bmatrix}\n1 & x_i & (x_i)^2 & (x_i)^3 & 0 & 0 & 0 & 0\\\\\n1 & x_{i+1} & (x_{i+1})^2 & (x_{i+1})^3 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 2x_{i+1} & 3(x_{i+1})^2 & 0 & -1 & -2 x_{i+1} & -3(x_{i+1})^3\\\\\n0 & 0 & 2 & 6x_{i+1} & 0 & 0 & -2 & -6x_{i+1}\n\\end{bmatrix}\n\\]\n\\(x_{n+1}\\) 은 주어져 있지 않으므로 \\(\\boldsymbol{M}_{n-1}\\) 은 \\(2 \\times 8\\) 행렬이며 다음과 같다.\n\\[\\boldsymbol{M}_{n-1} = \\begin{bmatrix}\n1 & x_{n-1} & (x_{n-1})^2 & (x_{n-1})^3 & 0 & 0 & 0 & 0\\\\\n1 & x_{n} & (x_{n})^2 & (x_{n})^3 & 0 & 0 & 0 & 0\\\\\n\\end{bmatrix}\n\\]\n또한 역시 식 9 로 부터 \\(4(n-1)\\times 1\\) 행렬 \\(\\boldsymbol{y}\\) 는 \\(i=1,\\ldots,\\,n\\) 에 대해 다음과 같이 정할 수 있다.\n\\[\nb_{4j-3}= y_i, \\, b_{4j-2}= y_{i+1},\\, b_{4j-1} = 0,\\, b_{4j}= 0\n\\]\n이제 \\(\\boldsymbol{M}\\) 의 마지막 두 행을 경계조건에 따라 정해야 한다.\n\n\nFree boundary\n우선 첫번째 경계조건이 주어졌을 경우 \\[\n\\begin{aligned}\ns''_1 (x_1)=0 &\\implies 2c_1+ 6 d_1 (x_1)=0, \\\\\ns''_{n-1}(x_n) = 0 &\\implies 2c_{n-1} + 6d_{n-1}(x_n) = 0\n\\end{aligned}\n\\]\n를 얻는다. 이 조건으로부터,\n\\[\nM_{4n-5, 3}=2,\\, M_{4n-5, 4}= 6x_1,\\, M_{4n-4, 4n-5} = 2,\\, M_{4n-4, 4n-4} = 6x_n\n\\]\n을 얻는다.\n\n\n\nClamped boundary\n\\[\n\\begin{aligned}\ns'_1 (x_1)=f'(x_0) &\\implies b_1 + 2c_1(x_1)+ 3d_1 (x_1)^2=f'(x_0), \\\\\ns'_{n-1}(x_n) = f'(x_n) &\\implies b_{n-1}+ 2c_{n-1}(x_n) + 3d_{n-1}(x_n)^2 = f'(x_n)\n\\end{aligned}\n\\]\n를 얻는다. 이 조건으로부터,\n\\[\n\\begin{aligned}\nM_{4n-5, 2}=1,\\, M_{4n-5, 3}=2x_1,\\, M_{4n-5, 4} = 3(x_1)^2,\\, b_{4n-5}=f'(x_0), \\\\\nM_{4n-4, 4n-6}=1,\\, M_{4n-4, 4n-5}=2x_n,\\, M_{4n-4,4n-4}=3(x_n)^2,\\, b_{4n-4}=f'(x_n)\n\\end{aligned}\n\\]\n을 얻는다.\n\n이제 행렬 \\(\\boldsymbol{M}\\) 과 벡터 \\(\\boldsymbol{b}\\) 를 얻었으므로 \\(\\boldsymbol{Ma}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{a}\\) 를 구할 수 있다. \\(\\boldsymbol{a}\\) 는 이 보간법의 각 구간에서의 3차 다항식의 계수를 결정하기 때문에 우리는 보간법을 사용하여 정해진 구간 내의 모든 값을 계산 할 수 있다.\n여기에 사용된 모든 보간법은 interpolation.jl 에 Interpolation1D 객체로 구현되었다.\nusing Plots, LaTeXStrings, LinearAlgebra, Plots, SparseArrays, Printf\ninclude(\"../lib/interpolation.jl\")\n\nxp = 0.0:0.75:15.0 # change step to vector\nyp = cos.(3 .* xp) .* exp.(-xp/10.0)\nyp[8:9]=[-0.15 -0.3]# \nxt = 0.0:0.05:15.0 # change step to vector\n\ninterp1=Interpolator1D(xp, yp, :cubic)\ninterp2=Interpolator1D(xp, yp, :cubic_spline_naturalbc)\ninterp3=Interpolator1D(xp, yp, :cubic_spline_clampedbc, [0.0, 0.0])\n\nscatter(xp, yp, label = L\"\\mathrm{Data}\", dpi=300)\nplot!(xt, interp1.(xt), lw=2, lc=:green, label=L\"\\mathrm{Cubic}\")\nplot!(xt, interp2.(xt), lw=2, lc=:red, ls = :dash, label=L\"\\mathrm{Cubic\\;Spline\\;with\\;natural\\;BC}\")\nplot!(xt, interp3.(xt), lw=2, lc=:blue, ls = :dot, label=L\"\\mathrm{Cubic\\;Spline\\;with\\;clamped\\;BC}\")\n이 결과로 다음의 그래프를 얻었다.\n\n\n\nCubic Spline Interpolation"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html",
    "href": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html",
    "title": "일변수 함수의 미분과 적분",
    "section": "",
    "text": "이 장에서는 수치해석적으로 주어진 함수의 미분을 구하는 방법을 알아본다. 앞서 설명했듯이함수 \\(f: X\\subset \\mathbb{R} \\to \\mathbb {R}\\) 이 \\(x_0 \\in X\\) 에서 미분가능하다는 것은 다음의 극한이 존재한다는 것이다.\n\\[\nf'(x_0)=\\lim_{h\\to 0} \\dfrac{f(x_0+h)- f(x_0)}{h}\n\\]\n여기서 \\(h\\) 는 음수도, 양수도 가능하다. 그리고 우리가 앞서 배웠듯이 컴퓨터가 다룰수 있는 가장 \\(0\\) 에 가깝지만 가장 작은 수에는 한계가 있으므로 이러한 극한을 다룰수 없다. 따라서 수치해석적으로 미분을 계산할 때는 우리가 관심있는 영역 \\([a,\\,b]\\subset X\\) 를 분할하여 수열을 만들어 다룰 수 밖에 없다. 즉 우리는 \\(x_1=a&lt;x_2&lt;\\cdots &lt;x_n=b\\) 에 대해 \\(f(x_i) = y_i\\) 로 정하고 수열 \\((x_i)\\) 와 \\((y_i)\\) 를 이용하여 수치해석적으로 미분을 구한다. 이것은 미분가능한 함수가 주어졌을 때 뿐만 아니라 이산적인 값 \\(\\{(x_i,\\, y_i)\\}\\) 가 주어졌을 때도 동일하게 사용 할 수 있다. 우리는 \\([a,\\,b]\\) 를 일정한 간격으로 분할한, 즉 \\(x_{i+1}-x_i =h\\) 가 상수일 경우만 생각하기로 한다.\n\n\n\n수열 \\(y_1,\\,y_2,\\ldots\\) 에 대해 전방 차분 (forward difference) 는 \\(\\Delta_F y_i = y_{i+1}-y_i\\) 로 정의된다. 후방 차분 (backward difference) 는 \\(\\Delta_B y_i = y_{i}-y_{i-1}\\) 로 정의된다. 함수 \\(f(x)\\) 에 대해 어떤 특정한 간격 \\(h&gt;0\\) 가 주어졌을 때 전방 차분은 \\(\\Delta_F f(x) = f(x+h)-f(x)\\) 이며 후방차분은 \\(\\Delta_B f(x) = f(x)-f(x-h)\\) 이다. 앞서 말했듯이 수치해석에서는 \\(h\\to 0\\) 극한을 사용할 수 없으므로 차분을 이용하여 미분값을 계산한다.\n\n\n\n\n함수 \\(f\\) 가 \\(C^2\\) 함수일 때 \\(f\\) 에 대한 테일러 전개는 아래와 같다.\n\\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(\\xi_1)}{2} h^2,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(\\xi_2)}{2} h^2.\n\\end{aligned}\n\\tag{1}\\]\n\\(h&gt;0\\) 일 때 전방차분과 후방차분을 이용하여\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x)}{h} + O(h) = \\dfrac{\\Delta_F f(x)}{h} + O(h) \\\\\n&= \\dfrac{f(x)-f(x-h)}{h} + O(h) = \\dfrac{\\Delta_B f(x)}{h} + O(h)\n\\end{aligned}\n\\tag{2}\\]\n로 근사 할 수 있다.\n\n\n\n\n2차와 3차 테일러 다항식 까지 전개한다면 \\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(\\xi_1)}{6} h^3,  \\\\\n&= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_1)}{24}h^4,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(\\xi_2)}{6} h^3, \\\\\n&= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_2)}{24}h^4\n\\end{aligned}\n\\tag{3}\\]\n를 만족하는 \\(\\xi_1,\\,\\xi'_1\\in (x-h,\\, x),\\, \\xi_2,\\,\\xi'_2 \\in (x,\\,x+h)\\) 가 존재한다.\n이로부터\n\\[\n\\begin{aligned}\nf(x+h)-f(x-h) &= 2f'(x) h + \\dfrac{1}{6} \\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)h^3, \\\\\nf(x+h) -2 f(x) + f(x-h) &= f''(x) h^2 + \\dfrac{1}{24}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)h^4\n\\end{aligned}\n\\]\n이므로 우리는 이것을 이용하여 1차 뿐만 아니라 2차 도함수에 대한 근사값도 구할 수 있다. 여기서 \\(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1)\\) 를 보자. \\(\\xi_1\\in [x-h,\\,x],\\, \\xi_2 \\in [x,\\,x+h]\\) 인데, \\(f\\in C^3_{[x-h,x+h]}\\) 이면 따름정리 : 여러 점의 경우 에 의해 \\(f^{(3)}(\\xi) = \\frac{1}{2}\\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)\\) 를 만족하는 \\(\\xi\\in[x-h,\\,x+h]\\) 가 존재하며, 같은 이유로 \\(f\\in C^4_{[x-h,\\,x+h]}\\) 이면 \\(f^{(4)}(\\xi')=\\frac{1}{2}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)\\) 를 만족하는 \\(\\xi'\\in [x-h,\\,x+h]\\) 가 항상 존재한다. 따라서 다음과 같이 도함수와 2차도함수를 근사 할 수 있다.\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x-h)}{2h} - \\dfrac{f^{(3)}(\\xi)}{6}h^2 ,\\\\\nf''(x) &=  \\dfrac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\dfrac{f^{(4)}(\\xi')}{12}h^2\n\\end{aligned}\n\\tag{4}\\]\n이 때 수치해석적으로 계산한 미분의 오차는 \\(h^2\\) 에 비례한다. 따라서 \\(h\\) 을 작게 잡을 수록 오차가 작아지며 충분히 작을 때 전방차분이나 후방차분보다 오차가 작을 것을 기대 할 수 있다. 위의 식에 의해 구한 미분의 추정값을 중앙 차분 (central difference) 라고 한다. 아래 그림은 함수 \\(f\\) 에 대한 전방 차분, 후방 차분, 중앙 차분값을 그림으로 표현하였다. 실제 미분값은 중앙차분에 의한 값과 거의 같다.\n\n\n\nFinite difference\n\n\n양 끝점에서는 도함수를 구할 수 없는데 이때는 전방차분이나 후방차분과 비슷한 방법을 사용하여 구할 수 있다.\n\\[\n\\begin{aligned}\nf(x+2h) & = f(x) + f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 + \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4) \\\\\nf(x-2h) &= f(x) - f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 - \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4),\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\ny'_1 &= \\dfrac{-y_{3}+4y_{2}-3y_1}{2h} + O(h^2),\\\\\ny'_n &= \\dfrac{3y_{n}-4x_{n-1}+y_{n-2}}{2h} + O(h^2).\n\\end{aligned}\n\\tag{5}\\]\n\n\n\n\n\\(h\\) 값이 작을 수록 오차가 작아지지만 \\(h\\) 값이 어느 이하로 작아지면 에러가 발생한다. 아래는 쉬운 예를 보여준다. 우리는 \\(f(x)=e^x\\) 의 도함수는 자기 자신과 같으며, \\(f(0)=f'(0)=1\\) 임을 알고 있다. 앞의 전방, 후반 차분법과 보통의 차분법에 대해 \\(h\\) 값을 변화시키며 \\(f'(0)\\) 의 값을 계산하였다. \\(h\\) 값이 충분히 작지 않을 때는 오차가 발생하였으나 어느 정도 작아지면 그 값이 정확하고 안정적이다. 그러나 \\(h\\) 값이 \\(10^{-13}\\) 보다 작아지면 roundoff 에러가 발생하여 불안정해지는 것을 알 수 있다.\n\n\n\nRoundioff-Finite difference\n\n\n\n\n\n\n지금까지 1차와 2차 테일러 전개를 이용하여 미분계수를 \\(O(h)\\) 나 \\(O(h^2)\\) 의 오차로 구하는 방법을 소개하였다. 고차 테일러 전개를 이용하면 더 정확하게 미분값을 구할 수 있다. 4차 테일러 다항식과 나머지 값은 다음과 같다.\n\\[\n\\begin{aligned}\nf(x-2h) &= f(x) - f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 - \\dfrac{f^{(5)}(\\xi_1)}{120} (2h)^5\\,\\\\\nf(x-h) &= f(x) - f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 - \\dfrac{f^{(5)}(\\xi_2)}{120} (h)^5\\,\\\\\nf(x+h) &= f(x) + f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 + \\dfrac{f^{(5)}(\\xi_3)}{120} (h)^5\\,\\\\\nf(x+2h) &= f(x) + f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 + \\dfrac{f^{(5)}(\\xi_4)}{120} (2h)^5\\,\\\\\n\\end{aligned}\n\\tag{6}\\]\n이로부터,\n\\[\n\\begin{aligned}\nf(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h) &= 12 f'(x) h+ O (h^5) \\,,\\\\\n-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h) &= 12 f''(x) h^2 + O(h^5) .\n\\end{aligned}\n\\]\n임을 안다. 즉,\n\\[\n\\begin{aligned}\nf'(x) & = \\dfrac{f(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h)}{12h} + O(h^5)\\,,\\\\\nf''(x) &= \\dfrac{-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h)}{12h^2} + O(h^4)\n\\end{aligned}\n\\tag{7}\\]\n이다.\n다음 그림은 함수 \\(f(x) = x\\sin (x)\\) 에 대해 \\(h\\) 를 변화시켜 가면서로 잡고 위에서 설명한 두가지 방법을 이용하여 도함수를 구했을때의 그래프(“3 Points”, “5 Points”) 와 \\(f'(x) = \\sin (x) + x\\cos (x)\\) 의 그래프 (“Analytical”) 를 같이 그린 것이다. \\(h=1\\times 10^{-1}\\) 에서는 첫번째 수치미분보다 두번째 수치미분이 좀 더 실제 값에 가까우며 \\(1 \\times 10^{-2}\\) 부터 \\(1.0 \\times 10^{-14}\\) 까지는 두 방법 모두 상당히 정확한 값을 보여준다. 그러나 \\(h\\) 값이 \\(1.0\\times 10^{-15}\\) 보다 작아지면서부터는 뚜렷하게 오차를 보여준다. 이것은 수치 미분을 구할 때 분모를 \\(h\\) 로 나누게 되는데, 이 값이 작을수록 round-off 에러가 발생하기 때문이다. 따라서 적당한 \\(h\\) 값을 잡는 것이 중요하다.\n\n\n\n\nDerivative"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#일변수-함수의-미분",
    "href": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#일변수-함수의-미분",
    "title": "일변수 함수의 미분과 적분",
    "section": "",
    "text": "이 장에서는 수치해석적으로 주어진 함수의 미분을 구하는 방법을 알아본다. 앞서 설명했듯이함수 \\(f: X\\subset \\mathbb{R} \\to \\mathbb {R}\\) 이 \\(x_0 \\in X\\) 에서 미분가능하다는 것은 다음의 극한이 존재한다는 것이다.\n\\[\nf'(x_0)=\\lim_{h\\to 0} \\dfrac{f(x_0+h)- f(x_0)}{h}\n\\]\n여기서 \\(h\\) 는 음수도, 양수도 가능하다. 그리고 우리가 앞서 배웠듯이 컴퓨터가 다룰수 있는 가장 \\(0\\) 에 가깝지만 가장 작은 수에는 한계가 있으므로 이러한 극한을 다룰수 없다. 따라서 수치해석적으로 미분을 계산할 때는 우리가 관심있는 영역 \\([a,\\,b]\\subset X\\) 를 분할하여 수열을 만들어 다룰 수 밖에 없다. 즉 우리는 \\(x_1=a&lt;x_2&lt;\\cdots &lt;x_n=b\\) 에 대해 \\(f(x_i) = y_i\\) 로 정하고 수열 \\((x_i)\\) 와 \\((y_i)\\) 를 이용하여 수치해석적으로 미분을 구한다. 이것은 미분가능한 함수가 주어졌을 때 뿐만 아니라 이산적인 값 \\(\\{(x_i,\\, y_i)\\}\\) 가 주어졌을 때도 동일하게 사용 할 수 있다. 우리는 \\([a,\\,b]\\) 를 일정한 간격으로 분할한, 즉 \\(x_{i+1}-x_i =h\\) 가 상수일 경우만 생각하기로 한다.\n\n\n\n수열 \\(y_1,\\,y_2,\\ldots\\) 에 대해 전방 차분 (forward difference) 는 \\(\\Delta_F y_i = y_{i+1}-y_i\\) 로 정의된다. 후방 차분 (backward difference) 는 \\(\\Delta_B y_i = y_{i}-y_{i-1}\\) 로 정의된다. 함수 \\(f(x)\\) 에 대해 어떤 특정한 간격 \\(h&gt;0\\) 가 주어졌을 때 전방 차분은 \\(\\Delta_F f(x) = f(x+h)-f(x)\\) 이며 후방차분은 \\(\\Delta_B f(x) = f(x)-f(x-h)\\) 이다. 앞서 말했듯이 수치해석에서는 \\(h\\to 0\\) 극한을 사용할 수 없으므로 차분을 이용하여 미분값을 계산한다.\n\n\n\n\n함수 \\(f\\) 가 \\(C^2\\) 함수일 때 \\(f\\) 에 대한 테일러 전개는 아래와 같다.\n\\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(\\xi_1)}{2} h^2,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(\\xi_2)}{2} h^2.\n\\end{aligned}\n\\tag{1}\\]\n\\(h&gt;0\\) 일 때 전방차분과 후방차분을 이용하여\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x)}{h} + O(h) = \\dfrac{\\Delta_F f(x)}{h} + O(h) \\\\\n&= \\dfrac{f(x)-f(x-h)}{h} + O(h) = \\dfrac{\\Delta_B f(x)}{h} + O(h)\n\\end{aligned}\n\\tag{2}\\]\n로 근사 할 수 있다.\n\n\n\n\n2차와 3차 테일러 다항식 까지 전개한다면 \\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(\\xi_1)}{6} h^3,  \\\\\n&= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_1)}{24}h^4,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(\\xi_2)}{6} h^3, \\\\\n&= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_2)}{24}h^4\n\\end{aligned}\n\\tag{3}\\]\n를 만족하는 \\(\\xi_1,\\,\\xi'_1\\in (x-h,\\, x),\\, \\xi_2,\\,\\xi'_2 \\in (x,\\,x+h)\\) 가 존재한다.\n이로부터\n\\[\n\\begin{aligned}\nf(x+h)-f(x-h) &= 2f'(x) h + \\dfrac{1}{6} \\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)h^3, \\\\\nf(x+h) -2 f(x) + f(x-h) &= f''(x) h^2 + \\dfrac{1}{24}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)h^4\n\\end{aligned}\n\\]\n이므로 우리는 이것을 이용하여 1차 뿐만 아니라 2차 도함수에 대한 근사값도 구할 수 있다. 여기서 \\(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1)\\) 를 보자. \\(\\xi_1\\in [x-h,\\,x],\\, \\xi_2 \\in [x,\\,x+h]\\) 인데, \\(f\\in C^3_{[x-h,x+h]}\\) 이면 따름정리 : 여러 점의 경우 에 의해 \\(f^{(3)}(\\xi) = \\frac{1}{2}\\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)\\) 를 만족하는 \\(\\xi\\in[x-h,\\,x+h]\\) 가 존재하며, 같은 이유로 \\(f\\in C^4_{[x-h,\\,x+h]}\\) 이면 \\(f^{(4)}(\\xi')=\\frac{1}{2}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)\\) 를 만족하는 \\(\\xi'\\in [x-h,\\,x+h]\\) 가 항상 존재한다. 따라서 다음과 같이 도함수와 2차도함수를 근사 할 수 있다.\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x-h)}{2h} - \\dfrac{f^{(3)}(\\xi)}{6}h^2 ,\\\\\nf''(x) &=  \\dfrac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\dfrac{f^{(4)}(\\xi')}{12}h^2\n\\end{aligned}\n\\tag{4}\\]\n이 때 수치해석적으로 계산한 미분의 오차는 \\(h^2\\) 에 비례한다. 따라서 \\(h\\) 을 작게 잡을 수록 오차가 작아지며 충분히 작을 때 전방차분이나 후방차분보다 오차가 작을 것을 기대 할 수 있다. 위의 식에 의해 구한 미분의 추정값을 중앙 차분 (central difference) 라고 한다. 아래 그림은 함수 \\(f\\) 에 대한 전방 차분, 후방 차분, 중앙 차분값을 그림으로 표현하였다. 실제 미분값은 중앙차분에 의한 값과 거의 같다.\n\n\n\nFinite difference\n\n\n양 끝점에서는 도함수를 구할 수 없는데 이때는 전방차분이나 후방차분과 비슷한 방법을 사용하여 구할 수 있다.\n\\[\n\\begin{aligned}\nf(x+2h) & = f(x) + f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 + \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4) \\\\\nf(x-2h) &= f(x) - f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 - \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4),\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\ny'_1 &= \\dfrac{-y_{3}+4y_{2}-3y_1}{2h} + O(h^2),\\\\\ny'_n &= \\dfrac{3y_{n}-4x_{n-1}+y_{n-2}}{2h} + O(h^2).\n\\end{aligned}\n\\tag{5}\\]\n\n\n\n\n\\(h\\) 값이 작을 수록 오차가 작아지지만 \\(h\\) 값이 어느 이하로 작아지면 에러가 발생한다. 아래는 쉬운 예를 보여준다. 우리는 \\(f(x)=e^x\\) 의 도함수는 자기 자신과 같으며, \\(f(0)=f'(0)=1\\) 임을 알고 있다. 앞의 전방, 후반 차분법과 보통의 차분법에 대해 \\(h\\) 값을 변화시키며 \\(f'(0)\\) 의 값을 계산하였다. \\(h\\) 값이 충분히 작지 않을 때는 오차가 발생하였으나 어느 정도 작아지면 그 값이 정확하고 안정적이다. 그러나 \\(h\\) 값이 \\(10^{-13}\\) 보다 작아지면 roundoff 에러가 발생하여 불안정해지는 것을 알 수 있다.\n\n\n\nRoundioff-Finite difference\n\n\n\n\n\n\n지금까지 1차와 2차 테일러 전개를 이용하여 미분계수를 \\(O(h)\\) 나 \\(O(h^2)\\) 의 오차로 구하는 방법을 소개하였다. 고차 테일러 전개를 이용하면 더 정확하게 미분값을 구할 수 있다. 4차 테일러 다항식과 나머지 값은 다음과 같다.\n\\[\n\\begin{aligned}\nf(x-2h) &= f(x) - f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 - \\dfrac{f^{(5)}(\\xi_1)}{120} (2h)^5\\,\\\\\nf(x-h) &= f(x) - f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 - \\dfrac{f^{(5)}(\\xi_2)}{120} (h)^5\\,\\\\\nf(x+h) &= f(x) + f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 + \\dfrac{f^{(5)}(\\xi_3)}{120} (h)^5\\,\\\\\nf(x+2h) &= f(x) + f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 + \\dfrac{f^{(5)}(\\xi_4)}{120} (2h)^5\\,\\\\\n\\end{aligned}\n\\tag{6}\\]\n이로부터,\n\\[\n\\begin{aligned}\nf(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h) &= 12 f'(x) h+ O (h^5) \\,,\\\\\n-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h) &= 12 f''(x) h^2 + O(h^5) .\n\\end{aligned}\n\\]\n임을 안다. 즉,\n\\[\n\\begin{aligned}\nf'(x) & = \\dfrac{f(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h)}{12h} + O(h^5)\\,,\\\\\nf''(x) &= \\dfrac{-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h)}{12h^2} + O(h^4)\n\\end{aligned}\n\\tag{7}\\]\n이다.\n다음 그림은 함수 \\(f(x) = x\\sin (x)\\) 에 대해 \\(h\\) 를 변화시켜 가면서로 잡고 위에서 설명한 두가지 방법을 이용하여 도함수를 구했을때의 그래프(“3 Points”, “5 Points”) 와 \\(f'(x) = \\sin (x) + x\\cos (x)\\) 의 그래프 (“Analytical”) 를 같이 그린 것이다. \\(h=1\\times 10^{-1}\\) 에서는 첫번째 수치미분보다 두번째 수치미분이 좀 더 실제 값에 가까우며 \\(1 \\times 10^{-2}\\) 부터 \\(1.0 \\times 10^{-14}\\) 까지는 두 방법 모두 상당히 정확한 값을 보여준다. 그러나 \\(h\\) 값이 \\(1.0\\times 10^{-15}\\) 보다 작아지면서부터는 뚜렷하게 오차를 보여준다. 이것은 수치 미분을 구할 때 분모를 \\(h\\) 로 나누게 되는데, 이 값이 작을수록 round-off 에러가 발생하기 때문이다. 따라서 적당한 \\(h\\) 값을 잡는 것이 중요하다.\n\n\n\n\nDerivative"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#일변수-함수의-적분-뉴턴-코츠-방법",
    "href": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#일변수-함수의-적분-뉴턴-코츠-방법",
    "title": "일변수 함수의 미분과 적분",
    "section": "2 일변수 함수의 적분 : 뉴턴-코츠 방법",
    "text": "2 일변수 함수의 적분 : 뉴턴-코츠 방법\n수치해석적으로 적분을 구하는 방법을 알아보도록 한다. 다항식이나 삼각함수, 지수함수를 포함한 몇면 함수에 대해서는 우리가 이미 프로그래밍 언어에 내장되어 있는 기본적인 함수로 존재하므로 쉽게 구할 수 있다. 예를 들어 \\([0, \\theta]\\) 영역에서의 \\(\\sin x\\) 함수의 적분은\n\\[\n\\int_0^\\theta \\sin x \\, dx = -\\cos \\theta  +1\n\\]\n이라는 것을 안다. 그러나 대부분의 함수는 수치해석적으로 구할 수 밖에 없다. 수학적으로는 우리는 어떤 구간에서 연속인 함수라면 그 구간에서 적분이 존재한다는 것을 알고 있다. 또한 \\([a,\\,b]\\) 구간에서 불연속인 점이 유한개이면 적분이 존재한다는 것도 알고 있다1. 만약 적분구간이 부분적으로 연속인 유한개의 구간으로 이루어져 있다면, 각각의 유한개의 구간에 대한 적분의 합으로 생각 할 수 있으므로, 여기서는 연속인 경우만 다루기로 한다. 미분과 마찬가지로 \\([a,\\,b]\\) 구간이 \\(x_1=a&lt;x_2&lt;\\cdots &lt;x_{n-1}&lt;x_n=b\\) 인 \\(n\\) 개의 점을 이용하여 \\(n-1\\) 개의 부분구간(subintervals)로 분할되었다고 가정한다. 이렇게 적분을 유한개의 구간으로 나누어 구간의 합으로 계산하는 방법을 구적법(quadrature) 라고 한다.\n\n\n뉴턴 코츠(Newton-Cotes) 방법\n많은 경우 구간의 간격 \\(x_{i+1}-x_i\\) 가 항상 같으며, 이 경우 적분을 구적법으로 구하는 것을 Newton-Cotes 방법이라고 한다. 구간의 간격을 \\(h\\) 라고 하자. 즉 \\([a,\\,b]\\) 구간을 \\(a=x_1&lt;\\cdots &lt;x_n=b\\) 로 등간격으로 나누었다고 하자. 이 때, 양 끝점을 포함하여 구간을 나눌 수도 있고, 양 끝점을 빼고 구간을 나눌 수도 있다. 양 끝점을 포함하는 것을 닫힌 Newton-Cotes 방법(closed Newton-Cotes method) 이라고 하고, 양 끝점을 빼는 것을 열린 Newton-Cotes 방법(open Newton-Cotes method) 이라고 한다. 여기서는 닫힌 Newton-Cotes 방법에 대해서 주로 다루기로 한다. 우선 \\([a,\\,b]\\) 구간을 \\(n\\) 개의 점 \\(x_1,\\ldots,\\,x_n\\) 을 이용하여 \\(n-1\\) 개의 등간격으로 분할하면 각 \\(x_i\\) 는 다음과 같다.\n\\[\nx_i = a + (i-1)h = a+ (i-1)\\dfrac{(b-a)}{n-1},\\qquad i=1,\\ldots,\\,n\n\\]\n이 때 적분값을 \\(f(x_1), \\ldots,\\,f(x_n)\\) 의 선형결합으로 다음과 같이 표현하는 것이 Newton-Cotes 방법이다.\n\\[\n\\begin{aligned}\n\\int_{a}^b f(x)\\, dx &\\approx \\sum_{k=1}^n w_i f(x_i)\\qquad & & \\text{closed Newton-Cotes method}\\\\\n&\\approx \\sum_{i=2}^{n-1} w_i f(x_i) \\qquad & & \\text{open Newton-Cotes method}\n\\end{aligned}\n\\]\n즉 우리가 여기서 구해야 할 것은 각 구간에서의 weight factor \\(w_i\\) 이다. Newton-Cotes 방법을 이용한 대표적인 적분방법이 Trapzoidal 방법과 Simpson 방법이다.\n\n\n\n\nTrapzoidal method 와 Simpson method\n\n\n\n중점법은 구간 \\([x_i,\\, [x_{i+1}]]\\) 의 중점 \\(x^m_{i}\\) 을 이용하여 적분값을 \\(f(x^m_{i})h\\) 로 추정하는 방법이다. Trepziodal 방법은 \\([x_i,\\,x_{i+1}]\\) 의 적분을 \\((x_i,\\, f(x_i))\\) 와 \\((x_{i+1},\\, f(x_{i+1}))\\) 을 1차 함수로 근사하여 적분값을 계산한다. Simpson 방법은 두가지가 있는데 각각은 이어지는 세 점이나 네 점을 각각 2차함수와 3차함수로 근사하여 적분하는 방법이다. $\n\n\n\n중점을 이용한 적분\n\\([x_{i},\\, x_{i+1}]\\) 구간에 대한 적분을 구할 때 구간 끝잠의 중점 \\(x^m_i = \\dfrac{x_{i+1}+x_{i}}{2}\\) 에서의 함수값을 사용하는 방법이다. 즉,\n\\[\n\\int_{x_{i}}^{x_{i+1}} f(x)\\,dx\\approx f\\left(\\dfrac{x_{i+1}+x_i}{2}\\right) h = f(x^m_i) h\n\\]\n로 근사하는 방법이다. 테일러 정리에 의해\n\\[\nf(x) = f(x^m_i)+f'(x^m_i)(x-x_m) + \\dfrac{1}{2}f^{(2)}(\\xi) (x-x_m)^2\n\\]\n을 만족하는 \\(\\xi_i\\in [x_{i},\\, x_{i+1}]\\) 이 존재한다.\n\\[\n\\int_{x_i}^{x_{i+1}} f(x)\\, dx = f(x_i^m)h + \\dfrac{1}{24}f^{(2)}(\\xi_i)h^3\n\\]\n이다. \\([a,\\,b]\\) 를 \\(a=x_1&lt;x_2&lt;\\cdots &lt;x_n=b\\) 의 \\(n\\) 개의 점을 이용하여 \\(n-1\\) 개의 구간으로 나누어 적분하면,\n\\[\n\\int_a^b f(x) \\,dx= \\sum_{i=1}^{n-1} f\\left(\\dfrac{x_{i}+x_{i+1}}{2}\\right) h + \\dfrac{h^3}{24} \\sum_{i=1}^{n-1}f^{(2)}(\\xi_i)\n\\]\n이다. \\(f\\in C^2_{[a,\\,b]}\\) 라면 따름정리 : 여러 점의 경우 에 의해 \\(\\displaystyle \\sum_{i=1}^{n-1}f^{(2)}(\\xi_i) = (n-1)f^{(2)}(\\xi)\\) 를 만족하는 \\(\\xi\\in [a,\\,b]\\) 가 존재하므로,\n\\[\n\\int_a^b f(x) \\, dx =  \\sum_{i=1}^{n-1} f\\left(\\dfrac{x_{i}+x_{i+1}}{2}\\right) h + \\dfrac{(n-1)h^3}{24} f^{(2)}(\\xi)\n\\]\n를 만족한다. 적분의 근사값을 \\(I_M[a, b, n]\\) 을\n\\[\nI_M [f,\\,a,\\,b,\\,n] = \\sum_{i=1}^{n-1}f\\left(\\dfrac{x_{i}+x_{i+1}}{2}\\right) h\n\\]\n이라고 할 수 있으며, \\(M=\\max \\{ |f^{(2)}(x)| : x\\in [a,\\,b] \\}\\) 일 때 중점을 이용한 적분의 오차는 \\(E_M [f,\\,a,\\,b,\\,n]=\\dfrac{(n-1)h^3}{24} M=\\dfrac{(b-a)M}{24}h^2\\) 보다 작거나 같다. 즉 \\(O(E_M) =h^2\\) 이다.\n\n\n\n사다리꼴 방법 를 이용한 적분\n함수 \\(f(x)\\) 를 \\([x_i,\\, x_{i+1}]\\) 구간에서 1차 다항식으로 근사하는 것을 사다리꼴 방법 이라고 하며, 주어진 점으로부터 다항식을 구하는 방법은 다항식을 이용한 전역적 보간법 에서 설명한 세가지 방법중 한가지를 사용한다.\n\n\\([x_{i-1},\\, x_i]\\) 구간에서 \\((x_{i-1},\\, f(x_{i-1}))\\) 과 \\((x_{i},\\, f(x_i))\\) 를 1차 다항식으로 근사하면 다항식을 이용한 보간법의 오차 의 정리 1 에서 보았듯이 다음을 만족하는 \\(\\xi\\in [x_{i-1},\\, x_i]\\) 가 존재한다. \\[\n\\begin{aligned}\nf(x) = f(x_{i-1})\\dfrac{x-x_{i}}{x_{i-1}-x_i} + f(x_i)\\dfrac{x-x_{i-1}}{x_{i}-x_{i-1}} + \\dfrac{f^{(2)}(\\xi_i)}{2}(x-x_{i-1})(x-x_i).\\\\\n\\end{aligned}\n\\]\n이것을 \\([x_{i-1},\\, x_i]\\) 구간에서 적분하면 다음을 얻는다.\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_i} f(x)\\, dx = \\dfrac{h}{2}(f(x_{i-1})+f(x_i)) -\\dfrac{f^{(2)}(\\xi)}{12} h^3\n\\end{aligned}\n\\]\n전체 구간 \\([a,\\,b]\\) 에 대해 적분하면\n\\[\n\\int_{a}^b f(x)\\, dx= \\dfrac{h}{2}(f(x_1)+ f(x_n)) + \\sum_{i=2}^{n-1} hf(x_i) - \\dfrac{h^3}{12}\\sum_{i=1}^{n-1} f^{(2)}(\\xi_i)\n\\]\n를 얻는다. 사다리꼴 방법에 의한 적분값 \\(I_T\\) 는\n\\[\nI_T[f, a, b, n] = \\dfrac{h}{2}\\left(f(x_1)+ f(x_n) + \\sum_{i=2}^{n-1} f(x_i)\\right)\n\\]\n이다. 이제 적분의 오차를 알아보자. \\(f^{(2)}(x)\\) 가 연속이므로 \\(\\displaystyle \\dfrac{1}{n-1}\\sum_{i=1}^{n-1} f^{(2)}(\\xi_i)= f^{(2)}(\\xi)\\) 를 만족하는 \\(\\xi\\in [a,\\,b]\\) 가 존재하며2 따라서 사다리꼴 방법에 의한 적분에 대한 에러 \\(E_T\\) 는\n\\[\nE_T[f, a, b, n] = \\dfrac{h^3}{12}(n-1)f^{(2)}(\\xi) = \\dfrac{h^3}{12}\\dfrac{b-a}{h}f^{(2)}(\\xi) = \\dfrac{(b-a)f^{(2)}(\\xi)}{12}h^2 = O(h^2)\n\\]\n이다.\n\n\n\nSimpson 1/3 적분\n\\([x_{i-1},\\,x_{i+1}]\\) 구간에서의 적분을 생각하자. 테일러 정리에 의해\n\\[\nf(x) = f(x_i) + f'(x_i)(x-x_i) + \\dfrac{f''(x_i)}{2}(x-x_i)^2 + \\dfrac{f^{(3)}(x_i)}{6}(x-x_i)^3 + \\dfrac{f^{(4)}(\\xi_i)}{24}(x-x_i)^4\n\\]\n를 만족하는 \\(\\xi_i \\in [x_{i-1},\\, x_{i+1}]\\) 이 존재한다. 양변을 적분하면\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+1}}f(x)\\,dx &= f(x_i)(2h) + \\dfrac{f''(x_i)}{3}h^3 + \\dfrac{f^{(4)}(\\xi_i)}{60}h^5\n\\end{aligned}\n\\]\n이다. 또한 식 4 로부터\n\\[\nf''(x) =  \\dfrac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\dfrac{f^{(4)}(\\xi_i')}{36}h^5\n\\]\n를 만족하는 \\(\\xi_i'\\in [x_{i-1},\\,x_{i+1}]\\) 가 존재한다는 것을 알고 있다. 따라서\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+1}}f(x)\\,dx &= f(x_i)(2h) + \\dfrac{h}{3}\\left( f(x_{i+1}) -2f(x_i) + f(x_{x-i}) \\right)  + \\left(\\dfrac{f^{(4)}(\\xi_i)}{60} - \\dfrac{f^{(4)}(\\xi_i')}{36} \\right)h^5 \\\\\n&=\\dfrac{1}{3} \\left[f(x_{i-1}) + 4f(x_{i}) + f(x_{i+1})\\right] -  \\left( \\dfrac{f^{(4)}(\\xi_i')}{36} - \\dfrac{f^{(4)}(\\xi_i)}{60} \\right)h^5\n\\end{aligned}\n\\]\n따라서 우리는 Simpson 1/3 적분에서의 오차가 \\(O(h^5)\\) 임을 알 수 있다. 여기서는 \\(\\xi_i\\) 와 \\(\\xi_i'\\) 에서의 4차 도함수값이 필요했지만 실제로는\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+1}}f(x)\\,dx =\\dfrac{h}{3} \\left[f(x_{i-1}) + 4f(x_{i}) + f(x_{i+1})\\right] -  \\dfrac{f^{(4)}(\\overline{\\xi}_i)}{90}h^5\n\\end{aligned}\n\\]\n를 만족하는 \\(\\overline{\\xi}_i \\in [x_{i-1},\\,x_{i+1}]\\) 가 존재한다(Atkinson, Kendall E. (1989). An Introduction to Numerical Analysis (2nd ed.). John Wiley & Sons. 을 참고하라)\n이제 \\([a,\\,b]\\) 구간을 \\(a=x_1&lt;x_2&lt;\\cdots&lt;x_{2n}&lt;x_{2n+1}=b\\) 의 \\(2n\\) 개의 구간으로 나누어 적분하여 합치는 것을 생각하자. Simpson 1/3 적분은 2개의 구간을 한꺼번에 적분하므로 \\(2n+1\\) 개의 위치가 필요하다. 에러도 \\(2n+1\\) points 에 대한 중간값 정리를 사용하면 다음을 만족하는 \\(\\xi \\in [x_1,\\,x_{2n+1}]\\) 이 존재한다.\n\\[\n\\begin{aligned}\n\\int_{a}^b f(x)\\, dx &= \\dfrac{h}{3} \\left[f(x_1) + 4f(x_2) + 2f(x_3) + 4f(x_4) + 2f(x_5)+\\cdots \\right.\\\\\n&\\qquad \\cdots \\left.+ 4f(x_{2n-2})+2f(x_{2n-1}) + 4f(x_{2n})+f(x_{2n+1})\\right] - \\dfrac{n}{2}\\dfrac{f^{(4)}(\\xi)}{90}h^5\n\\end{aligned}\n\\]\n따라서 Simpson 1/3 적분값은 다음과 같다. \\[\n\\mathcal{I}_{1/3}[f,\\,a,\\,b,\\, 2n+1] = \\dfrac{h}{3} \\left[f(x_1) + f(x_{2n+1}) + 4\\left(\\sum_{k=1}^n  f(x_{2k})\\right) + 2\\left(\\sum_{k=1}^{n-1} f(x_{2k+1})\\right)\\right]\n\\]\n\n\n\nSimpson 3/8 적분\nSimpson 1/3 적분이 전체 \\(n\\) 개의 구간을 2개씩 묶어서 적분하여 합쳤다면 3/8 적분은 3개씩 묶어서 합친다. 라그랑쥬 다항식을 이용하면,\n\\[\nL_4(x) = f(x_{i-1})l_{i-1}(x) + f(x_i)l_i(x) + f(x_{i+1})l_{i+1}(x) + f(x_{i+2})l_{i+2}(x)\n\\]\n에 대해\n\\[\nf(x) = L_4 (x) + \\dfrac{f^{(4)}(\\xi_i)}{4!}\\prod_{j=1}^4(x-x_{j-2})\n\\]\n를 만족하는 \\(\\xi_i\\in [x_{i-1},\\, x_{i+2}]\\) 가 존재한다.\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+2}} f(x)\\, dx = \\dfrac{3h}{8} \\left( f(x_{i-1}) + 3 f(x_{i}) + 3f(x_{i+1}) + f(x_{i+2})\\right) - \\dfrac{3}{80}f^{(4)}(\\xi) h^5\n\\end{aligned}\n\\]\n를 얻는다. 이것을 \\([a,\\,b]\\) 구간을 \\(a=x_1&lt;\\cdots &lt;x_{3n+1}=b\\) 이며 \\(x_{i+1}-x_i = h=\\text{const.}\\) 라면\n\\[\n\\begin{aligned}\n\\int_a^b f(x)\\, dx &= \\dfrac{3h}{8} \\left[f(x_1) + f(x_{3n+1}) + 3\\sum_{i=0}^{n-1} \\left(f(x_{3i+2}) + f(x_{3i+3})\\right)  + 2\\sum_{i=1}^{n-1} f(x_{3i+1})\\right] - \\dfrac{3n}{80}f^{(4)} (\\xi) h^5\n\\end{aligned}\n\\]\n를 만족하는 \\(\\xi \\in [a,\\,b]\\) 가 존재한다. 여기서\n\\[\n\\mathcal{I}_{3/8}[f,\\,a,\\,b,\\, 3n+1]=\\dfrac{3h}{8} \\left[f(x_1) + f(x_{3n+1}) + 3\\sum_{i=0}^{n-1} \\left(f(x_{3i+2}) +f(x_{3i+3})\\right) +  + 2\\sum_{i=1}^{n-1} f(x_{3i+1})\\right]\n\\]\n는 Simpson 3/8 적분값이며 그 오차는 \\(- \\dfrac{3n}{80}f^{(4)} (\\xi) h^5\\) 이다.\n\n\n아래 그림은 \\(\\displaystyle \\int_0^1 \\exp(x)\\, dx\\) 를 세가지 방법으로, 구간을 변화시켜 가며 구하여 실제값인 \\((e-1)\\) 로 나눈 비율을 표현하였다. \\(N_{points}\\) 가 작을 때는 계산값간의 다소간의 차이가 있으며 실제 값과도 차이가 있지만 \\(N_{points}\\) 값이 커질수록 세 방법 모두 실제 값에 수렴해 나간다는 것을 볼 수 있다. 또 하나 유의할 것은 Simpson 3/8 방법이 Simpson 1/3 방법보다 다소 복잡함에도 불구하고 일반적으로 실제 값과의 차이는 Simpson 1/3 방법이 더 작다. 이런 이유로 단순이 Simpson 방법이라고 할 때는 Simpson 1/3 방법을 말한다.\n\n\n\n수치 적분\n\n\nfunction integrate_trapzoidal(\n    f::Function, \n    a::Number, \n    b::Number, \n    n::Integer)\n    \n    a, b = minmax(a, b)\n    h = (b-a)/n\n    x = range(a, b, length = n+1)\n    ff = f.(x)\n    result = 0.5*(ff[1]+ff[end])\n    result += sum(ff[2:end-1])\n    return result*h\nend\n\nfunction integrate_simpson_1_3(\n    f::Function, \n    a::Number, \n    b::Number, \n    n::Integer)\n    @assert n %2 ==0\n    a, b = minmax(a, b)\n    h = (b-a)/n\n    x = range(a, b, length = n+1)\n    ff = f.(x)\n    result = (ff[1]+ff[end])\n    result += 4*sum(ff[2:2:end-1])\n    result += 2*sum(ff[3:2:end-2])\n    return result * h/3\nend\n\nfunction integrate_simpson_3_8(\n    f::Function,  \n    a::Number, \n    b::Number, \n    n::Integer)\n    @assert n %3 ==0\n    a, b = minmax(a, b)\n    h = (b-a)/n\n    x = range(a, b, length = n+1)\n    println(\"h=$h, dx=$(x[10]-x[9])\")\n    ff = f.(x)\n    result = (ff[1]+ff[end])\n    result += 3*sum(ff[2:3:end-2])\n    result += 3*sum(ff[3:3:end-1])\n    result += 2*sum(ff[4:3:end-3])\n    return result * h * 3 / 8\nend"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#리처드슨-외삽법과-롬버그-적분",
    "href": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#리처드슨-외삽법과-롬버그-적분",
    "title": "일변수 함수의 미분과 적분",
    "section": "3 리처드슨 외삽법과 롬버그 적분",
    "text": "3 리처드슨 외삽법과 롬버그 적분\n\n리처드슨 외삽법\n어떤 값 \\(M\\) 을 계산하는데 매개변수 \\(h\\) 에 대해 그 truncation 오차가 \\(O(h)\\) 인 방법을 사용하여 \\(N_1(h)\\) 를 얻었다고 하자. 이 때 우리는\n\\[\nM - N_1(h) = k_1 h + k_2 h^2 + O(h^3)\n\\tag{8}\\]\n라고 생각 할 수 있다. 이것을 약간 변형하면,\n\\[\nM-N_1\\left(\\dfrac{h}{2}\\right) = k_1 \\dfrac{h}{2} + k_2 \\dfrac{h^2}{4} + O(h^3)\n\\tag{9}\\]\n이며 \\(2\\times\\)(식 9)\\(-\\)(식 8) 를 계산하면,\n\\[\n\\begin{aligned}\nM&=\\left[2N_1\\left(\\dfrac{h}{2}\\right) - N_1(h) \\right] - k_2 \\dfrac{h^2}{2} + O(h^3) = N_2(h) + O(h^2) \\\\\n&\\qquad \\qquad \\text{where} \\; N_2(h) = \\left[2N_1\\left(\\dfrac{h}{2}\\right) - N_1(h) \\right]\n\\end{aligned}\n\\]\n이다. 즉 \\(O(h)\\) 인 방법을 이용하여 truncation 오차가 \\(O(h^2)\\) 인 추정값 \\(N_2(h)\\) 를 얻었다. 이렇게 정확도가 낮은 값을 이용하여 정확도가 높은 값을 얻는 것을 리처드슨 외삽법이라고 한다. 리처드슨 외삽법은 truncation 오차가 다항식 꼴인 방법에 대해 항상 사용 할 수 있다.\n\\(M\\) 에 대해 tuncation 오차가 \\(O(h^2)\\) 인 방법을 사용하여 \\(N_2(h)\\) 를 얻었다고 하자.\n\\[\n\\begin{aligned}\nM - N_2 (h) &= k_2h^2 + k^3 h^3 + O(h^4) , \\\\\nM - N_2 \\left(\\dfrac{h}{2}\\right) &= k_2\\dfrac{h^2}{4} + k_3 \\dfrac{h^3}{8} + O(h^4)\n\\end{aligned}\n\\]\n를 이용하여,\n\\[\n\\begin{aligned}\nM &= \\dfrac{1}{3}\\left[4N_2 \\left(\\dfrac{h}{2}\\right)-N_2(h)\\right] - k_3 \\dfrac{h^3}{6} + O(h^4) = N_3(h) + O(h^3) \\\\\n&\\qquad \\qquad \\text{where} \\; N_3(h)=\\dfrac{1}{3}\\left[4N_2 \\left(\\dfrac{h}{2}\\right)-N_2(h)\\right]\n\\end{aligned}\n\\]\n를 얻는다. 즉 \\(O(h^2)\\) 인 방법을 이용하여 \\(O(h^3)\\) 인 값을 얻었다.\n이것을 일반화하여 보자. \\(O(h^n)\\) 인 방법을 사용하여 \\(M\\) 의 값을 \\(N_n(h)\\) 로 얻었다고 하자.\n\\[\n\\begin{aligned}\nM - N_n(h) &=  k_n h^n + k_{n+1}h^{n+1} + O(h^{n+2}), \\\\\nM - N_n\\left(\\dfrac{h}{2}\\right) & = k_n \\left(\\dfrac{h}{2}\\right)^n + k_{n+1}\\left(\\dfrac{h}{2}\\right)^{n+1} + O(h^{n+2})\n\\end{aligned}\n\\]\n를 이용하여,\n\\[\n\\begin{aligned}\nM &= \\dfrac{1}{2^n-1}\\left[ 2^n N_n \\left(\\dfrac{h}{2}\\right)-N_n (h)\\right] - \\dfrac{k_{n+1}}{2(2^n-1)}h^{n+1} + O(h^{n+2}) \\\\\n&= N_{n+1}(h) + O(h^{n+1})\n\\end{aligned}\n\\]\n을 얻는다.\n\n\n보기 1 (리차드슨 미분) 우리는 이미 식 4 에 의해\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x-h)}{2h} - \\dfrac{f^{(3)}(\\xi)}{6}h^2 ,\\\\\nf''(x) &=  \\dfrac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\dfrac{f^{(4)}(\\xi')}{12}h^2\n\\end{aligned}\n\\]\n임을 안다. \\(N_1 (h) = \\dfrac{f(x+h)-f(x-h)}{2h}\\) 이며 \\(f'(x) = N_1(h) +O(h^2)\\)\n\n\n\n\n롬버그 적분\n앞서 Trapzoidal 방법을 통해 \\(O(h^2)\\) 의 오차를 갖는 함수 \\(f\\) 의 적분값을 얻었다. 이것을 리차드슨 외삽법과 결합하면 \\(O(h^3)\\) 의 오차를 갖는 적분값을 계산 할 수 있을 것이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#footnotes",
    "href": "src/numerical_analysis_using_julia/05_calculus_of_one_variable_function.html#footnotes",
    "title": "일변수 함수의 미분과 적분",
    "section": "각주",
    "text": "각주\n\n\n더 정확히 말하자면 불연속인 점이 무한개라도 가산(countable) 이면 적분이 존재하지만, 어짜피 불연속인 점이 무한개일 경우는 여기서 다루지 않는다.↩︎\n최대 최소 정리 을 생각하자. \\([a,\\,b]\\) 구간에서 연속인 함수 \\(g(x)\\) 는 최대값 \\(g_M\\) 과 최소값 \\(g_m\\) 을 가진다. \\(\\{x_1,\\ldots,\\,x_n\\}\\subset [a,\\,b]\\) 라면 \\(g_m \\le g(x_i) \\le g_M\\) 이며, \\[\ng_m \\le \\dfrac{g(x_1)+ \\cdots + g(x_n)}{n}  \\le g_M\n\\] 이다. 중간값 정리에 의해 \\(g(\\overline{\\xi}) = \\dfrac{g(x_1)+ \\cdots + g(x_n)}{n}\\) 를 만족하는 \\(\\overline{\\xi}\\in [a,\\,b]\\) 가 존재한다.↩︎"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_finding_root.html",
    "href": "src/numerical_analysis_using_julia/06_finding_root.html",
    "title": "일변수 방정식의 해",
    "section": "",
    "text": "우리는 수학을 배운 이후 \\(2x-6=0\\) 와 같은 방정식의 해를 구하는 것을 배워 왔다. 여기서는 일변수 방정식, 그중에서도 실함수에 대한 실수해를 구하는 방법을 알아본다.\n많은 경우 우리는 해가 존재하는지 아닌지 여부를 쉽게 알 수 있다. 예를 들어 3차방정식의 경우는 최소한 하나의 해가 존재하며 복잡하긴 하지만 우리는 그 계수만을 가지고 근을 알 수 있는 공식이 존재한다는 것을 안다. 그러나 5차방정식 혹은 그 이상의 홀수차 방정식의 경우는 그 계수만으로 해를 알 수 있는 근의공식이 존재하지 않지만 최소한 하나의 해가 존재한다는 것을 알고 있다. 이 장에서 다루는 수치해석적인 방법을 통해 어떤 구간 안에서 해가 하나 이상 존재하는 것을 미리 알고 있을 때, 그 구간에서의 해를 하나 구할 수 있다.\n또 하나 이 장에서 새롭개 배우는 것은 소위 반복법 (iteration) 이다. 지금까지는 이미 존재하는 함수나 데이터를 통해 우리가 구하고자 하는 값을 직접적으로 구했다. 그러나 많은 경우 직접적으로 이 값을 구할 수 없으며, 이런 경우에는 반복적인 계산을 통해 우리가 구하고자 값에 가까운 값을 구할 수 있다. 이 때 우리가 이 반복적인 실행을 통해 원하는 값을 얻었는지를 판단할 수 있는 근거가 필요한데 이 값들을 허용범위(tolerence) 라고 한다. 예를 들어 우리가 방정식 \\(f(x)=0\\) 의 어떤 해가 \\((-1.0\\times 10^{-8}, \\, 1.0\\times 10^{-8})\\) 구간에 존재한다는 것을 알았다고 하자. 이 경우 해를 \\(x=0\\) 으로 잡으면 최대 오차는 \\(1.0 \\times 10^{-8}\\) 인데 어떤 경우는 부족하지만 어떤 경우는 충분히 만족스러울 수 있다. 만약 이정도의 오차가 충분히 만족스럽다면 허용범위를 구간의 범위가 \\(2.0 \\times 10^{-8}\\) 보다 작다고 정하면된다. 문제에 따라 다양한 허용 범위를 조합하여 사용 할 수도 있다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_finding_root.html#하나의-해를-찾는-법",
    "href": "src/numerical_analysis_using_julia/06_finding_root.html#하나의-해를-찾는-법",
    "title": "일변수 방정식의 해",
    "section": "1 하나의 해를 찾는 법",
    "text": "1 하나의 해를 찾는 법\n\n이분법 (Bisection Method)\n함수 \\(f\\) 가 \\((a,\\,b)\\) 에서 연속이며, \\(f(a)&lt;0\\) 이고 \\(f(b)&gt;0\\) 이거나 혹은 \\(f(a)&gt;0\\) 이고 \\(f(b)&lt;0\\) 이라 하자. 즉 \\(f(a)\\cdot f(b)&lt;0\\) 이라고 하자. 중간값 정리 에 따라, \\(f(a)\\cdot f(b)&lt;0\\) 이면, \\((a,\\,b)\\) 구간의 최소한 한 점에서 \\(f(x)=0\\) 의 해가 존재한다는 것을 안다. 이 조건만으로는 해가 \\((a,\\,b)\\) 구간에서 몇개인지는 모르지만 최소한 하나는 존재한다는 것을 알 수 있다. 이분법은 이 조건이 만족하는 구간에서 하나의 근사적인 해를 구하는 방법이다.\n\n일단 \\(f(a)&lt;0,\\, f(b)&gt;0\\) 인 경우에 대해 생각하자. \\(c=\\dfrac{a+b}{2}\\) 로 놓으면 \\(a&lt;b&lt;c\\) 이다.\n우연히도 \\(f(c) =0\\) 이면 우리는 원하는 것을 얻었으므로 끝이다. \\(f(c)&gt;0\\) 이면, \\(f(a)\\cdot f(c)&lt;0\\) 이므로 역시 중간값 정리에 의해 \\((a,\\,c)\\) 구간에 해가 반드시 존재한다. \\((c,\\,b)\\) 구간에 존재여부는 이 조건에서는 알 수 없으며, 우리는 이 구간은 이제 잊는다. \\(f(c)&lt;0\\) 이면 \\(f(c)\\cdot f(b)&lt;0\\) 이므로 \\((c,\\,b)\\) 구간에 해가 존재한다.\n이제 우리는 해가 반드시 존재하는 원래 구간 길이의 1/2 인 새로운 구간을 얻었다. 이제 1. 로 돌아가 새로운 구간에서 다시 수행한다.\n\n\\(f(a)&gt;0,\\,f(b)&lt;0\\) 인 경우에도 같은 방법을 쓸 수 있다는것은 쉽게 이해 할 수 있을 것이다.이 방법을 한번 쓸 때 마다 해가 존재하는것이 확실한 구간이 이전보다 \\(\\frac{1}{2}\\) 씩 준다. 이것을 \\(n\\) 번 수행하면, 운 좋게도 \\(f(c)=0\\) 이 되지 않는 한, 해가 존재하는 구간의 길이는 \\(\\frac{1}{2^{n}}|b-a|\\) 로 계속 준다. 10번 수행하면 처음 시작 구간의 약 0.1% 로, 100 번 하면 약 백만분의 일로 준다.\n\n\n이분법 과정\n\n\n\n이분법\n\n\n이 과정을 프로그래밍 입장에서 다시 정리해보자. 일단 처음 주어지는 함수 \\(f(x)\\) 와 \\(a,\\,b\\) 에 대해 \\(a&lt;b\\) 로 주어졌다고 하자. 그리고 우리는 실제의 근 \\(x_0\\) 와 우리가 구한 근의 차이를 어떤 작은 양수 \\(\\delta\\) 보다 작게 하고자 한다. 이 \\(\\delta\\) 가 허용범위이다.\n\n\\(a_0=a,\\,b_0=b,\\,c_0=\\dfrac{a+b}{2}\\) 로 놓는다. 만약 \\(f(a_0) \\cdot f(c_0)&lt;0\\) 이면 역시 중간값 정리에 의해 \\((a_0,\\, c_0)\\) 구간에 해가 존재함을 알 수 있다. 그렇다면 \\(a_1=a_0,\\, b_1=c_0\\) 으로 놓는다. 반대로 \\(f(a_0)\\cdot f(c_0)&gt;0\\) 이면 \\(f(c_0)\\cdot f(b_0)&lt;0\\) 이므로 \\((c_0,\\,b_0)\\) 구간에 해가 존재한다. 이때는 \\(a_1=c_0,\\, b_1=b_0=b\\) 로 놓는다. \\(f(c_0)=0\\) 이면 \\(c\\) 이 \\(f(x)=0\\) 의 해이므로 더이상 진행하지 않는다.\n\\(a_n&lt;b_n\\) 에 대해 \\(f(a_n)\\cdot f(b_n)&lt;0\\) 이라 하자. \\(|b_n-a_n|&lt;2\\delta\\) 이면 실제의 근 \\(x_0\\) 와 \\(c_n =\\dfrac{a_n+b_n}{2}\\) 의 차이는 \\(\\delta\\) 보다 작기 때문에 \\(c_n\\) 이 우리가 구하고자 하는 수치적인, 그리고 근사적인 근이 된다. \\(|b_n-a_n|\\ge 2\\delta\\) 이면, \\(c_n =\\dfrac{a_n+b_n}{2}\\) 이라 놓는다. \\(f(c_n)=0\\) 이면 우리는 하나의 해를 구했으므로 종료한다. \\(f(a_n)\\cdot f(c_n)&lt;0\\) 이면 \\((a_n,\\,c_n)\\) 구간에서 하나의 해가 존재하므로 \\(a_{n+1}=a_n,\\, b_{n+1}=b_n\\) 으로 놓고 이 과정을 계속 한다. \\(f(a_n)\\cdot f(c_n)&gt;0\\) 이면 \\(f(b_n) \\cdot f(c_n)&lt;0\\) 이므로 \\(a_{n+1}=c_n,\\, b_{n+1}=b_n\\) 으로 놓는다.\n\n\n이제 이것을 줄리아로 구현해 보자. 실제 프로그래밍 상에서는 \\(a_n\\) 이나 \\(b_n\\) 계산하지 않고, \\(a,\\,b\\) 의 변수값을 계속 바꾸도록 한다. \\(a_n\\) 과 \\(b_n\\) 의 지난 값이 중요하다면 기억하겠지만 대부분의 경우는 그렇지 않기 때문이다.\n\n\n\n이분법에 대한 julia 함수\n이분법을 bisection 함수로 구현해보자. 우선 인자로 해를 구하고자 하는 함수(f) 와, 양 끝 구간(a, b), 그리고 허용범위(xtol)가 필요하다. 이분법은 잠시 뒤에 보이겠지만 허용범위가 양수일 경우 유한번의 반복으로 허용범위 내의 근사적 해를 구한다. 실제 계산에서는 필요하지 않을 수도 있지만 여기서는 몇번의 반복으로 해를 구했는지 확인하기 위해 bisection 함수가 근사적 해와 반복 횟수를 반환하도록 한다.\nfunction bisection(f::Function,     # 함수\n    a::Real,                        # 구간값 1\n    b::Real,                        # 구간값 2\n    xtol::Real = 1.0e-8,             # 해의 오차의 허용 범위\n    etol::Real = 1.0e-10)           # 해의 함수값의 허용 범위\n    Niter = 0\n    a, b = minmax(a, b)\n    f(a)*f(b) &lt;= 0 || error(\"f(a)*f(b) should be negative\") \n    c = (a+b)/2\n    while ((b-a) &gt; 2*xtol) || (abs(f(c))&lt;etol)\n        Niter +=1\n        \n        if f(c) == 0.0\n            break\n        elseif f(a)*f(c) &lt; 0 \n            a, b = a, c\n        else \n            a, b = c, b \n        end\n        c = (a+b)/2\n    end\n    return c, Niter\nend\n이제 이분법을 이용하여 \\(\\sqrt{2}\\) 의 근사값을 구할 수 있다. \\(\\sqrt{2}\\) 는 \\(f(x)=x^2-2\\) 의 근이므로\nbisection(x -&gt; x^2-2, 0.0, 4.0)\n라 하면, sqrt2 의 값은 다음과 같다.\n(1.4142135605216026, 28)\n\n\n\n\n\n\n\n노트\n\n\n\n앞의 코드에서 f(a)*f(b) &lt;= 0 || error(\"f(a)*f(b) should be negative\") 는 소위 단락 계산 (short-circit evaluation) 을 사용한 표현이다. 표현식 a && b 에서, 하위 표현식 b는 오직 a 가 true 일때만 실행된다. 반면 표현식 a || b 에서, 하위 표현식 b 는 오직 a 가 false 로 계산될 때만 계산을 받는다. 왜냐 하면, a 가 false 이면, b 의 값에 관계없이 a && b 는 무조건 false 가 되고, a 가 true 이면, b 의 값에 관계없이 a && b 는 무조건 true 가 되기 때문이다. 따라서 f(a)*f(b) 가 0 보다 큰 경우에만 에러를 발생시킨다. 이것은\nif f(a)*f(b) &lt;= 0\n    error(\"f(a)*f(b) )\n와 같은 표현이다.\n\n\n\n\n\n\n고정점 반복법 (Fixed Point Iteration)\n함수 \\(f(x)\\) 에 대해 \\(f(p)=p\\) 를 만족하는 점 \\(p\\) 를 \\(f\\) 의 고정점 (fixed point) 라 한다. 고정점 자체가 중요한 경우도 많으며, 방정식의 해를 찾는것과 밀접하게 연관되어 있다. \\(g(x) = f(x)-x\\) 라 놓으면 \\(f(x)\\) 의 고정점을 찾는 것은 \\(g(x)\\) 의 해를 찾는 문제와 같은 문제라는 것을 쉽게 이해 할 수 있을 것이다. 역으로, 함수 \\(g(x)=0\\) 의 해를 찾는 문제는 \\(f(x) = g(x) + x\\) 의 고정점을 찾는 문제와 동일한 문제이다.\n고정점 반복법이 가능한 이유는 아래의 고정점 정리 때문이다.\n\n정리 1 (고정점 정리) \\(f\\) 가 \\([a,\\,b]\\) 구간에서 연속이며 \\(f([a,\\,b])\\subset [a,\\,b]\\) 이면,\n  (\\(1\\)) \\(f(p)=p\\) 를 만족하는 고정점 \\(p\\) 가 \\([a,\\,b]\\) 구간에 존재한다.\n  (\\(2\\)) 모든 \\(x,\\,y \\in [a,\\,b]\\) 에 대해 \\(|f(x)-f(y) |\\le \\lambda |x-y|\\) 를 만족하는 \\(\\lambda\\in\\mathbb{R}\\) 이 존재하며, \\(0&lt;\\lambda&lt;1\\) 이면 고정점은 유일하다.\n  (\\(3\\)) (\\(2\\))의 조건을 만족시킬 때, 임의의 \\(p_1\\in [a,\\,b]\\) 와 \\(p_{n+1}=f(p_n)\\) 으로 정의되는 수열 \\(\\langle p_n\\rangle\\) 은 수렴한다.\n\n\n(증명). (\\(1\\)) \\(f(a)=a\\) 이거나 \\(f(b)=b\\) 이면 자명하므로 \\(f(a)\\ne a,\\, f(b) \\ne b\\) 인 경우만 생각한다. \\(g(x)=f(x)-x\\) 라 하면 가정에 의해 \\(g(a)\\ne 0,\\, g(b) \\ne 0\\) 이다. 모든 \\(x\\in [a,\\,b]\\) 에 대해 \\(a&lt;f(x)&lt;b\\) 이므로 \\(g(a)=f(a)-a&gt;0\\) 이며 \\(g(b)=f(b)-b&lt;0\\) 이다. \\(g(x)\\) 역시 \\([a,\\,b]\\) 에서 연속이므로 중간값정리에 의해 \\(g(p)=0\\) 인 \\(p\\in(a,\\,b)\\) 가 존재해야 한다. 즉 \\(f(p)=p\\) 를 만족하는 점 \\(p\\in [a,\\,b]\\) 가 존재한다.\n(\\(2\\)) 고정점이 두개 이상 존재한다고 가정하고 두개의 임의의 고정점을 \\(p,\\,q\\) 라 하자. 그렇다면, \\[\n|p-q | = |f(p)-f(q)| \\le \\lambda |p-q|&lt; |p-q|\n\\]\n이므로 모순이다. 따라서 고정점은 유일하다.\n(\\(3\\)) \\(p\\) 를 유일한 고정점이라고 하자.\n\\[\n|p-p_{n+1}| = |f(p) - f(p_n)| \\le \\lambda |p-p_n| \\le \\lambda^{n-1}|p-p_1|\n\\]\n이므로 \\(\\displaystyle \\lim_{n \\to \\infty} p_n = p\\) 이다. \\(\\square\\)\n\n\n\n따름정리 1 \\([a,\\,b]\\) 구간에서 미분가능한 함수 \\(f(x)\\) 가 \\(f([a,\\,b])\\subset [a,\\,b]\\) 이며, 어떤 양수 \\(0&lt;\\gamma&lt;1\\) 에 대해 \\(x\\in [a,\\,b] \\implies |f'(x)|&lt;\\gamma\\) 이면, \\([a,\\,b]\\) 구간에서 유일한 고정점을 가진다.\n\n\n(증명). 고정점 정리의 (\\(2\\)) 를 생각하자. \\([a,\\,b]\\) 구간에서 \\(f\\) 가 미분가능이므로 중간값 정리에 의해 \\(\\dfrac{f(x)-f(y)}{x-y}=f'(c)\\) 인 \\(c\\in [a,\\,b]\\) 가 존재하며, \\(|f'(x)|&lt;\\gamma&lt;1\\) 이므로 \\[\n|f(x)-f(y)|=|f'(c)||x-y|&lt;\\gamma |x-y|\n\\]\n이다. 따라서 \\(f(x)\\) 는 \\([a,\\,b]\\) 구간에서 유일한 고정점을 가진다. \\(\\square\\)\n\n\n\n보기 1 함수 \\(f(x) = x^2-2\\) 를 생각하자. \\(f(0)=-2\\) 이며 \\(f(2)=2\\) 이므로 \\([0,\\,2]\\) 구간에서 해가 반드시 존재한다.\n\n\n보기 2 이제 고정점 정리를 이용하여 \\(f(x)=x^3 − 2x^2 − 1 = 0\\) 의 해를 \\([1,\\,3]\\) 구간에서 구해보자. \\(g(x) = x-f(x)\\) 로 놓으면, \\(g(1) = 3,\\, g(3)=-5\\) 이므로 고정점 정리의 가정 \\(g([a,\\,b]) \\subset [a,\\,b]\\) 에 위배된다. \\(p\\) 가 \\(f(x)\\) 의 해이면 \\(p^3 = 2p^2+1\\) 이므로 \\(p\\) 는 \\(h(x) = (2x^2+1)^{1/3}\\) 의 해이다. \\(h(1) \\approx 1.442,\\, h(3) \\approx 2.668\\) 이므로 \\(h(x)\\) 는 고정점 정리의 제 1 조건을 만족한다. 또한\n\\[\nh'(x) = \\dfrac{4x}{3(2x^2+1)^{2/3}}\n\\]\n이며, \\(x\\in [1, 3]\\) 이므로 \\(x&gt;0\\) 이다. 따라서 \\([1,\\,3]\\) 구간에서,\n\\[\n|h'(x) | = \\dfrac{4|x|}{|3(2x^2+1)^{2/3}|} \\le \\dfrac{4|x|}{|3(2x^2+1)^{1/2}|} \\le \\dfrac{4|x|}{|3(2x^2)^{1/2}|}  &lt; \\dfrac{4}{3\\sqrt{2}} &lt;0.943&lt; 1\n\\]\n이므로 \\(h(x)\\) 는 \\([1,\\,3]\\) 구간에서 유일한 고정점을 가진다.\n\nfunction fixedpoint(f::Function, xi::T, xtol::T=1.0e-10, MaxIter::Int64 = 100_000)::T where T&lt;:AbstractFloat\n    Niter = 0\n    for i in 1:MaxIter\n        c = f(xi)\n        if abs(c-xi) &lt; xtol\n            return c\n        else\n            xi = c\n            Niter += 1\n        end\n    end\n    error(\"최대 반복 횟수 $MaxIter 에 도달하였으나 답을 찾지 못함.\")\nend\n\nh(x) = (2x^2+1)^(1/3)\nfixedpoint(h, 2.0)\n여기서 얻은 결과는 2.2055694302615003 이다.\n\n\n\n뉴턴 방법 (Newton-Method)\n\n\n\n뉴턴 방법\n\n\n함수 \\(f(x)\\) 가 미분가능하다고 하자. 그리고 \\((a,\\,b)\\) 구간에서 \\(f(x)=0\\) 의 해가 존재하며, 이 구간에서 도함수 \\(f'(x)\\) 가 \\(0\\) 보다 항상 크다고 하자. 해는 정확히 모르지만 대략 \\(p_0 \\in (a,\\,b)\\) 근처임을 안다고 하자. 테일러 정리에 의해 \\(f(x)\\) 는 \\(p_0\\) 근처에서 대략 \\[\nf(x) \\approx f(p_0) + f'(p_0)(x-p_0)\n\\]\n이다. 이제 \\(f_0 (x) = f(p_0) + f'(p_0)(x-p_0)\\) 라 놓고 \\(f_0(x) = 0\\) 의 해를 구하여 \\(p_1\\) 이라 하면,\n\\[\np_1 = p_0 - \\dfrac{f(p_0)}{f'(p_0)}\n\\]\n가 된다. 이제 \\(f(x)\\) 를 \\(p_1\\) 에서의 1차 다항식으로 전개한 \\(f_1(x)\\) 는\n\\[\nf_1(x) = f(p_1) + f'(p_1)(x-p_1)\n\\]\n이 되며 이 식의 해를 \\(p_2\\) 라 놓는다. 즉 \\(p_2 = p_1 - \\dfrac{f(p_1)}{f'(p_1)}\\) 이다. 이 과정을 반복하여 해를 얻는 방법을 뉴턴 방법(Newton method) 혹은 뉴턴-랩슨 방법(Newton-Raphson) method 라고 한다.\n\n앞서 배운 이분법과는 달리 뉴턴방법은 시작점이 해와 충분히 가깝지 않다면 해를 발견하지 못할 수도 있다. 뉴턴 방법 역시 조건이 만족할 때 까지 반복문을 수행하는데 이 반복이 끝나지 않을 수 있다.\n\n\n무한루프\n수치해석은 기본적으로 for ~ end 문이나 while ~ end 같은 반복문이 아주 많이 쓰인다. 이 가운데 while (condition) ~ end 구문은 조건이 참인지 아닌지 여부만을 따져 수행을 반복하기 때문에 잘못하면 수행이 끝나지 않을 수 있다. 예를 들어,\nv = 1\nwhile v&lt;10\n    v=v*1\nend\n같은 코드는 종료되지 않는다. 이분법의 경우는 상관 없지만 어떤 알고리즘을 루프로 구현할 경우, 다양한 원인으로 인해 무한루프에 빠질 수 있다. 프로그래밍에 익숙한 사용자라면 일정 시간이 흘러도 결과가 나오지 않으면 무한루프에 빠졌다는 것을 쉽게 알 수 있을 수도 있다. 그러나 함수값 하나 얻는 데 시간이 오래 결리는 경우는, 수행시간이 오래 지났더라도 이것이 정상적인 실행중인지, 무한루프에 빠졌는지 불확실할 경우도 있다. 그래서 이런 경우는 보통 최대 반복 횟수를 정해놓고 이 횟수에 도달하면 에러를 발생시키는 등으로 정상적인 결과를 얻지 못했다는 것을 알려 주는것이 좋다.\n\n\n\n뉴턴 방법의 구현\n\n\\(f(x)=0\\) 을 만족하는 해가 대략 \\(p_0\\) 근처임을 안다.\n\\(p_{n+1} = p_{n}- \\dfrac{f(p_{n})}{f'(p_{n})}\\) 을 계속 반복\n\n이를 구현한 코드는 아래와 같다. 앞서 언급했듯이 뉴턴 방법은 분할법과는 달리 항상 해를 발견하는 것을 보장하지 않는다. 따라서 무한 루프에 빠지는 것을 방지하기 위해 최대 반복 횟수(MaxIter) 를 함수의 인자로 입력한다. \\(p_n\\) 에서의 미분값이 \\(0\\) 일 경우 \\(p_{n+1}\\) 을 구할 수 없으며, \\(|f'(p_n)|\\) 이 매우 작을 경우 원하는 범위를 벗어나기 때문에 미분값의 절대값의 최소값을 지정하여 그 절대값보다 작을 경우는 에러를 발생시키도록 한다. 이분법의 경우는 구간을 좁혀가는 방법이기 때문에 구간의 범위를 허용범위로 정했지만 뉴턴 방법에서는 \\(|f(p_n)|\\) 값이 특정 값 \\(\\delta&gt;0\\) 보다 작을 때 \\(x_n\\) 을 근사적 해로 간주하며 \\(\\delta\\) 를 허용범위로 한다. 다음 함수에서는 이 허용범위를 etol 인자로 전달한다.\nfunction newton_method(f::Function, # 함수\n    df::Function,                   # 도함수\n    p::Real,                        # 시작값\n    MaxIter::Int64=100_000,         # 최대 반복 횟수\n    etol::Real = 1.0e-8,            # 해의 함수값의 허용 범위\n    dfmin::Real = 1.0e-6)           # 미분값의 절대값의 허용되는 최소값\n    \n    Niter = 0\n    for i in 1:MaxIter\n        if abs(f(p)) &lt; etol\n            break\n        elseif abs(df(p)) &lt; dfmin \n            error(\"df ≈ 0.0\")\n        end\n        p = p - f(p)/df(p)\n        Niter += 1       \n        \n        if abs(f(p)) &lt; etol \n            return (p, Niter)\n        end\n    end\n    error(\"최대 반복 횟수 $MaxIter 에 도달하였으나 답을 찾지 못함\")\nend\n\n\nf2(x) = x*(x-1.)*(x-2.)+5\ndf2(x) = 3*x^2-6*x+2\nnewton_method(f2, df2, 1.2)\n\\(f_2(x) = x(x-1)(x-2)+5\\) 에 대한 해를 구하였으며, 시작점 \\(x_i = 1.2\\) 로 부터 추산했을 때 그 결과는 다음과 같다.\n(-0.9041608591349207, 24)\n만약 \\(0.0\\) 부터시작한다면, 즉 newton_method(f2, df2, 0.0) 를 실행한다면,\n(-0.9041608591349207, 7)\n이 된다.\n\n\n\n뉴턴 방법의 단점과 수렴\nBisection method는 두 시작점에서의 함수값의 곱이 음수이면 무조건 하나의 해를 원하는 오차 내에서 찾을 수 있다. 그러나, Newton method 는 해를 찾을 수 없는 경우도 생기는데 가장 대표적인 경우는 위의 과정중에 어떤 \\(x_k\\) 에 에서 \\(f'(x_k)=0\\) 인 경우이다. 또한 시작점이 해와 충분히 가깝지 않을 경우 발산 할 수 있다. 우리는 뉴턴 방법을 통해 무조건 해를 갖는 조건을 보일 수 있다.\n\n정리 2 (뉴턴 방법의 수렴정리) \\(f\\in C^2_{[a,\\,b]}\\) 인 실함수 \\(f\\) 에 대해 \\(f(p)=0\\) 이며 \\(f'(p)\\ne 0\\) 이라 하자. 그렇다면 어떤 \\(\\delta&gt;0\\) 이 존재하여 \\(p_1\\in [p-\\delta,\\, p+\\delta]\\) 이라면 뉴턴 방법을 통해 얻은 수열 \\(\\langle p_n\\rangle\\) 은 \\(p\\) 로 수렴한다.\n\n\n(증명). 뉴턴 방법에 의해 \\(p_n\\) 이 정해졌을 때 \\(p_{n+1}\\) 은 직선 \\(f'(p_n) (x-p_n) + f(p_n) = 0\\) 의 해이다. 즉,\n\\[\np_{n+1}= p_n - \\dfrac{f(p_n)}{f'(p_{n})}\n\\]\n이다. \\(g(x) = x-\\dfrac{f(x)}{f'(x)}\\) 라 하자. \\(f(p)=0\\) 이므로 \\(g(p)=p\\) 이다. \\(f \\in C_2{[a,b]}\\) 이고 \\(p\\in p=(a,\\,b)\\) 이며 \\(f'(p) \\ne 0\\) 이므로 어떤 \\(p\\) 의 근방에 대해 미분값이 \\(0\\) 이 아니다. 즉 어떤 \\(\\delta_1&gt;0\\) 에 대해 \\(t\\in I_1=[p-\\delta_1,\\, p+\\delta_1]\\) 이면 \\(f'(t)\\ne 0\\) 이다. \\(g(x)\\) 는 \\(C^1_{I_1}\\) 이므로 도함수가 존재한다.\n\\[\ng'(x) = 1-\\dfrac{(f'(x))^2-f(x) f''(x)}{(f'(x))^2} = \\dfrac{f(x)f''(x)}{(f'(x))^2}\n\\]\n이며 \\(g'(p)= 0\\) 이다. \\(g\\) 의 도함수가 연속이며 \\(g'(p)=0\\) 이므로 어떤 \\(k\\in (0,\\,1)\\) 에 대해 \\(|g'(x)|\\le k\\) 인 구간 \\(I_2=[p-\\delta_2,\\, p+\\delta_2]\\) 가 존재한다. \\(\\delta = \\min(\\delta_1,\\delta_2)\\) 라 하면 구간 \\(I=[p-\\delta,p+\\delta]\\) 에 대해 \\(t\\in I\\) 이면 \\(|g'(t)|\\le k,\\, 0&lt;k&lt;1\\) 이며 \\(f'(t)\\ne 0\\) 이다.\n평균값 정리에 의해 \\(t\\in I\\) 이면 \\(g(t)-g(p) = g'(\\xi)(t-p)\\) 인 \\(\\xi\\in I\\) 가 존재한다. \\(0&lt;|g'(\\xi)|&lt;1\\) 이므로,\n\\[\n|g(t)-p| = |g(t)-g(p)| &lt; |g'(\\xi)||t-p| \\le k|t-p| &lt; |t-p|\n\\]\n\\(|t-p|&lt;\\delta\\) 이므로 \\(|g(t)-p|&lt;\\delta\\) 이다. 따라서 \\(g\\) 는 \\([p-\\delta,\\, p+\\delta]\\) 에서 \\([p-\\delta, p+\\delta]\\) 로의 함수이다. 고정점 정리(정리 1) 에 의해 \\(p_{n+1}=g(p_n)\\) 으로 정의된 수열은 \\(p\\) 로 수렴한다. \\(\\square\\)\n\n\n\n\n\n할선법 (Secant method)\n\n\n\n할선법\n\n\n뉴턴 방법에서는 함수 \\(f(x)\\) 뿐만 아니라 도함수 \\(f'(x)\\) 도 필요하다. 그러나 도함수 \\(f'(x)\\) 가 매우 복잡하거나 하여, 도함수를 직접적으로 인자로 주기 힘든 경우가 생길 수 있다. 이 때 시작점이 아닌 두 \\(x\\) 좌표 \\(p_0,\\,p_1\\) 을 함수의 인자로 주고, 도함수가 아닌 수치적으로 계산한 미분의 근사값 \\(\\dfrac{f(p_n)-f(p_{n-1})}{p_n -p_{n-1}}\\) 을 사용하는 것을 할선법이라 한다. 즉 주어진 \\(p_{n-1},\\, p_n\\) 에 대해 \\(p_{n+1}\\) 을 다음과 같이 얻는다.\n\\[\np_{n+1} = p_n - \\dfrac{f(p_n)}{g(p_n)} \\,\\qquad \\textrm{where } g(p_n)=\\dfrac{f(p_n)-f(p_{n-1})}{p_n -p_{n-1}}.\n\\]\nfunction secant(f::Function,    # 함수\n    p0::Real,                   # 시작값 1\n    p1::Real,                   # 시작값 2\n    MaxIter::Int64 = 100_000,   # 최대 반복 횟수\n    etol::Real = 1.0e-8,        # 해의 함수값의 허용 범위\n    dfmin::Real = 1.0e-6)       # 도함수의 근사값의 절대값에 허용되는 최소값\n    \n    Niter = 0\n    \n    for i in 1:MaxIter\n        gx = (f(p1)-f(p0))/(p1-p0)\n        if abs(f(p1)) &lt; etol \n            return p1, Niter\n        elseif abs(gx)&lt;dfmin\n            error(\"df ≈ 0.0\")\n        end\n        p0, p1 = p1, p1 - f(p1)/gx\n        Niter += 1\n    end\n    error(\"최대 반복 횟수 $MaxIter 에 도달하였으나 답을 찾지 못함.\")\nend\n이것에 대해 newton_method 와 비교해보았다.\nf2(x) = x*(x-1.)*(x-2.)+5\ndf2(x) = 3*x^2-6*x+2\nnewton_method(f2, df2, 0.0)\nsecant(f2, 0.0, 0.1)\n를 수행하면\n(-0.9041608591349207, 7)\n(-0.9041608591355101, 10)\n의 결과를 얻었다. 뉴턴 방법은 7회, 할선법은 10회의 반복으로 원하는 범위의 해를 얻었다.\n\n\n\nRegula Falci\n이분법과 할선법을 결합시킨 방법이다. 우선 구간 \\([a,\\,b]\\) 에서 연속인 함수 \\(f(x)\\) 의 해를 구하고자 하며 \\(f(a)\\cdot f(b)&lt;0\\) 이라 하자. 이분법에서는 \\(c=\\dfrac{a+b}{2}\\) 에서의 \\(f(c)\\) 값에 대해 \\(f(a)\\cdot f(c)&lt;0\\) 인지 여부에 따라 다음 구간이 이전 구간의 반으로 줄었다면 Regula false 에서는\n\\[\nc = b-f(b) \\cdot \\dfrac{b-a}{f(b)-f(a)}\n\\]\n에 대한 \\(f(c)\\) 를 생각한다. 이 방법은 도함수가 필요 없으며, 많은 경우 이분법보다 빨리 해를 찾는다는 장점이 있다.\nfunction regula_falci(f::Function,  # 함수\n    a::Real,                        # 구간값 1\n    b::Real,                        # 구간값 2\n    MaxIter::Int64 = 100_000,       # 최대 반복 회수\n    xtol::Real = 1.0e-8,            # 해의 오차의 허용 범위\n    etol::Real = 1.0e-8,            # 해의 함수값의 허용 범위\n    dfmin::Real = 1.0e-6)           # 도함수의 근사값의 절대값에 허용되는 최소값\n\n    a, b = minmax(a, b)\n    @assert f(a)*f(b) &lt; 0\n\n    Niter = 0\n\n    for i in 1:MaxIter\n        Niter +=1\n        gx =  (f(b)-f(a))/(b-a)\n        c = b-f(b)/gx\n        if (abs(b-a)&lt;xtol) || (abs(f(c))&lt;etol)\n            return c, Niter\n        elseif abs(gx) &lt; dfmin \n            error(\"df ≈ 0.0\")\n        end\n        \n        \n        if f(b)*f(c) &lt; 0 \n            a, b = b, c\n        else \n            a, b = a, c\n        end\n    end\n    error(\"최대 반복 횟수 $MaxIter 에 도달하였으나 답을 찾지 못함.\")\nend\n\n\n\n네가지 방법의 비교\n\\(f(x)=x-\\cos(x)\\) 에 대한 해를 구해보자. \\(f'(x) = 1+\\sin(x)\\) 이므로 \\(f(x)\\) 는 단조증가함수이다. \\(f(0)=-1&lt;0\\) 이며 \\(f(\\pi/2) = \\pi/2&gt;0\\) 이므로 우리는 \\((0,\\, \\pi/2)\\) 구간에서 단 하나의 해가 존재한다는 것을 알 수 있다. 우리는 앞서 네가지 방법에서 해를 발견할 경우 해와 반복 수행 햇수를 반환하도록 코딩하였다.\nf(x) = x-cos(x)\ndf(x) = 1+sin(x)\nprintln(bisection(f, 0, π/2))\nprintln(newton_method(f, df, 0.0))\nprintln(secant(f, 0, π/2))\nprintln(regula_falci(f, 0, π/2))\n그 결과는 다음과 같다.\n(0.7390851321023699, 27)\n(0.739085133385284, 4)\n(0.739085133034638, 5)\n(0.7390851292482057, 9)\n이분법이 가장 많은 반복을 수행하였으며 뉴턴법이 가장 적은 반복을 수행했다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_finding_root.html#오차-해석",
    "href": "src/numerical_analysis_using_julia/06_finding_root.html#오차-해석",
    "title": "일변수 방정식의 해",
    "section": "2 오차 해석",
    "text": "2 오차 해석\n\n수학적 기초\n\n정의 1 (수렴 속도 (order of convergence)) 수열 \\(\\langle p_n \\rangle\\) 이 \\(p\\) 로 수렴하며, 모든 \\(n\\) 에 대해 \\(p_n \\ne p_0\\) 라고 하자. 이 때\n\\[\n\\lim_{n \\to \\infty} \\dfrac{| p_{n+1}-p|}{|p_n-p|^\\alpha} = \\mu\n\\]\n를 만족하는 양수 \\(\\mu\\) 와 \\(\\alpha\\ge 1\\) 가 존재한다면 \\(\\alpha\\) 를 수열 \\(\\langle p_n \\rangle\\) 의 수렴 속도 라고 하고 \\(\\mu\\) 를 근사적 오차 상수(asymptotic error constant) 라고 한다. 특히 \\(\\alpha=1\\) 인 수열은 \\(\\mu&lt;1\\) 일 때에만 수렴하며 이 경우 선형 수렴 수열 이라고 한다. \\(\\alpha=2\\) 인 수열은 이차 수렴 수열 이라고 한다.\n\n\n\n정리 3 실함수 \\(g\\in C[a,\\,b]\\) 가 \\(g([a,\\,b]) \\subset [a,\\, b]\\) 라 하자. 정리 1 에 의해 고정점 \\(p\\in [a,\\,b]\\) 가 존재한다. 또한 어떤 양수 \\(\\lambda &lt;1\\) 가 존재하여 모든 \\(x\\in (a,\\,b)\\) 에 대해 \\(|g'(x)|&lt;\\lambda\\) 라 하자. \\(g'(p)\\ne 0\\) 라면 \\(p_0 \\ne p\\) 에 대해 수열 \\(\\langle p_n \\rangle\\) 을\n\\[\np_{n+1} = g(p_{n}),\\qquad n=0,\\,1,\\,2,\\ldots\n\\]\n로 정의하자. 이 때 이 수열은 \\([a,\\,b]\\) 의 고정점 \\(p\\) 로 수렴하는 선형 수렴 수열이다.\n\n\n(증명). 평균값 정리에 의해 각각의 \\(n=1,\\,2,\\ldots\\) 에 대해\n\\[\n\\dfrac{p_{n+1}-p}{p_{n}-p} = \\dfrac{g(p_n)-g(p)}{p_n-p} \\le g'(\\xi_n)\n\\]\n를 만족하는 \\(\\xi_n\\) 이 \\(p_n\\) 과 \\(p\\) 사이에 존재한다. 즉 \\(|p_{n+1}-p| \\le |g'(\\xi_n)(p_n-p)|\\) 이다. \\(\\langle p_n \\rangle\\) 이 \\(p\\) 로 수렴하므로 \\(\\langle \\xi_n\\rangle\\) 도 \\(p\\) 로 수렴한다. \\(g'\\) 이 \\((a,\\,b)\\) 구간에서 연속이므로,\n\\[\n\\lim_{n \\to \\infty} g'(\\xi_n) = g'(p) \\ne 0\n\\]\n이며, 따라서,\n\\[\n\\lim_{n \\to \\infty} \\dfrac{|p_{n+1}-p|}{|p_n-p|} = |g'(p)|\n\\]\n이다. \\(g'(p)\\ne 0\\) 이므로 \\(\\langle p_n \\rangle\\) 은 선형 수렴 수열이다. \\(\\square\\)"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html",
    "href": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html",
    "title": "반복법을 이용한 선형 시스템의 해를 구하기",
    "section": "",
    "text": "정의 1 (대각 지배 행렬 (Diagonally dominant matrix)) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 의 각 행의 대각성분의 절대값이 그 행의 대각성분을 제외한 성분의 절대값의 합보다 크면, 즉 각각의 \\(i=1,\\ldots,\\,n\\) 행에 대해\n\\[\n|A_{ii}| \\ge \\sum_{j=1,\\, j\\ne i}^n |A_{ij}|, \\qquad i=1,\\ldots,\\,n\n\\]\n이면 이 행렬 \\(\\boldsymbol{A}\\) 를 행에 대한 대각 지배 행렬이라 한다. 또한 각 열에대해\n\\[\n|A_{ii}| \\ge \\sum_{j=1,\\, j\\ne i}^n |A_{ji}|, \\qquad i=1,\\ldots,\\,n\n\\]\n이면 이 행렬 \\(\\boldsymbol{A}\\) 를 열에 대한 대각 지배 행렬이라 한다. 행/열 에 대한 대각 지배 행렬의 조건에서 등호 조건을 제외하고 성립하면 행/열 에 대한 엄격한 대각 지배 행렬 이라 한다.\n\n\n\n\n\n\n명제 1 엄격한 대각 지배 행렬은 가역행렬이다.\n\n\n(증명). 행에 대해 엄격한 대각 지배 행렬 \\(\\boldsymbol{A}\\) 이 가역행렬이면, \\(\\boldsymbol{A}^T\\) 는 열에 대해 엄격한 대각 지배 행렬이며 가역행렬이다. 따라서 행에 대해 엄격한 대각 지배 행렬이 가역행렬임을 보이면 된다.\n\\(\\boldsymbol{A}\\in \\mathbb{F}^{n \\times n}\\) 이 행에 대한 엄격한 대각 지배 행렬이며 가역행렬이 아니라고 하자. \\(\\boldsymbol{Ax}=\\boldsymbol{0}\\) 을 만족하는 \\(\\boldsymbol{x}\\ne \\boldsymbol{0}\\) 이 존재한다. 이 \\(\\boldsymbol{x}\\) 가운데 그 절대값이 가장 큰 \\(|x_k|\\ne 0\\) 을 찾을 수 있다. \\(\\boldsymbol{Ax}=0\\) 이므로, 각각의 \\(i=1,\\ldots,\\,n\\) 에 대해\n\\[\n\\sum_{j=1}^n A_{ij}x_j=0\n\\]\n이며, 따라서 \\(x_k\\) 의 \\(k\\) 에 대해\n\\[\nA_{kk}x_k = -\\sum_{j=1,\\,j \\ne k}^n A_{kj}x_j\n\\]\n이다. \\(\\boldsymbol{A}\\) 가 행에 대해 엄격한 대각 지배 행렬이므로 모든 대각성분은 \\(0\\) 이 아니다. 삼각부등식에 의해,\n\\[\n|A_{kk}| |x_k|  \\le \\sum_{j=1,\\,j\\ne k}^n |A_{kj}| |x_j|\n\\]\n이므로,\n\\[\n|A_k| \\le \\sum_{j= 1,\\, j \\ne k}^n \\dfrac{|x_j|}{|x_k|} |A_{kj}| &lt; \\sum_{j= 1,\\, j \\ne k}^n |A_{kj}|\n\\]\n이므로 \\(\\boldsymbol{A}\\) 가 행에 대해 엄격한 대각 지배 행렬이라는 가정에 위배된다. 따라서 \\(\\boldsymbol{A}\\) 는 가역행렬이다. \\(\\square\\)\n\n\n\n명제 2 행에 대해 엄격한 대각 지배 행렬은 피보팅 없이 가우스-요르단 소거법을 수행 할 수 있다.\n\n\n(증명). \\(\\boldsymbol{A}\\in\\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 이 행에 대해 엄격한 대각 지배 행렬일 때 induction 으로 증명한다. 우선 \\(n=1\\) 일 경우는 자명하다. \\(n\\) 에 대해 명제가 성립함을 가정하자. 가우스-요르단 소거법을 첫번째 행을 가준으로 하여 피보팅 없이 두번째 행부터 \\(n+1\\) 번째 행까지 첫번째 열을 소거한 행렬을 \\(\\boldsymbol{A}'\\) 이라 하면 \\[\nA'_{ij} = A_{ij}- \\dfrac{A_{i1}}{A_{11}}A_{1j},\\qquad i=2,\\ldots,\\,n+1 \\tag{1}\n\\]\n이다.\n\\[\n\\begin{aligned}\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &= \\sum_{j=2,\\, j \\ne i} \\left|A_{ij}- \\dfrac{A_{i1}}{A_{11}}A_{1j}\\right| \\le \\sum_{j=2,\\, j \\ne i}^n |A_{ij}| + \\sum_{j=2,\\,j \\ne i} \\left|\\dfrac{A_{i1}}{A_{11}}A_{1j}\\right|\n\\end{aligned}\\tag{2}\n\\]\n인데,\n\\[\n\\begin{aligned}\n\\sum_{j=2,\\, j \\ne i}^n |A_{ij}| &lt; |A_{ii}| - |A_{i1}|,\\\\\n\\sum_{j=2,\\, j \\ne i}^n |A_{1j}| &lt; |A_{11}| - |A_{1i}|\n\\end{aligned} \\tag{3}\n\\]\n이므로, \\((2)\\) 과 \\((3)\\) 를 보면 \\[\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &lt; |A_{ii}|-|A_{i1}| + \\dfrac{|A_{i1}|}{|A_{11}|} \\left(|A_{11}| - |A_{1i}|\\right) = |A_{ii}| - \\dfrac{|A_{i1}|}{|A_{11}|} |A_{1i}| \\tag{4}\n\\]\n이다. \\(1\\) 로 부터,\n\\[\n|A'_{ii}| = \\left|A_{ii}- \\dfrac{A_{i1}}{A_{11}}A_{1i}\\right| \\ge \\left|A_{ii}\\right|- \\left|\\dfrac{A_{i1}}{A_{11}}A_{1i}\\right| \\tag{5}\n\\]\n이므로, \\((4)\\) 와 \\((5)\\) 를 결합하면,\n\\[\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &lt; |A'_{ii}|\n\\]\n이다. 즉 2행 2열부터 \\(n+1\\) 행 \\(n+1\\) 열까지의 \\(\\boldsymbol{A}'\\) 의 부분행렬은 행에 대해 엄격한 지배행렬이므로 가정에 의해 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. 따라서 임의의 크기의 정사각 행렬이 행에 대해 엄격한 대각 지배 행렬일 때, 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n정의 2 (Positive definite 행렬) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 이 대칭행렬이며 모든 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{R})\\), \\(\\boldsymbol{x}\\ne \\boldsymbol{0}\\) 에 대해 \\(\\langle \\boldsymbol{Ax},\\boldsymbol{x}\\rangle &gt; 0\\) 일 경우 \\(\\boldsymbol{A}\\) 를 positive definite 라 한다.\n\n\n\n\n\nPositive definite 행렬은 복소수체에서 정의할 수도 있으나 여기서는 실수체에서 정의된 행렬만 생각하기로 한다. 다음 명제는 대부분의 선형대수학 교재에서 다루기 때문에 증명 없이 사용하기로 하자. 우선 실수체에서 정의된 대칭행렬의 중요한 성질에 대해 알아보자.\n\n정리 1 (실수체(\\(\\mathbb{R}\\)) 에서 정의된 행렬의 스펙트럼 정리) \\(\\boldsymbol{A} \\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 행렬에 대해 다음 세 명제는 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 는 대칭행렬이다.\n  (\\(2\\)) \\(\\boldsymbol{A}\\) 는 직교변환에 의해 대각행렬로 표현된다.\n  (\\(3\\)) \\(\\boldsymbol{A}\\) 의 고유벡터로 정규직교기저를 구성 할 수 있다.\n\n\n즉 모든 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{R})\\) 은 \\(\\boldsymbol{A}\\) 의 고유벡터의 선형결합으로 표현 할 수 있다. 이제 positive definite 행렬에 대한 성질을 알아보자.\n\n\n명제 3 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 이 positive definite 일 경우 다음이 성립한다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 의 모든 고유값은 양수이다.\n  (\\(2\\)) \\(\\det (\\boldsymbol{A}) &gt;0\\) 이다.\n  (\\(3\\)) \\(\\boldsymbol{A}\\) 는 가역행렬이다.\n  (\\(4\\)) \\(\\boldsymbol{A}\\) 의 대각성분은 모두 양수이다.\n  (\\(5\\)) \\(|A_{ij}| \\le \\max \\{|A_{ii}| : i=1,\\ldots,\\,n\\}\\).\n  (\\(6\\)) \\((A_{ij})^2 &lt; A_{ii}A_{jj}\\).\n\n\n(증명). (\\(1\\)) \\(\\lambda\\) 가 \\(\\boldsymbol{A}\\) 의 고유값이며 \\(\\boldsymbol{v}\\) 가 \\(\\lambda\\) 에 대한 고유벡터일 경우 \\(\\lambda = \\langle \\boldsymbol{Av}, \\boldsymbol{v}\\rangle &gt;0\\) 이어야 한다.\n(\\(2\\)) 대칭행렬 \\(\\boldsymbol{A}\\) 의 행렬식은 모든 고유값의 곱이므로 양수이다.\n(\\(3\\)) \\(\\boldsymbol{x}\\ne 0\\) 이며 \\(\\boldsymbol{Ax}=\\boldsymbol{0}\\) 일 경우 \\(\\langle \\boldsymbol{Ax}, \\boldsymbol{x}\\rangle = 0\\) 인데 이는 \\(\\boldsymbol{A}\\) 가 positive definite 가 아니라는 의미이다.\n(\\(4\\)) \\(A_{ii} = \\langle \\boldsymbol{Ae}_i,\\, \\boldsymbol{e}_i\\rangle &gt; 0\\)\n(\\(5\\)) \\(i\\ne j\\) 에 대해\n\\[\n\\begin{aligned}\n0&lt; \\langle \\boldsymbol{A}(\\boldsymbol{e}_i-\\boldsymbol{e}_j), (\\boldsymbol{e}_i-\\boldsymbol{e}_j)\\rangle = A_{ii}+ A_{ij} - 2 A_{ij} \\\\\n0&lt; \\langle \\boldsymbol{A}(\\boldsymbol{e}_i+\\boldsymbol{e}_j), (\\boldsymbol{e}_i+\\boldsymbol{e}_j)\\rangle = A_{ii}+ A_{ij} + 2 A_{ij} \\\\\n\\end{aligned}\n\\]\n이므로 \\[\n|A_{ij}| &lt; \\dfrac{A_{ii}+A_{jj}}{2} \\le \\max \\{|A_{ii}| : i=1,\\ldots,\\,n\\}\n\\]\n이다.\n(\\(6\\)) \\(i\\ne j\\) 와 임의의 실수 \\(t\\) 에 대해\n\\[\n0 &lt; \\langle \\boldsymbol{A}(t\\boldsymbol{e}_i + \\boldsymbol{e}_j),\\, (t\\boldsymbol{e}_i + \\boldsymbol{e}_j)\\rangle = t^2A_{ii} +2tA_{ij}+ A_{jj}\n\\]\n이므로 \\((A_{ij})^2 &lt; A_{ii}A_{jj}\\) 이다. \\(\\square\\)\n\n\n\n\n\n\n\n\n\n정의 3 (부분 행렬(submatrix) 와 선행 주 부분 행렬(leading principal submatrix)) 행렬 \\(\\boldsymbol{A}\\in \\mathbb{F}^{m \\times n}\\) 에 대해 임의의 중복되지 않은 행 \\(I=\\{i_1,\\ldots,\\,i_p: 1\\le i_k\\le m\\}\\) 과 중복되지 않은 열 \\(J=\\{j_1,\\ldots,\\,j_q: 1 \\le j_l \\le n \\}\\) 을 모아 만든 행렬을 \\(\\boldsymbol{A}\\) 의 부분 행렬이라고 하고 \\(\\boldsymbol{A}[I, J]\\) 라고 쓴다. \\(I=1,\\ldots,\\,k\\), \\(J=1,\\ldots,\\,k\\) 일 때 \\(\\boldsymbol{A}[I, J]\\) 를 선행 주 부분 행렬 이라고 하고 \\(\\boldsymbol{A}_k\\) 라고 쓴다.\n\n\n\n\n\n이제 \\(\\boldsymbol{A}\\) 가 positive definite 인 것과 \\(\\boldsymbol{A}\\) 의 모든 선행 주 부분행렬의 행렬식이 \\(0\\) 보다 큰 것이 동치임을 보이고자 한다. 이를 위해 몇가지 미리 보여야 할 것이 있다.\n\n보조정리 1 \\(\\boldsymbol{A}\\in \\mathbb{R}^{n \\times n}\\) 이 대칭행렬이고 \\(\\boldsymbol{Q} \\in \\mathbb{R}^{n \\times n}\\) 이 가역행렬 일 때 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 가 positive definite 이고 \\(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 가 대칭행렬이다.\n  (\\(2\\)) \\(\\boldsymbol{Q}^T \\boldsymbol{AQ}\\) 가 positive definte 이다.\n\n\n(증명). (\\(1 \\implies 2\\)) 임의의 \\(\\boldsymbol{0}\\) 벡터가 아닌 \\(\\boldsymbol{v}\\in \\mathbb{R}^{n}\\) 에 대해 \\(\\boldsymbol{Qv}\\ne \\boldsymbol{0}\\) 이다. \\(\\boldsymbol{A}\\) 가 positive definite 이므로,\n\\[\n0 &lt; (\\boldsymbol{Qv})^T \\boldsymbol(A)(\\boldsymbol{Qv}) = \\boldsymbol{v} \\left(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\right)\\boldsymbol{z}\n\\]\n이므로 \\(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 는 positive definite 이다.\n(\\(2 \\implies 1\\)) \\(\\boldsymbol{A}\\) 가 대칭행렬이므로 \\((\\boldsymbol{Q}^T\\boldsymbol{AQ})^T = \\boldsymbol{Q}^T \\boldsymbol{A}^T\\boldsymbol{Q} = \\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 이다. 즉 \\(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 는 대칭행렬이다. \\(\\boldsymbol{Q}\\) 가 가역이므로 임의의 \\(\\boldsymbol{x}\\in \\mathbb{R}^{n}\\) 에 대해 \\(\\boldsymbol{x}=\\boldsymbol{Qy}\\) 를 만족하는 \\(\\boldsymbol{y}\\in \\mathbb{R}^n\\) 이 존재한다.\n\\[\n\\boldsymbol{x}^T\\boldsymbol{Ax} =  (\\boldsymbol{Qy})^T \\boldsymbol{A}\\boldsymbol{Qy} = \\boldsymbol{y}^T\\boldsymbol{Q}^T\\boldsymbol{AQ}\\boldsymbol{y} &gt; 0\n\\]\n이므로 \\(\\boldsymbol{A}\\) 는 positive defnite 이다. \\(\\square\\)\n\n\n\n명제 4 대칭행렬 \\(\\boldsymbol{A}\\) 가 positive definite 일 필요충분조건은 \\(\\boldsymbol{A}\\) 의 모든 선행 주 부분 행렬의 행렬식이 양수인 것이다.\n\n\n(증명). Inductinon 을 통해 증명한다. \\(1 \\times 1\\) 행렬의 경우는 trivial 하다. 이제 \\(n\\times n\\) 행렬에 대해 성립한다고 가정한다. \\(\\boldsymbol{A}\\) 가 \\((n+1)\\times (n+1)\\) 행렬이라 하자.Carl P.Simon & Lawrence E. Blume 의 Mathematics for Economists 의 증명이다\n우선 모든 \\(\\boldsymbol{A}_i\\), \\(i=1,\\ldots,\\,n\\) 의 행렬식이 양수이면 \\(\\boldsymbol{A}\\) 가 positive definite 임을 보이자. 우선 \\(\\boldsymbol{A}\\) 를 \\(\\boldsymbol{A}_n\\) 에 대하여 아래와 같이 분할하여 보자.\n\\[\n\\boldsymbol{A} = \\left[\\begin{array}{c|c} \\boldsymbol{A}_n & \\boldsymbol{a} \\\\ \\hline \\boldsymbol{a}^T & a\\end{array}\\right]\n\\]\n여기서 \\(\\boldsymbol{a}=\\begin{bmatrix} A_{1, n+1} & \\cdots & A_{n, n+1}\\end{bmatrix}^T\\) 이고 \\(a=A_{n+1, n+1}\\) 이다. 그렇다면,\n\\[\n\\boldsymbol{A} = \\left[\\begin{array}{c|c} \\boldsymbol{I}_n & \\boldsymbol{0} \\\\ \\hline (\\boldsymbol{A}_n^{-1}\\boldsymbol{a})^T & 1\\end{array}\\right] \\left[\\begin{array}{c|c} \\boldsymbol{A}_n & \\boldsymbol{0}_n \\\\ \\hline (\\boldsymbol{0}_n)^T & d\\end{array}\\right] \\left[\\begin{array}{c|c} \\boldsymbol{I}_n & \\boldsymbol{A}_n^{-1}\\boldsymbol{a} \\\\ \\hline \\boldsymbol{0}_n^T & 1\\end{array}\\right] = \\boldsymbol{Q}^T\\boldsymbol{BQ}\n\\]\n이며 이 때 \\(d=a-\\boldsymbol{a}^T(\\boldsymbol{A}_n)^{-1}\\boldsymbol{a}\\) 이다. 또한 \\(\\boldsymbol{A}_n\\) 이 대칭행렬이므로 \\(\\boldsymbol{A}_n^{-1}\\) 도 대칭행렬이다. (즉 \\((\\boldsymbol{A}_n^{-1})^{T} = \\boldsymbol{A}_n^{-1}\\) 이다.)\n우리는 \\(\\det (\\boldsymbol{Q}^T) = \\det (\\boldsymbol{Q})=1\\) 이며 \\(\\det (\\boldsymbol{B})=d \\cdot \\det (\\boldsymbol{A}_n)\\) 임을 안다. 즉\n\\[\n\\det (\\boldsymbol{A}) =  d \\cdot \\det (\\boldsymbol{A}_n)\n\\]\n이다. \\(\\boldsymbol{A}\\) 가 positive definite 이며 \\(\\det (\\boldsymbol{A})&gt;0\\) 이므로 \\(d&gt;0\\) 이다.\n이제 임의의 \\(\\boldsymbol{x}\\in \\mathbb{R}^{n+1}\\) 을 생각하자. \\(\\boldsymbol{x} = \\begin{bmatrix} \\boldsymbol{x}_0 & x \\end{bmatrix}^T\\), \\(\\boldsymbol{x}_0 \\in \\mathbb{R}^n\\) 이라 하면,\n\\[\n\\boldsymbol{x}^T \\boldsymbol{Bx} = \\boldsymbol{x}^T \\boldsymbol{A}_n \\boldsymbol{x} + d\\cdot x\n\\]\n이다. \\(\\boldsymbol{A}_n\\) 이 가정에 의해 positive definite 이며, \\(d&gt;0\\) 이므로 \\(\\boldsymbol{x}^T\\boldsymbol{Bx}&gt;0\\) 이다. 따라서 보조정리 1 에 의해 \\(\\boldsymbol{B}=\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 일 때 \\(\\boldsymbol{A}\\) 는 positive definite 이다. \\(\\square\\)\n\n\n\n명제 5 대칭행렬 \\(\\boldsymbol{A}\\) 에 대해 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 는 positive definite 하다.\n  (\\(2\\)) \\(\\boldsymbol{A}\\) 는 피보팅 없이 가우스-요르단 소거법을 수행 할 수 있으며, 피봇 성분은 양수이다.\n\n\n(증명)."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html#특별한-선형-시스템",
    "href": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html#특별한-선형-시스템",
    "title": "반복법을 이용한 선형 시스템의 해를 구하기",
    "section": "",
    "text": "정의 1 (대각 지배 행렬 (Diagonally dominant matrix)) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 의 각 행의 대각성분의 절대값이 그 행의 대각성분을 제외한 성분의 절대값의 합보다 크면, 즉 각각의 \\(i=1,\\ldots,\\,n\\) 행에 대해\n\\[\n|A_{ii}| \\ge \\sum_{j=1,\\, j\\ne i}^n |A_{ij}|, \\qquad i=1,\\ldots,\\,n\n\\]\n이면 이 행렬 \\(\\boldsymbol{A}\\) 를 행에 대한 대각 지배 행렬이라 한다. 또한 각 열에대해\n\\[\n|A_{ii}| \\ge \\sum_{j=1,\\, j\\ne i}^n |A_{ji}|, \\qquad i=1,\\ldots,\\,n\n\\]\n이면 이 행렬 \\(\\boldsymbol{A}\\) 를 열에 대한 대각 지배 행렬이라 한다. 행/열 에 대한 대각 지배 행렬의 조건에서 등호 조건을 제외하고 성립하면 행/열 에 대한 엄격한 대각 지배 행렬 이라 한다.\n\n\n\n\n\n\n명제 1 엄격한 대각 지배 행렬은 가역행렬이다.\n\n\n(증명). 행에 대해 엄격한 대각 지배 행렬 \\(\\boldsymbol{A}\\) 이 가역행렬이면, \\(\\boldsymbol{A}^T\\) 는 열에 대해 엄격한 대각 지배 행렬이며 가역행렬이다. 따라서 행에 대해 엄격한 대각 지배 행렬이 가역행렬임을 보이면 된다.\n\\(\\boldsymbol{A}\\in \\mathbb{F}^{n \\times n}\\) 이 행에 대한 엄격한 대각 지배 행렬이며 가역행렬이 아니라고 하자. \\(\\boldsymbol{Ax}=\\boldsymbol{0}\\) 을 만족하는 \\(\\boldsymbol{x}\\ne \\boldsymbol{0}\\) 이 존재한다. 이 \\(\\boldsymbol{x}\\) 가운데 그 절대값이 가장 큰 \\(|x_k|\\ne 0\\) 을 찾을 수 있다. \\(\\boldsymbol{Ax}=0\\) 이므로, 각각의 \\(i=1,\\ldots,\\,n\\) 에 대해\n\\[\n\\sum_{j=1}^n A_{ij}x_j=0\n\\]\n이며, 따라서 \\(x_k\\) 의 \\(k\\) 에 대해\n\\[\nA_{kk}x_k = -\\sum_{j=1,\\,j \\ne k}^n A_{kj}x_j\n\\]\n이다. \\(\\boldsymbol{A}\\) 가 행에 대해 엄격한 대각 지배 행렬이므로 모든 대각성분은 \\(0\\) 이 아니다. 삼각부등식에 의해,\n\\[\n|A_{kk}| |x_k|  \\le \\sum_{j=1,\\,j\\ne k}^n |A_{kj}| |x_j|\n\\]\n이므로,\n\\[\n|A_k| \\le \\sum_{j= 1,\\, j \\ne k}^n \\dfrac{|x_j|}{|x_k|} |A_{kj}| &lt; \\sum_{j= 1,\\, j \\ne k}^n |A_{kj}|\n\\]\n이므로 \\(\\boldsymbol{A}\\) 가 행에 대해 엄격한 대각 지배 행렬이라는 가정에 위배된다. 따라서 \\(\\boldsymbol{A}\\) 는 가역행렬이다. \\(\\square\\)\n\n\n\n명제 2 행에 대해 엄격한 대각 지배 행렬은 피보팅 없이 가우스-요르단 소거법을 수행 할 수 있다.\n\n\n(증명). \\(\\boldsymbol{A}\\in\\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 이 행에 대해 엄격한 대각 지배 행렬일 때 induction 으로 증명한다. 우선 \\(n=1\\) 일 경우는 자명하다. \\(n\\) 에 대해 명제가 성립함을 가정하자. 가우스-요르단 소거법을 첫번째 행을 가준으로 하여 피보팅 없이 두번째 행부터 \\(n+1\\) 번째 행까지 첫번째 열을 소거한 행렬을 \\(\\boldsymbol{A}'\\) 이라 하면 \\[\nA'_{ij} = A_{ij}- \\dfrac{A_{i1}}{A_{11}}A_{1j},\\qquad i=2,\\ldots,\\,n+1 \\tag{1}\n\\]\n이다.\n\\[\n\\begin{aligned}\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &= \\sum_{j=2,\\, j \\ne i} \\left|A_{ij}- \\dfrac{A_{i1}}{A_{11}}A_{1j}\\right| \\le \\sum_{j=2,\\, j \\ne i}^n |A_{ij}| + \\sum_{j=2,\\,j \\ne i} \\left|\\dfrac{A_{i1}}{A_{11}}A_{1j}\\right|\n\\end{aligned}\\tag{2}\n\\]\n인데,\n\\[\n\\begin{aligned}\n\\sum_{j=2,\\, j \\ne i}^n |A_{ij}| &lt; |A_{ii}| - |A_{i1}|,\\\\\n\\sum_{j=2,\\, j \\ne i}^n |A_{1j}| &lt; |A_{11}| - |A_{1i}|\n\\end{aligned} \\tag{3}\n\\]\n이므로, \\((2)\\) 과 \\((3)\\) 를 보면 \\[\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &lt; |A_{ii}|-|A_{i1}| + \\dfrac{|A_{i1}|}{|A_{11}|} \\left(|A_{11}| - |A_{1i}|\\right) = |A_{ii}| - \\dfrac{|A_{i1}|}{|A_{11}|} |A_{1i}| \\tag{4}\n\\]\n이다. \\(1\\) 로 부터,\n\\[\n|A'_{ii}| = \\left|A_{ii}- \\dfrac{A_{i1}}{A_{11}}A_{1i}\\right| \\ge \\left|A_{ii}\\right|- \\left|\\dfrac{A_{i1}}{A_{11}}A_{1i}\\right| \\tag{5}\n\\]\n이므로, \\((4)\\) 와 \\((5)\\) 를 결합하면,\n\\[\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &lt; |A'_{ii}|\n\\]\n이다. 즉 2행 2열부터 \\(n+1\\) 행 \\(n+1\\) 열까지의 \\(\\boldsymbol{A}'\\) 의 부분행렬은 행에 대해 엄격한 지배행렬이므로 가정에 의해 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. 따라서 임의의 크기의 정사각 행렬이 행에 대해 엄격한 대각 지배 행렬일 때, 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n정의 2 (Positive definite 행렬) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 이 대칭행렬이며 모든 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{R})\\), \\(\\boldsymbol{x}\\ne \\boldsymbol{0}\\) 에 대해 \\(\\langle \\boldsymbol{Ax},\\boldsymbol{x}\\rangle &gt; 0\\) 일 경우 \\(\\boldsymbol{A}\\) 를 positive definite 라 한다.\n\n\n\n\n\nPositive definite 행렬은 복소수체에서 정의할 수도 있으나 여기서는 실수체에서 정의된 행렬만 생각하기로 한다. 다음 명제는 대부분의 선형대수학 교재에서 다루기 때문에 증명 없이 사용하기로 하자. 우선 실수체에서 정의된 대칭행렬의 중요한 성질에 대해 알아보자.\n\n정리 1 (실수체(\\(\\mathbb{R}\\)) 에서 정의된 행렬의 스펙트럼 정리) \\(\\boldsymbol{A} \\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 행렬에 대해 다음 세 명제는 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 는 대칭행렬이다.\n  (\\(2\\)) \\(\\boldsymbol{A}\\) 는 직교변환에 의해 대각행렬로 표현된다.\n  (\\(3\\)) \\(\\boldsymbol{A}\\) 의 고유벡터로 정규직교기저를 구성 할 수 있다.\n\n\n즉 모든 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{R})\\) 은 \\(\\boldsymbol{A}\\) 의 고유벡터의 선형결합으로 표현 할 수 있다. 이제 positive definite 행렬에 대한 성질을 알아보자.\n\n\n명제 3 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 이 positive definite 일 경우 다음이 성립한다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 의 모든 고유값은 양수이다.\n  (\\(2\\)) \\(\\det (\\boldsymbol{A}) &gt;0\\) 이다.\n  (\\(3\\)) \\(\\boldsymbol{A}\\) 는 가역행렬이다.\n  (\\(4\\)) \\(\\boldsymbol{A}\\) 의 대각성분은 모두 양수이다.\n  (\\(5\\)) \\(|A_{ij}| \\le \\max \\{|A_{ii}| : i=1,\\ldots,\\,n\\}\\).\n  (\\(6\\)) \\((A_{ij})^2 &lt; A_{ii}A_{jj}\\).\n\n\n(증명). (\\(1\\)) \\(\\lambda\\) 가 \\(\\boldsymbol{A}\\) 의 고유값이며 \\(\\boldsymbol{v}\\) 가 \\(\\lambda\\) 에 대한 고유벡터일 경우 \\(\\lambda = \\langle \\boldsymbol{Av}, \\boldsymbol{v}\\rangle &gt;0\\) 이어야 한다.\n(\\(2\\)) 대칭행렬 \\(\\boldsymbol{A}\\) 의 행렬식은 모든 고유값의 곱이므로 양수이다.\n(\\(3\\)) \\(\\boldsymbol{x}\\ne 0\\) 이며 \\(\\boldsymbol{Ax}=\\boldsymbol{0}\\) 일 경우 \\(\\langle \\boldsymbol{Ax}, \\boldsymbol{x}\\rangle = 0\\) 인데 이는 \\(\\boldsymbol{A}\\) 가 positive definite 가 아니라는 의미이다.\n(\\(4\\)) \\(A_{ii} = \\langle \\boldsymbol{Ae}_i,\\, \\boldsymbol{e}_i\\rangle &gt; 0\\)\n(\\(5\\)) \\(i\\ne j\\) 에 대해\n\\[\n\\begin{aligned}\n0&lt; \\langle \\boldsymbol{A}(\\boldsymbol{e}_i-\\boldsymbol{e}_j), (\\boldsymbol{e}_i-\\boldsymbol{e}_j)\\rangle = A_{ii}+ A_{ij} - 2 A_{ij} \\\\\n0&lt; \\langle \\boldsymbol{A}(\\boldsymbol{e}_i+\\boldsymbol{e}_j), (\\boldsymbol{e}_i+\\boldsymbol{e}_j)\\rangle = A_{ii}+ A_{ij} + 2 A_{ij} \\\\\n\\end{aligned}\n\\]\n이므로 \\[\n|A_{ij}| &lt; \\dfrac{A_{ii}+A_{jj}}{2} \\le \\max \\{|A_{ii}| : i=1,\\ldots,\\,n\\}\n\\]\n이다.\n(\\(6\\)) \\(i\\ne j\\) 와 임의의 실수 \\(t\\) 에 대해\n\\[\n0 &lt; \\langle \\boldsymbol{A}(t\\boldsymbol{e}_i + \\boldsymbol{e}_j),\\, (t\\boldsymbol{e}_i + \\boldsymbol{e}_j)\\rangle = t^2A_{ii} +2tA_{ij}+ A_{jj}\n\\]\n이므로 \\((A_{ij})^2 &lt; A_{ii}A_{jj}\\) 이다. \\(\\square\\)\n\n\n\n\n\n\n\n\n\n정의 3 (부분 행렬(submatrix) 와 선행 주 부분 행렬(leading principal submatrix)) 행렬 \\(\\boldsymbol{A}\\in \\mathbb{F}^{m \\times n}\\) 에 대해 임의의 중복되지 않은 행 \\(I=\\{i_1,\\ldots,\\,i_p: 1\\le i_k\\le m\\}\\) 과 중복되지 않은 열 \\(J=\\{j_1,\\ldots,\\,j_q: 1 \\le j_l \\le n \\}\\) 을 모아 만든 행렬을 \\(\\boldsymbol{A}\\) 의 부분 행렬이라고 하고 \\(\\boldsymbol{A}[I, J]\\) 라고 쓴다. \\(I=1,\\ldots,\\,k\\), \\(J=1,\\ldots,\\,k\\) 일 때 \\(\\boldsymbol{A}[I, J]\\) 를 선행 주 부분 행렬 이라고 하고 \\(\\boldsymbol{A}_k\\) 라고 쓴다.\n\n\n\n\n\n이제 \\(\\boldsymbol{A}\\) 가 positive definite 인 것과 \\(\\boldsymbol{A}\\) 의 모든 선행 주 부분행렬의 행렬식이 \\(0\\) 보다 큰 것이 동치임을 보이고자 한다. 이를 위해 몇가지 미리 보여야 할 것이 있다.\n\n보조정리 1 \\(\\boldsymbol{A}\\in \\mathbb{R}^{n \\times n}\\) 이 대칭행렬이고 \\(\\boldsymbol{Q} \\in \\mathbb{R}^{n \\times n}\\) 이 가역행렬 일 때 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 가 positive definite 이고 \\(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 가 대칭행렬이다.\n  (\\(2\\)) \\(\\boldsymbol{Q}^T \\boldsymbol{AQ}\\) 가 positive definte 이다.\n\n\n(증명). (\\(1 \\implies 2\\)) 임의의 \\(\\boldsymbol{0}\\) 벡터가 아닌 \\(\\boldsymbol{v}\\in \\mathbb{R}^{n}\\) 에 대해 \\(\\boldsymbol{Qv}\\ne \\boldsymbol{0}\\) 이다. \\(\\boldsymbol{A}\\) 가 positive definite 이므로,\n\\[\n0 &lt; (\\boldsymbol{Qv})^T \\boldsymbol(A)(\\boldsymbol{Qv}) = \\boldsymbol{v} \\left(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\right)\\boldsymbol{z}\n\\]\n이므로 \\(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 는 positive definite 이다.\n(\\(2 \\implies 1\\)) \\(\\boldsymbol{A}\\) 가 대칭행렬이므로 \\((\\boldsymbol{Q}^T\\boldsymbol{AQ})^T = \\boldsymbol{Q}^T \\boldsymbol{A}^T\\boldsymbol{Q} = \\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 이다. 즉 \\(\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 는 대칭행렬이다. \\(\\boldsymbol{Q}\\) 가 가역이므로 임의의 \\(\\boldsymbol{x}\\in \\mathbb{R}^{n}\\) 에 대해 \\(\\boldsymbol{x}=\\boldsymbol{Qy}\\) 를 만족하는 \\(\\boldsymbol{y}\\in \\mathbb{R}^n\\) 이 존재한다.\n\\[\n\\boldsymbol{x}^T\\boldsymbol{Ax} =  (\\boldsymbol{Qy})^T \\boldsymbol{A}\\boldsymbol{Qy} = \\boldsymbol{y}^T\\boldsymbol{Q}^T\\boldsymbol{AQ}\\boldsymbol{y} &gt; 0\n\\]\n이므로 \\(\\boldsymbol{A}\\) 는 positive defnite 이다. \\(\\square\\)\n\n\n\n명제 4 대칭행렬 \\(\\boldsymbol{A}\\) 가 positive definite 일 필요충분조건은 \\(\\boldsymbol{A}\\) 의 모든 선행 주 부분 행렬의 행렬식이 양수인 것이다.\n\n\n(증명). Inductinon 을 통해 증명한다. \\(1 \\times 1\\) 행렬의 경우는 trivial 하다. 이제 \\(n\\times n\\) 행렬에 대해 성립한다고 가정한다. \\(\\boldsymbol{A}\\) 가 \\((n+1)\\times (n+1)\\) 행렬이라 하자.Carl P.Simon & Lawrence E. Blume 의 Mathematics for Economists 의 증명이다\n우선 모든 \\(\\boldsymbol{A}_i\\), \\(i=1,\\ldots,\\,n\\) 의 행렬식이 양수이면 \\(\\boldsymbol{A}\\) 가 positive definite 임을 보이자. 우선 \\(\\boldsymbol{A}\\) 를 \\(\\boldsymbol{A}_n\\) 에 대하여 아래와 같이 분할하여 보자.\n\\[\n\\boldsymbol{A} = \\left[\\begin{array}{c|c} \\boldsymbol{A}_n & \\boldsymbol{a} \\\\ \\hline \\boldsymbol{a}^T & a\\end{array}\\right]\n\\]\n여기서 \\(\\boldsymbol{a}=\\begin{bmatrix} A_{1, n+1} & \\cdots & A_{n, n+1}\\end{bmatrix}^T\\) 이고 \\(a=A_{n+1, n+1}\\) 이다. 그렇다면,\n\\[\n\\boldsymbol{A} = \\left[\\begin{array}{c|c} \\boldsymbol{I}_n & \\boldsymbol{0} \\\\ \\hline (\\boldsymbol{A}_n^{-1}\\boldsymbol{a})^T & 1\\end{array}\\right] \\left[\\begin{array}{c|c} \\boldsymbol{A}_n & \\boldsymbol{0}_n \\\\ \\hline (\\boldsymbol{0}_n)^T & d\\end{array}\\right] \\left[\\begin{array}{c|c} \\boldsymbol{I}_n & \\boldsymbol{A}_n^{-1}\\boldsymbol{a} \\\\ \\hline \\boldsymbol{0}_n^T & 1\\end{array}\\right] = \\boldsymbol{Q}^T\\boldsymbol{BQ}\n\\]\n이며 이 때 \\(d=a-\\boldsymbol{a}^T(\\boldsymbol{A}_n)^{-1}\\boldsymbol{a}\\) 이다. 또한 \\(\\boldsymbol{A}_n\\) 이 대칭행렬이므로 \\(\\boldsymbol{A}_n^{-1}\\) 도 대칭행렬이다. (즉 \\((\\boldsymbol{A}_n^{-1})^{T} = \\boldsymbol{A}_n^{-1}\\) 이다.)\n우리는 \\(\\det (\\boldsymbol{Q}^T) = \\det (\\boldsymbol{Q})=1\\) 이며 \\(\\det (\\boldsymbol{B})=d \\cdot \\det (\\boldsymbol{A}_n)\\) 임을 안다. 즉\n\\[\n\\det (\\boldsymbol{A}) =  d \\cdot \\det (\\boldsymbol{A}_n)\n\\]\n이다. \\(\\boldsymbol{A}\\) 가 positive definite 이며 \\(\\det (\\boldsymbol{A})&gt;0\\) 이므로 \\(d&gt;0\\) 이다.\n이제 임의의 \\(\\boldsymbol{x}\\in \\mathbb{R}^{n+1}\\) 을 생각하자. \\(\\boldsymbol{x} = \\begin{bmatrix} \\boldsymbol{x}_0 & x \\end{bmatrix}^T\\), \\(\\boldsymbol{x}_0 \\in \\mathbb{R}^n\\) 이라 하면,\n\\[\n\\boldsymbol{x}^T \\boldsymbol{Bx} = \\boldsymbol{x}^T \\boldsymbol{A}_n \\boldsymbol{x} + d\\cdot x\n\\]\n이다. \\(\\boldsymbol{A}_n\\) 이 가정에 의해 positive definite 이며, \\(d&gt;0\\) 이므로 \\(\\boldsymbol{x}^T\\boldsymbol{Bx}&gt;0\\) 이다. 따라서 보조정리 1 에 의해 \\(\\boldsymbol{B}=\\boldsymbol{Q}^T\\boldsymbol{AQ}\\) 일 때 \\(\\boldsymbol{A}\\) 는 positive definite 이다. \\(\\square\\)\n\n\n\n명제 5 대칭행렬 \\(\\boldsymbol{A}\\) 에 대해 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 는 positive definite 하다.\n  (\\(2\\)) \\(\\boldsymbol{A}\\) 는 피보팅 없이 가우스-요르단 소거법을 수행 할 수 있으며, 피봇 성분은 양수이다.\n\n\n(증명)."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html#스펙트럼-반경과-반복법을-통한-선형시스템의-해",
    "href": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html#스펙트럼-반경과-반복법을-통한-선형시스템의-해",
    "title": "반복법을 이용한 선형 시스템의 해를 구하기",
    "section": "2 스펙트럼 반경과 반복법을 통한 선형시스템의 해",
    "text": "2 스펙트럼 반경과 반복법을 통한 선형시스템의 해\n\n스펙트럼 반경\n우리는 앞서 직접적으로 선형 시스템 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 의 해를 구하였다. 그러나 선형 시스템이 매우 크며, \\(\\boldsymbol{A}\\) 의 대분이 \\(0\\) 일 경우는 직접적으로 구하지 않고 반복법을 통해 구하는 방법이 더 빠르다. 여기서는 이를 알아보기로 한다. 먼저 많이 사용하게 될 개념을 우선 정하기로 하자.\n\n\n\n\n\n\n\n\n정의 4 (스펙트럼 반경(spectral radius))   (\\(1\\)) 정사각 행렬 \\(\\boldsymbol{A}\\) 에 대해 \\(\\lambda(\\boldsymbol{A})\\) 는 \\(\\boldsymbol{A}\\) 의 모든 고유값들의 집합이다.\n  (\\(2\\)) 행렬 \\(\\boldsymbol{A}\\) 의 스펙트럼 반경 \\(\\rho(\\boldsymbol{A})\\) 는 \\(\\lambda(\\boldsymbol{A})\\) 의 절대값의 상한으로 정의된다. 즉,\n\\[\n\\rho (\\boldsymbol{A}) := \\max \\{ |\\lambda| : \\lambda \\in \\lambda(\\boldsymbol{A})\\}.\n\\]\n\n\n\n\n\n\\(\\rho(\\boldsymbol{A})\\) 는 행렬에 대해 고유하게 정해지는 값이지만 행렬의 노름이 될 수 없다. 예를 들어\n\\[\n\\boldsymbol{A} = \\begin{bmatrix}2 & 1\\\\  2 &-2\\end{bmatrix},\\, \\boldsymbol{B} = \\begin{bmatrix} 2 & 4 \\\\ 1 &-3\\end{bmatrix}\n\\]\n의 경우 \\(\\rho(\\boldsymbol{A}) \\approx 2.45\\), \\(\\rho(\\boldsymbol{B}) \\approx 3.70\\), \\(\\rho(\\boldsymbol{A}+\\boldsymbol{B}) \\approx 6.44\\) 이므로 \\(\\rho(\\boldsymbol{A}+\\boldsymbol{B}) &gt; \\rho(\\boldsymbol{A}) + \\rho (\\boldsymbol{B})\\) 인데 이것은 행렬의 노름이 될 조건에 위배된다.\n\n\n명제 6 \\(\\boldsymbol{A}\\in \\mathbb{F}^{n \\times n}\\) 에 대해\n  (\\(1\\)) \\(\\boldsymbol{A} \\in \\mathbb{F}^{n \\times n}\\) 에 대해 다음이 성립한다.\n  (\\(2\\)) \\(\\rho(\\boldsymbol{A})\\) 는 모든 자연스러운 노름에 대해 \\(\\|\\boldsymbol{A}\\|\\) 보다 작거나 같다.\n\n\n(증명). (\\(1\\)) 증명은 Isacson, Keller 의 Analysis of numerical method (1966) 을 참고하라\n(\\(2\\)) \\(\\lambda \\in \\lambda(\\boldsymbol{A})\\) 이고 \\(\\boldsymbol{x}\\in \\mathbb{F}^n\\) 에 대해 \\(\\|\\boldsymbol{x}\\|=1\\) 일 때,\n\\[\n|\\lambda| =  \\|\\lambda \\boldsymbol{x}\\| = \\|\\boldsymbol{Ax}\\| \\le \\|\\boldsymbol{A}\\| \\|\\boldsymbol{x}\\| = \\|\\boldsymbol{A}\\|\n\\]\n\n\n\n\n\n\n\n\n\n정의 5 (행렬의 수렴) 정사각 행렬 \\(\\boldsymbol{A}\\in \\mathbb{F}^{n \\times n}\\) 이 다음 조건을 만족할 때 행렬 \\(\\boldsymbol{A}\\) 가 수렴한다고 한다.\n\\[\n\\lim_{k \\to \\infty} \\boldsymbol{A}^k = \\boldsymbol{0}.\n\\]\n\n\n\n\n\n\n명제 7 정사각 행렬 \\(\\boldsymbol{A}\\in \\mathbb{F}^{n \\times n}\\) 에 대해 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 는 수렴한다.\n  (\\(2\\)) 자연스러운 행렬 노름에 대해 \\(\\displaystyle \\lim_{k \\to \\infty} \\left\\|\\boldsymbol{A}^k\\right\\|=\\boldsymbol{0}\\) 이다.\n  (\\(3\\)) \\(\\rho (\\boldsymbol{A})&lt; 1\\).\n  (\\(3\\)) \\(\\displaystyle \\lim_{k\\to \\infty} \\boldsymbol{A}^k \\boldsymbol{x} = \\boldsymbol{0}\\).\n\n\n(증명). 증명은 Isacson, Keller 의 Analysis of numerical method (1966) 을 참고하라\n\n\n선형 시스템 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 반복법으로 구하는 방법중에 가장 일반적으로 사용되는 방법은 주어진 선형 방정식을 다음의 형태로 변형하는데서 시작한다.\n\\[\n\\boldsymbol{x} = \\boldsymbol{Tx}+ \\boldsymbol{c}.\n\\]\n만약 \\(\\boldsymbol{T}\\) 가 어떤 조건을 만족하면 초기값 \\(\\boldsymbol{x}^{(0)}\\) 부터 시작하여 \\[\n\\boldsymbol{x}^{(k+1)} =  \\boldsymbol{Tx}^{(k)}  + \\boldsymbol{c}\n\\]\n에서 생성되는 수열 \\(\\langle \\boldsymbol{x}^{(k)}\\rangle\\), \\(k=0,\\,1,\\ldots\\) 는 \\(\\boldsymbol{x} = \\boldsymbol{Tx}+ \\boldsymbol{c}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 로 수렴한다.\n\n\n보조정리 2 행렬 \\(\\boldsymbol{T}\\in \\mathbb{F}^{n \\times n}\\) 의 스펙트럼 반경이 \\(1\\) 보다 작다면 \\(\\boldsymbol{I}-\\boldsymbol{T}\\) 는 가역행렬이며,\n\\[\n(\\boldsymbol{I}-\\boldsymbol{T})^{-1} = \\sum_{j=0}^{\\infty} \\boldsymbol{T}^j\n\\]\n이다.\n\n\n(증명). \\(\\boldsymbol{x}\\) 가 \\(\\boldsymbol{T}\\) 의 고유벡터이며 그 고유값이 \\(\\lambda\\) 인것과 \\(\\boldsymbol{x}\\) 가 \\(\\boldsymbol{I}-\\boldsymbol{T}\\) 의 공유벡터이며 그 고유값이 \\((1-\\lambda)\\) 인것은 동치이다. 그런데 \\(\\boldsymbol{T}\\) 의 고유값의 절대값이 \\(1\\) 보다 작기 때문에 0 은 \\((\\boldsymbol{I}-\\boldsymbol{T})\\) 의 고유값이 될 수 없으며, 따라서 \\(\\boldsymbol{I}-\\boldsymbol{T}\\) 는 가역행렬이다.\n또한\n\\[\n(\\boldsymbol{I}-\\boldsymbol{T})\\left(\\sum_{j=0}^N \\boldsymbol{T}^j\\right) = \\boldsymbol{I} -\\boldsymbol{T}^{N+1}\n\\]\n이므로 명제 7 에 의해 \\((\\boldsymbol{I}-\\boldsymbol{T})^{-1} = \\displaystyle\\sum_{j=0}^\\infty \\boldsymbol{T}^j\\) 이다. \\(\\square\\)\n\n\n\n정리 2 임의의 \\(\\boldsymbol{x}^{(0)},\\, \\boldsymbol{c}\\in \\mathbb{F}^{n}\\) 과 행렬 \\(\\boldsymbol{T}\\in \\mathbb{F}^{n \\times n}\\) 에 대해\n\\[\n\\boldsymbol{x}^{(k+1)} =  \\boldsymbol{Tx}^{(k)}+ \\boldsymbol{c}\n\\]\n에 의해 생성되는 수열 \\(\\langle \\boldsymbol{x}^{k}\\rangle\\) 이 \\(\\boldsymbol{x}=\\boldsymbol{Tx}+\\boldsymbol{c}\\) 를 만족하는 유일한 \\(\\boldsymbol{x}\\) 로 수렴할 필요충분조건은 \\(\\rho(\\boldsymbol{T})&lt;1\\) 이다.\n\n\n(증명). \\(\\rho(\\boldsymbol{T})&lt;1\\) 임을 가정하자.\n\\[\n\\begin{aligned}\n\\boldsymbol{x}^{(k+1)} &= \\boldsymbol{Tx}^{k}+\\boldsymbol{c} \\\\\n&= \\boldsymbol{T}\\left(\\boldsymbol{Tx}^{k-1} + \\boldsymbol{c}\\right) + \\boldsymbol{c}  \\\\\n&\\qquad \\qquad \\vdots \\\\\n&=  \\boldsymbol{T}^{k+1}\\boldsymbol{x}^{(0)} + (\\boldsymbol{T}^{k}+ \\cdots + \\boldsymbol{T}+ \\boldsymbol{I})\\boldsymbol{c}\n\\end{aligned}\n\\]\n이므로 \\(k \\to \\infty\\) 극한에서 \\(\\boldsymbol{x}^{(\\infty)} = \\left(\\boldsymbol{I}-\\boldsymbol{T}\\right)^{-1}\\boldsymbol{c}\\) 이므로, \\(\\boldsymbol{x}\\) 는 수렴하며 \\(\\boldsymbol{x}^{(\\infty)} = \\boldsymbol{Tx}^{(\\infty)} +\\boldsymbol{c}\\) 를 만족한다.\n이제 \\(\\displaystyle \\lim_{k \\to \\infty}\\boldsymbol{x}^{(k)} = \\boldsymbol{x}\\) 이며 \\(\\boldsymbol{x}\\) 가 \\(\\boldsymbol{x}=\\boldsymbol{Tx}+\\boldsymbol{c}\\) 를 만족하는 유일한 해라고 하자. 즉 \\(\\boldsymbol{I}-\\boldsymbol{T}\\) 는 가역이다. 임의의 \\(\\boldsymbol{z}\\in \\mathbb{F}^n\\) 에 대해 \\(\\boldsymbol{x}^{(0)} = \\boldsymbol{x}-\\boldsymbol{z}\\) 라고 하자. \\(\\boldsymbol{x}^{(k+1)} = \\boldsymbol{Tx}^{(k)} + \\boldsymbol{c}\\) 이면 \\(\\langle \\boldsymbol{x}^{k}\\rangle\\) 은 \\(\\boldsymbol{x}\\) 로 수렴하며,\n\\[\n\\boldsymbol{x}-\\boldsymbol{x}^{(k+1)} = (\\boldsymbol{Tx}+\\boldsymbol{c})-(\\boldsymbol{Tx}^{k}+\\boldsymbol{c}) =  \\boldsymbol{T}(\\boldsymbol{x}-\\boldsymbol{x}^{(k)})\n\\]\n이므로,\n\\[\n\\boldsymbol{x}-\\boldsymbol{x}^{(k+1)} = \\boldsymbol{T}^{k+1}(\\boldsymbol{x}-\\boldsymbol{x}^{(0)}) = \\boldsymbol{T}^{(k+1)}\\boldsymbol{z}\n\\]\n이다. 명제 7 에 따라 임의의 \\(\\boldsymbol{z}\\) 에 대해 \\(\\displaystyle \\lim_{k \\to \\infty} \\boldsymbol{T}^{(k+1)}\\boldsymbol{z}=0\\) 이면 \\(\\rho(\\boldsymbol{T})&lt;1\\) 이다. \\(\\square\\)\n\n\n\n따름정리 1 임의의 자연스러운 행렬 노름에 대해 \\(\\|\\boldsymbol{T}\\|&lt;1\\) 이면 임의의 벡터 \\(\\boldsymbol{c}\\) 에 대해 \\(\\boldsymbol{x}^{(k+1)} = \\boldsymbol{Tx}^{(k)}+\\boldsymbol{c}\\) 에 의해 생성되는 수열 \\(\\langle \\boldsymbol{x}^{(k)} \\rangle\\) 은 초기값 \\(\\boldsymbol{x}^{(0)}\\) 에 무관하게 \\(\\boldsymbol{x}=\\boldsymbol{Tx} + \\boldsymbol{c}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 로 수렴한다. 또한 다음을 만족한다.\n  (\\(1\\)) \\(\\| \\boldsymbol{x}-\\boldsymbol{x}^{(k)}\\| \\le \\|\\boldsymbol{T}\\|^k \\|\\boldsymbol{x}-\\boldsymbol{x}^{(0)}\\|\\),\n  (\\(2\\)) \\(\\displaystyle \\|\\boldsymbol{x}-\\boldsymbol{x}^{(k)}\\| \\le \\dfrac{\\|\\boldsymbol{T}\\|^k}{1-\\|\\boldsymbol{T}\\|} \\|\\boldsymbol{x}^{(1)}-\\boldsymbol{x}^{(0)}\\|\\).\n\n\n(증명). \\(\\langle \\boldsymbol{x}^{(k)} \\rangle\\) 의 수렴은 정리 2 로 부터 알 수 있다. 명제 6 에 의해 \\(\\rho(\\boldsymbol{T}) \\le \\|\\boldsymbol{T}\\|&lt;1\\) 이다. 따라서\n\\[\n\\|\\boldsymbol{x}-\\boldsymbol{x}^{(k)}\\| \\le \\|\\boldsymbol{T}\\| \\cdot \\|\\boldsymbol{x}-\\boldsymbol{x}^{(k-1)}\\| \\le  \\cdots \\le \\|\\boldsymbol{T}\\|^{k} \\cdot \\|\\boldsymbol{x}-\\boldsymbol{x}^{(0)}\\|\n\\]\n이다.\n또한\n\\[\n\\begin{aligned}\n\\|\\boldsymbol{x}^{(k+1)}-\\boldsymbol{x}^{(k)}\\| & = \\|\\boldsymbol{Tx}^{(k)}- \\boldsymbol{Tx}^{(k-1)}\\|\\le \\|\\boldsymbol{T}\\|\\cdot \\| \\boldsymbol{x}^{(k)}-\\boldsymbol{x}^{(k-1)} \\| \\\\\n& \\le \\cdots \\le \\|\\boldsymbol{T}\\|^k \\cdot \\|\\boldsymbol{x}^{(1)}-\\boldsymbol{x}^{(0)}\\|\n\\end{aligned}\n\\]\n이므로 양의 정수 \\(m\\) 에 대해\n\\[\n\\begin{aligned}\n\\|\\boldsymbol{x}^{(k+m)} -\\boldsymbol{x}^{(k)}\\| & = \\| \\boldsymbol{x}^{(k+m)} - \\boldsymbol{x}^{(k+m-1)} + \\boldsymbol{x}^{(k+m-1)} - \\cdots + \\boldsymbol{x}^{(k+1)}- \\boldsymbol{x}^{(k)} \\| \\\\\n&\\le  \\| \\boldsymbol{x}^{(k+m)} - \\boldsymbol{x}^{(k+m-1)} \\| + \\cdots +  \\| \\boldsymbol{x}^{(k+1)} - \\boldsymbol{x}^{(k)}\\| \\\\\n&\\le \\|\\boldsymbol{T}\\|^{k+m-1} \\cdot \\|\\boldsymbol{x}^{(1)} - \\boldsymbol{x}^{(0)}\\| + \\cdots +\\|\\boldsymbol{T}\\|^k \\|\\boldsymbol{x}^{(1)} - \\boldsymbol{x}^{(0)}\\|  \\\\\n& = \\|\\boldsymbol{T}\\|^k \\left(1 + \\|\\boldsymbol{T}\\| + \\cdots +\\|\\boldsymbol{T}\\|^{m-1}\\right) \\|\\boldsymbol{x}^{(1)} - \\boldsymbol{x}^{(0)}\\| \\\\\n\\end{aligned}\n\\]\n이므로 \\(m \\to \\infty\\) 극한에서,\n\\[\n\\|\\boldsymbol{x}-\\boldsymbol{x}^{(k)} \\| \\le \\dfrac{\\|\\boldsymbol{T}\\|^{k}}{1-\\|\\boldsymbol{T}\\|} \\|\\boldsymbol{x}^{(1)}-\\boldsymbol{x}^{(0)}\\|\n\\]\n이다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html#야코비jacobi-방법과-가우스-지델gauss-siedel-방법",
    "href": "src/numerical_analysis_using_julia/07_iterative_method_for_linear_system.html#야코비jacobi-방법과-가우스-지델gauss-siedel-방법",
    "title": "반복법을 이용한 선형 시스템의 해를 구하기",
    "section": "3 야코비(Jacobi) 방법과 가우스-지델(Gauss-Siedel) 방법",
    "text": "3 야코비(Jacobi) 방법과 가우스-지델(Gauss-Siedel) 방법\n\n야코비 방법\n모든 대각 성분이 \\(0\\) 이 아닌 행렬 \\(\\boldsymbol{A}\\) 를 대각행렬 \\(\\boldsymbol{D}\\) 와 하삼각행렬 \\(\\boldsymbol{L}\\), 상삼각행렬 \\(\\boldsymbol{U}\\) 의 합으로 표현한다고 하자. 이 때 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 는 \\((\\boldsymbol{D} + \\boldsymbol{L} +\\boldsymbol{U})\\boldsymbol{x}=\\boldsymbol{b}\\) 가 되며,\n\\[\n\\boldsymbol{Dx}=-(\\boldsymbol{L}+\\boldsymbol{U})\\boldsymbol{x}+\\boldsymbol{b}\n\\]\n이다. 모든 대각 성분이 \\(0\\) 이 아닌 대각행렬 \\(\\boldsymbol{D}\\) 는 가역행렬이므로,\n\\[\n\\boldsymbol{x} = -\\boldsymbol{D}^{-1}(\\boldsymbol{L}+\\boldsymbol{U})\\boldsymbol{x} + \\boldsymbol{D}^{-1}\\boldsymbol{b}\n\\]\n이다.\n선형 방정식 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 에 대해 \\(\\boldsymbol{A}\\) 의 모든 대각 성분이 \\(0\\) 이 아니라고 하자. 초기 벡터 \\(\\boldsymbol{x}^{(0)}\\) 의 \\(i\\) 번째 성분 \\(x^0_i\\) 를 다음과 같이 정한다.\n\\[\nx_i^{(0)} = \\sum_{j=1,\\,j\\ne1}^n \\left(- \\dfrac{-a_{ij}x_j}{A_{ii}}\\right) + \\dfrac{b_j}{a_{ii}}.\n\\]\n\\(k\\) 번째 i\n\\[\nx_i^{(k+1)} = \\dfrac{1}{A_{ii}} \\left[\\sum_{j=1,\\,j\\ne i}^n \\left( -A_{ij}\\, x_j^{(k)} \\right) + b_i\\right]\n\\]"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/08_least_square_problem.html",
    "href": "src/numerical_analysis_using_julia/08_least_square_problem.html",
    "title": "최소자승 문제",
    "section": "",
    "text": "\\(\\mathbb{C}^{n\\times 1}\\) 에서의 벡터 \\(\\boldsymbol{v}\\) 에 대해 다음과 같이 정의된 \\(\\boldsymbol{H}_v\\) 를 하우스홀더 행렬 (Householder matrix) 이라 한다.\n\\[\n\\begin{aligned}\n\\boldsymbol{H}_{\\boldsymbol{v}} := I_n- \\dfrac{2\\boldsymbol{v}\\boldsymbol{v}^{\\ast}}{\\|\\boldsymbol{v}\\|^2}, \\qquad \\text{i. e. }\\quad\n(\\boldsymbol{H}_{\\boldsymbol{v}})_{ij} := \\delta_{ij} - \\dfrac{2 v_i \\overline{v_j}}{\\|\\boldsymbol{v}\\|^2}.\n\\end{aligned}\n\\]\n여기서 \\(\\boldsymbol{v}\\boldsymbol{v}^{\\ast}\\) 는 벡터의 내적이 아니라 \\(n\\times 1\\) 행렬 \\(\\boldsymbol{v}\\) 와 \\(1 \\times n\\) 행렬 \\(\\boldsymbol{v}^{\\ast}\\) 가 곱해진 \\(n \\times n\\) 행렬을 의미한다. 벡터 \\(\\boldsymbol{x}\\in \\mathbb{C}^n\\) 에 대해 \\(\\boldsymbol{H}_{\\boldsymbol{v}} \\boldsymbol{x}\\in \\mathbb{C}^n\\) 을 하우스홀더 변환 이라 한다. \\(\\boldsymbol{v}\\) 가 단위벡터일 경우, 즉 \\(\\|\\boldsymbol{v}\\|=1\\) 라면 좀 더 간단하게 쓸 수 있다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}} = I_n- 2\\boldsymbol{v}\\boldsymbol{v}^{\\ast},\\qquad \\text{where } \\|\\boldsymbol{v}\\|=1.\n\\]\n\n\n명제 1 위와 같이 정의된 하우스홀더 행렬 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 은 다음의 특징을 가진다.\n  (\\(1\\)) 에르미트 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}}= \\boldsymbol{H}_{\\boldsymbol{v}}^\\ast\\).\n  (\\(2\\)) 유니타리 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}} (\\boldsymbol{H}_{\\boldsymbol{v}})^\\ast = I\\).\n\n\n(증명). (\\(1\\)) \\(\\boldsymbol{v}\\) 가 단위벡터일 경우에만 보여도 된다. \\(\\boldsymbol{H} = \\boldsymbol{H}_{\\boldsymbol{v}}\\) 라 하면,\n\\[\n(\\boldsymbol{H}^\\ast)_{ij} = \\overline{H_{ji}}= \\delta_{ij}-2 \\overline{v_j \\overline{v_i}} = \\delta_{ij}-2 v_i \\overline{v_j} = (\\boldsymbol{H})_{ij}\n\\]\n이므로 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 는 에르미트 행렬이다.\n(\\(2\\)) 또한,\n\\[\n\\begin{aligned}\n\\left(\\boldsymbol{H} (\\boldsymbol{H}^\\ast)\\right)_{ij} &= \\left((\\boldsymbol{H})^2\\right)_{ij} = \\sum_{k}(\\delta_{ik}-2 v_i \\overline{v_k})(\\delta_{kj} -2 v_k \\overline{v_j}) \\\\\n&= \\sum_k \\delta_{ik}\\delta_{kj} - 2\\sum_k \\delta_{ik}v_k \\overline{v_j} - 2 \\sum_k \\delta_{kj} v_i \\overline{v_k} + 4 \\sum_{k} v_i \\overline{v_j} v_k \\overline{v_k} \\\\\n&= \\delta_{ij} - 2 v_i \\overline{v_{j}} - 2 v_i \\overline{v_j} + 4 v_i \\overline{v_j} = \\delta_{ij}\n\\end{aligned}\n\\]\n이다. \\(\\square\\)\n\n\n따라서 \\(\\mathbb{R}^n\\) 에서 생각 할 경우 하우스홀더 행렬은 대칭행렬이며, 직교행렬(orthogonal matrix) 이다.\n\n\n\n하우스 홀더 변환이 리플렉션(reflection, 반사) 라고 불린다. 수학적으로 \\(\\mathbb{R}^n\\) 공간에서 벡터 \\(\\boldsymbol{v}\\) 만으로 \\(\\boldsymbol{v}\\) 와 수직이며 원점을 지나는 평면이 유일하게 정의될 수 있다. 임의의 벡터 \\(\\boldsymbol{x} \\in \\mathbb{F}^n\\) 에 대해,\n\\[\n\\begin{aligned}\n(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x})_k &=  x_k - \\dfrac{2}{\\|\\boldsymbol{v}\\|^2}  \\sum_{j=1}^n v_k \\overline{v_j} x_j\\\\\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} &= \\boldsymbol{x} - 2 \\dfrac{\\langle \\boldsymbol{x},\\,  \\boldsymbol{v} \\rangle \\boldsymbol{v}}{\\|\\boldsymbol{v}\\|^2}\n\\end{aligned}\n\\]\n이며,\n\\[\n\\begin{aligned}\n\\dfrac{1}{2 }(\\boldsymbol{x}+\\boldsymbol{Hx}) &= \\boldsymbol{x} - \\langle \\boldsymbol{v,\\,  x}\\rangle \\boldsymbol{v} = \\boldsymbol{x} - \\text{Proj}_{\\boldsymbol{v}} \\boldsymbol{x} \\\\\n\\boldsymbol{x}-\\boldsymbol{Hx} &= 2\\langle \\boldsymbol{v ,\\, x} \\rangle  \\boldsymbol{v} = 2\\, \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\n\\end{aligned}\n\\]\n이다. 즉 \\(\\boldsymbol{x}\\) 와 \\(\\boldsymbol{Hx}\\) 는 \\(\\boldsymbol{v}\\) 에 의해 정의되는 평면에 대해 대칭이다.\n\n\n\nHouseholder 반사\n\n\n\\(\\boldsymbol{x}\\) 를 \\(\\boldsymbol{v}\\) 와 평행한 부분과 수직한 부분으로 분리하자. 즉 \\(\\boldsymbol{x}_{\\|} = \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\), \\(\\boldsymbol{x}_{\\perp} = \\boldsymbol{x}-\\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 라 하면, \\(\\boldsymbol{x} = \\boldsymbol{x}_{\\|} + \\boldsymbol{x}_{\\perp}\\) 이며 \\(\\boldsymbol{x}\\cdot \\boldsymbol{v} = \\boldsymbol{x}_{\\|}\\cdot \\boldsymbol{v}\\) 이다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x} - 2 \\boldsymbol{x}_{\\|} = \\boldsymbol{x}_{\\perp} - \\boldsymbol{x}_{\\|}\n\\]\n이다.\n\n\n\n\n\n명제 2 \\(\\mathbb{F}^m\\) 에서의 벡터 \\(\\boldsymbol{x}\\) 과 표준 기저 \\(\\{\\boldsymbol{e}_1,\\ldots,\\,\\boldsymbol{e}_m\\}\\) 를 생각하자. \\(\\alpha\\) 를 \\(\\boldsymbol{x}\\) 의 첫번째 성분 \\(x_1 = re^{i\\theta}\\) 에 대해 다음과 같이 정의한다.\n\\[\n\\alpha = \\left\\{ \\begin{array}{ll} \\|\\boldsymbol{x}\\|_2  & \\text{where } \\mathbb{F}=\\mathbb{R}, \\\\ e^{i\\theta}\\|\\boldsymbol{x}\\|_2 \\qquad & \\text{where } \\mathbb{F} =\\mathbb{C}. \\end{array} \\right.\n\\]\n\\(\\boldsymbol{x}\\) 에 대해 \\(\\boldsymbol{v}\\) 를 다음과 같이 정하자.\n\\[\n\\boldsymbol{v} = \\boldsymbol{x} - \\alpha \\boldsymbol{e}_1, \\\\\n\\]\n이 때 \\(\\boldsymbol{x}\\) 의 \\(\\boldsymbol{v}\\) 에 대한 하우스홀더 변환 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 는 다음과 같다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1.\n\\]\n\n\n(증명). \\(\\alpha \\overline{x}_1 = \\overline{\\alpha}x_1 = |x_1| \\|\\boldsymbol{x}\\|_2\\) 이며 \\(|\\alpha|^2 = \\|\\boldsymbol{x}\\|_2^2\\) 이다. \\(a=\\alpha\\overline{x}_1=\\overline{\\alpha}x_1\\) 이라 놓고 다음을 계산해 보자. \\[\n\\begin{aligned}\n\\langle \\boldsymbol{x},\\,\\boldsymbol{v}\\rangle & = \\langle \\, \\boldsymbol{x} , \\boldsymbol{x}-\\alpha \\boldsymbol{e}_1\\rangle = \\|\\boldsymbol{x}\\|_2^2-\\overline{\\alpha} x_1  = \\|\\boldsymbol{x}\\|_2^2 - a\\\\\n\\langle \\boldsymbol{v},\\,\\boldsymbol{v}\\rangle &= \\langle \\boldsymbol{x} -\\alpha \\boldsymbol{e}_1,\\, \\boldsymbol{x} -\\alpha\\boldsymbol{e}_1 \\rangle  = \\|\\boldsymbol{x}\\|^2 - \\overline{\\alpha} x_1 -\\alpha \\overline{x_1} + |\\alpha|^2 = 2(\\|\\boldsymbol{x}\\|_2^2 -a) \\\\\n&= 2 \\langle \\boldsymbol{x},\\, \\boldsymbol{v} \\rangle\n\\end{aligned}\n\\]\n이므로, (잠시 \\(\\|\\boldsymbol{x}\\|_2\\) 를 \\(\\|\\boldsymbol{x}\\|\\) 라 하자.)\n\\[\n\\boldsymbol{H}_\\boldsymbol{v} \\boldsymbol{x} = \\boldsymbol{x} - 2\\dfrac{\\langle \\boldsymbol{x},\\, \\boldsymbol{v}\\rangle}{\\|\\boldsymbol{v}\\|^2} \\boldsymbol{v} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1\n\\]\n이다. \\(\\square\\)\n\n\n이미 설명한 그람 슈미트 방법과 유사하게\n이제 \\(\\boldsymbol{Q}_1= \\boldsymbol{Q},\\, \\boldsymbol{A}=\\boldsymbol{A}_1\\) 이라 놓으면,\n\\[\n\\boldsymbol{Q}_1\\boldsymbol{A}_1 = \\begin{bmatrix}\\alpha _{1} & \\ast &\\cdots &\\ast \\\\0 & & &\\\\ \\vdots & & \\boldsymbol{A}_2 & \\\\ 0 & & & \\end{bmatrix}\n\\]\n꼴이 된다. 이제 행렬 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 번째 행까지는 상삼각 행렬의 모양을 따른다고 하자. 즉 \\(j\\le k\\) 이고 \\(i&gt;k\\) 이면 \\((\\boldsymbol{A}_k)_{ij}=0\\) 이라 하자. 이 때 \\(\\boldsymbol{A}_k\\) 의 \\(k\\) 번째 행부터 \\(m\\) 행, \\(k\\) 번째 열부터 \\(m\\) 열까지를 \\(\\boldsymbol{A}'_k\\) 라 하고,(julia 로 표현하면 Ak[k:end, k:end] 가 될 것이다) 이 \\(\\boldsymbol{A}'_k\\) 에 대해 앞서 \\(\\boldsymbol{A}\\) 에 했던 것과 똑같은 과정을 수행하는 하우스홀더 행렬을 \\(\\boldsymbol{Q}'_k\\) 라 하면 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 는 \\(\\boldsymbol{Q}_1\\boldsymbol{A}_1\\) 처럼 첫번째 열에서는 첫번째 행을 제외한 나며지 행의 값이 \\(0\\) 이 된다. 만약\n\\[\n\\boldsymbol{Q}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix}\n\\]\n이라 하면, \\((k-1)\\times (k-1)\\) 단위행렬 \\(I_{k-1}\\) 과 \\(\\boldsymbol{A}_k\\) 를 \\(k\\) 행 과 \\(k\\) 열 부터 잘라 \\(\\boldsymbol{A}_{k} = \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix}\\) 로 만들자. \\(B_k\\) 는 \\((k-1) \\times (k-1)\\) 행렬이며 \\(\\boldsymbol{A}'_{k}\\) 는 \\((m-k+1)\\times (n-k+1)\\) 행렬이다. \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 열까지 상삼각 행렬 모양이므로 \\(B_k\\) 아래는 \\(0\\) 행렬이다. 두 행렬의 곱은 \\[\n\\boldsymbol{Q}_k \\boldsymbol{A}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k' \\end{bmatrix} \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix} = \\begin{bmatrix} B_k & C_k \\\\ 0 & \\boldsymbol{Q}'_k \\boldsymbol{A'}_k \\end{bmatrix}\n\\]\n이 되고 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 의 첫번째 열은 첫번째 행을 제외하면 모두 \\(0\\) 이므로 \\(\\boldsymbol{Q}_k \\boldsymbol{A}_k\\) 는 \\(k\\) 열까지 상삼각 행렬 꼴이 된다.\n\\(L = \\min\\{m,\\,n\\}\\) 이라 하면 \\(\\boldsymbol{Q}_L \\boldsymbol{Q}_{L-1} \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A}\\) 는 상삼각행렬꼴이 된다. 이를 \\(\\boldsymbol{R}\\) 이라 하자. \\(\\boldsymbol{Q}'_k\\) 가 하우스홀더 행렬이므로\n\\[\n\\boldsymbol{Q}_k \\boldsymbol{Q}_k^\\ast = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix} \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & (\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = \\begin{bmatrix} I_{k-1} & 0 \\\\0 & \\boldsymbol{Q}_k'\n(\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = I\n\\]\n이다. 즉 \\(\\boldsymbol{Q}_k\\) 도 직교행렬이다. \\(\\boldsymbol{Q}_k\\) 가 에르미트 행렬임은 쉽게 보일 수 있다. 이제,\n\\[\n\\boldsymbol{Q}_L \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A} = \\boldsymbol{R} \\implies \\boldsymbol{A} = \\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast \\boldsymbol{R}\n\\]\n임은 쉽게 보일 수 있다. 직교행렬의 곱은 직교행렬이므로 \\(\\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast\\) 도 직교행렬이다. 따라서 QR 분해를 할 수 있다.\n\n\n\n\n\n\\(W\\) 가 내적벡터공간 \\(V\\) 의 부분공간이라 하자. 이 때 그람슈미트 과정을 통해 \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_m\\}\\) 을 구할 수 있다. 이 때 \\(\\boldsymbol{v} \\in V\\) 의 \\(W\\) 에 대한 정사영 \\(\\text{Proj}_W \\boldsymbol{v}\\) 는 다음과 같이 정의된다.\n\\[\n\\text{Proj}_W \\boldsymbol{v} = \\sum_{i=1}^m \\langle \\boldsymbol{v},\\,\\hat{\\boldsymbol{u}}_i \\rangle\\,\\hat{\\boldsymbol{u}}_i\n\\]\n\\(\\text{Proj}_W \\boldsymbol{v}\\) 는 \\(W\\) 에 속한 벡터이며, 벡터에 대한 정사영과 마찬가지로 임의의 \\(\\boldsymbol{w} \\in W\\) 에 대해\n\\[\n\\langle \\boldsymbol{w},\\,  \\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\rangle = \\boldsymbol{0}\n\\]\n이다. \\(\\boldsymbol{v} = \\text{Proj}_W \\boldsymbol{v} + (\\boldsymbol{v} - \\text{Proj}_W\\boldsymbol{v} )\\) 이므로 벡터 \\(\\boldsymbol{v}\\) 를 \\(W\\) 에 속하는 벡터와, \\(W\\) 에 직교하는 벡터로 분해 할 수 있다.\n\n내적벡터공간 \\(V\\) 의 두 벡터 \\(\\boldsymbol{v}_1,\\,\\boldsymbol{v}_2\\) 의 거리는 \\(\\|\\boldsymbol{v}_1-\\boldsymbol{v}_2\\| = \\sqrt{\\langle \\boldsymbol{v}_1-\\boldsymbol{v}_2,\\,\\boldsymbol{v}_1-\\boldsymbol{v}_2 \\rangle}\\) 로 정의된다. \\(V\\) 와 그 부분공간 \\(W\\) 를 생각하자. \\(V\\) 의 벡터 \\(\\boldsymbol{v}\\) 와 \\(W\\) 사이의 거리 \\(d(\\boldsymbol{v},\\,W)\\) 는 \\(W\\) 에 속한 벡터 가운데 \\(\\boldsymbol{v}\\) 와의 거리가 가장 작은 벡터 \\(\\boldsymbol{v}_0\\) 와의 거리로 정의된다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\min_{\\boldsymbol{w}\\in W} \\| \\boldsymbol{v} - \\boldsymbol{w}\\|\n\\]\n이다. 여기서 \\(d(\\boldsymbol{v},\\,W) = d(\\boldsymbol{v},\\, \\text{Proj}_W \\boldsymbol{v})\\) 임을 보이고자 한다. \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n\\}\\) 을 생각하자. 그리고 \\(V\\) 의 정규기저 벡터는 앞의 \\(W\\) 의 정규기저벡터를 확장하여 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n,\\,\\hat{\\boldsymbol{f}}_1,\\ldots,\\,\\hat{\\boldsymbol{f}}_m\\}\\) 라 하자. 그렇다면 \\(\\langle \\hat{\\boldsymbol{u}}_i,\\, \\hat{\\boldsymbol{f}}_j \\rangle = 0\\), \\(\\langle \\hat{\\boldsymbol{f}}_i ,\\,\\hat{\\boldsymbol{f}}_j \\rangle = \\delta_{ij}\\) 이다. 이제 이 정규기저벡터로 \\(\\boldsymbol{v}\\in V\\) 를 표현하면,\n\\[\n\\boldsymbol{v} = a_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + a_n \\hat{\\boldsymbol{u}}_n + b_1 \\hat{\\boldsymbol{f}}_1 + \\cdots + b_m \\hat{\\boldsymbol{f}}_m\n\\]\n이다. 임의의 \\(\\boldsymbol{w} = c_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + c_n \\hat{\\boldsymbol{u}}_n \\in W\\) 와 \\(\\boldsymbol{v}\\) 와의 거리의 제곱은\n\\[\n\\begin{aligned}\n\\left(d(\\boldsymbol{v},\\,\\boldsymbol{w}) \\right)^2&= (a_1-c_1)^2 + \\cdots + (a_n - c_n)^2 + b_1^2 + \\cdots + b_m^2 \\ge b_1^2 + \\cdots +b_m ^2\n\\end{aligned}\n\\]\n이므로 \\(a_1=c_1, \\cdots , a_n = c_n\\) 일 때 \\(d(\\boldsymbol{v},\\,W)\\) 가 최소값이 됨을 알 수 있다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\|\\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\|\n\\]\n이다.\n선형 시스템에서 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족시키는 해가 없지만 \\(\\|\\boldsymbol{Ax}-\\boldsymbol{b}\\|\\) 를 최소화 하는 \\(\\boldsymbol{x}\\) 를 구하고자 할 경우를 생각하자. \\(\\boldsymbol{A}\\) 가 \\(m\\times n\\) 행렬이고 \\(\\boldsymbol{x}\\in \\mathbb{F}^n,\\,\\boldsymbol{b}\\in \\mathbb{F}^m\\) 이라 하자. \\(\\boldsymbol{A}\\) 의 \\(i\\) 번째 행을 \\(\\boldsymbol{a}_i\\) 라 하면 \\(\\boldsymbol{a}_i \\in \\mathbb{F}^m\\) 이며,\n\\[\n\\boldsymbol{A} = \\begin{bmatrix} \\boldsymbol{a}_1 & \\boldsymbol{a}_2 & \\cdots & \\boldsymbol{a}_n\\end{bmatrix}\n\\]\n이다. \\(\\boldsymbol{x} = \\begin{bmatrix}x_1 & x_2 & \\ldots & x_n\\end{bmatrix}^T\\) 이라 하면, \\(\\boldsymbol{Ax}= x_1 \\boldsymbol{a}_1 + \\cdots x_n \\boldsymbol{a}_n\\) 이다. 즉 \\(\\boldsymbol{Ax}\\) 는 \\(\\boldsymbol{a}_1,\\ldots,\\boldsymbol{a}_n\\) 에 의해 정해지는 \\(\\mathbb{F}^n\\) 의 부분공간의 한 벡터이며, \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 는 이 부분공간의 벡터 가운데 \\(\\boldsymbol{b}\\) 와 같도록 하는 계수 \\(x_1,\\ldots,\\,x_n\\) 을 찾는 것이라고 이해 할 수 있다.\n\n\\(m=n,\\, \\text{rank}(\\boldsymbol{A})=n\\) 이면 \\(\\boldsymbol{A}\\) 가 가역행렬이므로 \\(\\boldsymbol{x}\\) 의 정확한 해가 반드시 존재한다. QR 분해의 경우 \\(\\boldsymbol{R}\\) 은 대각성분이 양수인 \\(n \\times n\\) 상삼각행렬이 된다.\n\\(m&gt;n\\) 이라면 \\(\\text{rank}(\\boldsymbol{A}) \\le n&lt; m\\) 이므로 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 해가 존재하지 않을 수 있다.\n\\(m&lt;n\\) 이라면\n\n– to be continued"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/08_least_square_problem.html#하우스홀더-행렬과-qr-분해",
    "href": "src/numerical_analysis_using_julia/08_least_square_problem.html#하우스홀더-행렬과-qr-분해",
    "title": "최소자승 문제",
    "section": "",
    "text": "\\(\\mathbb{C}^{n\\times 1}\\) 에서의 벡터 \\(\\boldsymbol{v}\\) 에 대해 다음과 같이 정의된 \\(\\boldsymbol{H}_v\\) 를 하우스홀더 행렬 (Householder matrix) 이라 한다.\n\\[\n\\begin{aligned}\n\\boldsymbol{H}_{\\boldsymbol{v}} := I_n- \\dfrac{2\\boldsymbol{v}\\boldsymbol{v}^{\\ast}}{\\|\\boldsymbol{v}\\|^2}, \\qquad \\text{i. e. }\\quad\n(\\boldsymbol{H}_{\\boldsymbol{v}})_{ij} := \\delta_{ij} - \\dfrac{2 v_i \\overline{v_j}}{\\|\\boldsymbol{v}\\|^2}.\n\\end{aligned}\n\\]\n여기서 \\(\\boldsymbol{v}\\boldsymbol{v}^{\\ast}\\) 는 벡터의 내적이 아니라 \\(n\\times 1\\) 행렬 \\(\\boldsymbol{v}\\) 와 \\(1 \\times n\\) 행렬 \\(\\boldsymbol{v}^{\\ast}\\) 가 곱해진 \\(n \\times n\\) 행렬을 의미한다. 벡터 \\(\\boldsymbol{x}\\in \\mathbb{C}^n\\) 에 대해 \\(\\boldsymbol{H}_{\\boldsymbol{v}} \\boldsymbol{x}\\in \\mathbb{C}^n\\) 을 하우스홀더 변환 이라 한다. \\(\\boldsymbol{v}\\) 가 단위벡터일 경우, 즉 \\(\\|\\boldsymbol{v}\\|=1\\) 라면 좀 더 간단하게 쓸 수 있다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}} = I_n- 2\\boldsymbol{v}\\boldsymbol{v}^{\\ast},\\qquad \\text{where } \\|\\boldsymbol{v}\\|=1.\n\\]\n\n\n명제 1 위와 같이 정의된 하우스홀더 행렬 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 은 다음의 특징을 가진다.\n  (\\(1\\)) 에르미트 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}}= \\boldsymbol{H}_{\\boldsymbol{v}}^\\ast\\).\n  (\\(2\\)) 유니타리 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}} (\\boldsymbol{H}_{\\boldsymbol{v}})^\\ast = I\\).\n\n\n(증명). (\\(1\\)) \\(\\boldsymbol{v}\\) 가 단위벡터일 경우에만 보여도 된다. \\(\\boldsymbol{H} = \\boldsymbol{H}_{\\boldsymbol{v}}\\) 라 하면,\n\\[\n(\\boldsymbol{H}^\\ast)_{ij} = \\overline{H_{ji}}= \\delta_{ij}-2 \\overline{v_j \\overline{v_i}} = \\delta_{ij}-2 v_i \\overline{v_j} = (\\boldsymbol{H})_{ij}\n\\]\n이므로 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 는 에르미트 행렬이다.\n(\\(2\\)) 또한,\n\\[\n\\begin{aligned}\n\\left(\\boldsymbol{H} (\\boldsymbol{H}^\\ast)\\right)_{ij} &= \\left((\\boldsymbol{H})^2\\right)_{ij} = \\sum_{k}(\\delta_{ik}-2 v_i \\overline{v_k})(\\delta_{kj} -2 v_k \\overline{v_j}) \\\\\n&= \\sum_k \\delta_{ik}\\delta_{kj} - 2\\sum_k \\delta_{ik}v_k \\overline{v_j} - 2 \\sum_k \\delta_{kj} v_i \\overline{v_k} + 4 \\sum_{k} v_i \\overline{v_j} v_k \\overline{v_k} \\\\\n&= \\delta_{ij} - 2 v_i \\overline{v_{j}} - 2 v_i \\overline{v_j} + 4 v_i \\overline{v_j} = \\delta_{ij}\n\\end{aligned}\n\\]\n이다. \\(\\square\\)\n\n\n따라서 \\(\\mathbb{R}^n\\) 에서 생각 할 경우 하우스홀더 행렬은 대칭행렬이며, 직교행렬(orthogonal matrix) 이다.\n\n\n\n하우스 홀더 변환이 리플렉션(reflection, 반사) 라고 불린다. 수학적으로 \\(\\mathbb{R}^n\\) 공간에서 벡터 \\(\\boldsymbol{v}\\) 만으로 \\(\\boldsymbol{v}\\) 와 수직이며 원점을 지나는 평면이 유일하게 정의될 수 있다. 임의의 벡터 \\(\\boldsymbol{x} \\in \\mathbb{F}^n\\) 에 대해,\n\\[\n\\begin{aligned}\n(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x})_k &=  x_k - \\dfrac{2}{\\|\\boldsymbol{v}\\|^2}  \\sum_{j=1}^n v_k \\overline{v_j} x_j\\\\\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} &= \\boldsymbol{x} - 2 \\dfrac{\\langle \\boldsymbol{x},\\,  \\boldsymbol{v} \\rangle \\boldsymbol{v}}{\\|\\boldsymbol{v}\\|^2}\n\\end{aligned}\n\\]\n이며,\n\\[\n\\begin{aligned}\n\\dfrac{1}{2 }(\\boldsymbol{x}+\\boldsymbol{Hx}) &= \\boldsymbol{x} - \\langle \\boldsymbol{v,\\,  x}\\rangle \\boldsymbol{v} = \\boldsymbol{x} - \\text{Proj}_{\\boldsymbol{v}} \\boldsymbol{x} \\\\\n\\boldsymbol{x}-\\boldsymbol{Hx} &= 2\\langle \\boldsymbol{v ,\\, x} \\rangle  \\boldsymbol{v} = 2\\, \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\n\\end{aligned}\n\\]\n이다. 즉 \\(\\boldsymbol{x}\\) 와 \\(\\boldsymbol{Hx}\\) 는 \\(\\boldsymbol{v}\\) 에 의해 정의되는 평면에 대해 대칭이다.\n\n\n\nHouseholder 반사\n\n\n\\(\\boldsymbol{x}\\) 를 \\(\\boldsymbol{v}\\) 와 평행한 부분과 수직한 부분으로 분리하자. 즉 \\(\\boldsymbol{x}_{\\|} = \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\), \\(\\boldsymbol{x}_{\\perp} = \\boldsymbol{x}-\\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 라 하면, \\(\\boldsymbol{x} = \\boldsymbol{x}_{\\|} + \\boldsymbol{x}_{\\perp}\\) 이며 \\(\\boldsymbol{x}\\cdot \\boldsymbol{v} = \\boldsymbol{x}_{\\|}\\cdot \\boldsymbol{v}\\) 이다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x} - 2 \\boldsymbol{x}_{\\|} = \\boldsymbol{x}_{\\perp} - \\boldsymbol{x}_{\\|}\n\\]\n이다.\n\n\n\n\n\n명제 2 \\(\\mathbb{F}^m\\) 에서의 벡터 \\(\\boldsymbol{x}\\) 과 표준 기저 \\(\\{\\boldsymbol{e}_1,\\ldots,\\,\\boldsymbol{e}_m\\}\\) 를 생각하자. \\(\\alpha\\) 를 \\(\\boldsymbol{x}\\) 의 첫번째 성분 \\(x_1 = re^{i\\theta}\\) 에 대해 다음과 같이 정의한다.\n\\[\n\\alpha = \\left\\{ \\begin{array}{ll} \\|\\boldsymbol{x}\\|_2  & \\text{where } \\mathbb{F}=\\mathbb{R}, \\\\ e^{i\\theta}\\|\\boldsymbol{x}\\|_2 \\qquad & \\text{where } \\mathbb{F} =\\mathbb{C}. \\end{array} \\right.\n\\]\n\\(\\boldsymbol{x}\\) 에 대해 \\(\\boldsymbol{v}\\) 를 다음과 같이 정하자.\n\\[\n\\boldsymbol{v} = \\boldsymbol{x} - \\alpha \\boldsymbol{e}_1, \\\\\n\\]\n이 때 \\(\\boldsymbol{x}\\) 의 \\(\\boldsymbol{v}\\) 에 대한 하우스홀더 변환 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 는 다음과 같다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1.\n\\]\n\n\n(증명). \\(\\alpha \\overline{x}_1 = \\overline{\\alpha}x_1 = |x_1| \\|\\boldsymbol{x}\\|_2\\) 이며 \\(|\\alpha|^2 = \\|\\boldsymbol{x}\\|_2^2\\) 이다. \\(a=\\alpha\\overline{x}_1=\\overline{\\alpha}x_1\\) 이라 놓고 다음을 계산해 보자. \\[\n\\begin{aligned}\n\\langle \\boldsymbol{x},\\,\\boldsymbol{v}\\rangle & = \\langle \\, \\boldsymbol{x} , \\boldsymbol{x}-\\alpha \\boldsymbol{e}_1\\rangle = \\|\\boldsymbol{x}\\|_2^2-\\overline{\\alpha} x_1  = \\|\\boldsymbol{x}\\|_2^2 - a\\\\\n\\langle \\boldsymbol{v},\\,\\boldsymbol{v}\\rangle &= \\langle \\boldsymbol{x} -\\alpha \\boldsymbol{e}_1,\\, \\boldsymbol{x} -\\alpha\\boldsymbol{e}_1 \\rangle  = \\|\\boldsymbol{x}\\|^2 - \\overline{\\alpha} x_1 -\\alpha \\overline{x_1} + |\\alpha|^2 = 2(\\|\\boldsymbol{x}\\|_2^2 -a) \\\\\n&= 2 \\langle \\boldsymbol{x},\\, \\boldsymbol{v} \\rangle\n\\end{aligned}\n\\]\n이므로, (잠시 \\(\\|\\boldsymbol{x}\\|_2\\) 를 \\(\\|\\boldsymbol{x}\\|\\) 라 하자.)\n\\[\n\\boldsymbol{H}_\\boldsymbol{v} \\boldsymbol{x} = \\boldsymbol{x} - 2\\dfrac{\\langle \\boldsymbol{x},\\, \\boldsymbol{v}\\rangle}{\\|\\boldsymbol{v}\\|^2} \\boldsymbol{v} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1\n\\]\n이다. \\(\\square\\)\n\n\n이미 설명한 그람 슈미트 방법과 유사하게\n이제 \\(\\boldsymbol{Q}_1= \\boldsymbol{Q},\\, \\boldsymbol{A}=\\boldsymbol{A}_1\\) 이라 놓으면,\n\\[\n\\boldsymbol{Q}_1\\boldsymbol{A}_1 = \\begin{bmatrix}\\alpha _{1} & \\ast &\\cdots &\\ast \\\\0 & & &\\\\ \\vdots & & \\boldsymbol{A}_2 & \\\\ 0 & & & \\end{bmatrix}\n\\]\n꼴이 된다. 이제 행렬 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 번째 행까지는 상삼각 행렬의 모양을 따른다고 하자. 즉 \\(j\\le k\\) 이고 \\(i&gt;k\\) 이면 \\((\\boldsymbol{A}_k)_{ij}=0\\) 이라 하자. 이 때 \\(\\boldsymbol{A}_k\\) 의 \\(k\\) 번째 행부터 \\(m\\) 행, \\(k\\) 번째 열부터 \\(m\\) 열까지를 \\(\\boldsymbol{A}'_k\\) 라 하고,(julia 로 표현하면 Ak[k:end, k:end] 가 될 것이다) 이 \\(\\boldsymbol{A}'_k\\) 에 대해 앞서 \\(\\boldsymbol{A}\\) 에 했던 것과 똑같은 과정을 수행하는 하우스홀더 행렬을 \\(\\boldsymbol{Q}'_k\\) 라 하면 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 는 \\(\\boldsymbol{Q}_1\\boldsymbol{A}_1\\) 처럼 첫번째 열에서는 첫번째 행을 제외한 나며지 행의 값이 \\(0\\) 이 된다. 만약\n\\[\n\\boldsymbol{Q}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix}\n\\]\n이라 하면, \\((k-1)\\times (k-1)\\) 단위행렬 \\(I_{k-1}\\) 과 \\(\\boldsymbol{A}_k\\) 를 \\(k\\) 행 과 \\(k\\) 열 부터 잘라 \\(\\boldsymbol{A}_{k} = \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix}\\) 로 만들자. \\(B_k\\) 는 \\((k-1) \\times (k-1)\\) 행렬이며 \\(\\boldsymbol{A}'_{k}\\) 는 \\((m-k+1)\\times (n-k+1)\\) 행렬이다. \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 열까지 상삼각 행렬 모양이므로 \\(B_k\\) 아래는 \\(0\\) 행렬이다. 두 행렬의 곱은 \\[\n\\boldsymbol{Q}_k \\boldsymbol{A}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k' \\end{bmatrix} \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix} = \\begin{bmatrix} B_k & C_k \\\\ 0 & \\boldsymbol{Q}'_k \\boldsymbol{A'}_k \\end{bmatrix}\n\\]\n이 되고 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 의 첫번째 열은 첫번째 행을 제외하면 모두 \\(0\\) 이므로 \\(\\boldsymbol{Q}_k \\boldsymbol{A}_k\\) 는 \\(k\\) 열까지 상삼각 행렬 꼴이 된다.\n\\(L = \\min\\{m,\\,n\\}\\) 이라 하면 \\(\\boldsymbol{Q}_L \\boldsymbol{Q}_{L-1} \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A}\\) 는 상삼각행렬꼴이 된다. 이를 \\(\\boldsymbol{R}\\) 이라 하자. \\(\\boldsymbol{Q}'_k\\) 가 하우스홀더 행렬이므로\n\\[\n\\boldsymbol{Q}_k \\boldsymbol{Q}_k^\\ast = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix} \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & (\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = \\begin{bmatrix} I_{k-1} & 0 \\\\0 & \\boldsymbol{Q}_k'\n(\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = I\n\\]\n이다. 즉 \\(\\boldsymbol{Q}_k\\) 도 직교행렬이다. \\(\\boldsymbol{Q}_k\\) 가 에르미트 행렬임은 쉽게 보일 수 있다. 이제,\n\\[\n\\boldsymbol{Q}_L \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A} = \\boldsymbol{R} \\implies \\boldsymbol{A} = \\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast \\boldsymbol{R}\n\\]\n임은 쉽게 보일 수 있다. 직교행렬의 곱은 직교행렬이므로 \\(\\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast\\) 도 직교행렬이다. 따라서 QR 분해를 할 수 있다.\n\n\n\n\n\n\\(W\\) 가 내적벡터공간 \\(V\\) 의 부분공간이라 하자. 이 때 그람슈미트 과정을 통해 \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_m\\}\\) 을 구할 수 있다. 이 때 \\(\\boldsymbol{v} \\in V\\) 의 \\(W\\) 에 대한 정사영 \\(\\text{Proj}_W \\boldsymbol{v}\\) 는 다음과 같이 정의된다.\n\\[\n\\text{Proj}_W \\boldsymbol{v} = \\sum_{i=1}^m \\langle \\boldsymbol{v},\\,\\hat{\\boldsymbol{u}}_i \\rangle\\,\\hat{\\boldsymbol{u}}_i\n\\]\n\\(\\text{Proj}_W \\boldsymbol{v}\\) 는 \\(W\\) 에 속한 벡터이며, 벡터에 대한 정사영과 마찬가지로 임의의 \\(\\boldsymbol{w} \\in W\\) 에 대해\n\\[\n\\langle \\boldsymbol{w},\\,  \\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\rangle = \\boldsymbol{0}\n\\]\n이다. \\(\\boldsymbol{v} = \\text{Proj}_W \\boldsymbol{v} + (\\boldsymbol{v} - \\text{Proj}_W\\boldsymbol{v} )\\) 이므로 벡터 \\(\\boldsymbol{v}\\) 를 \\(W\\) 에 속하는 벡터와, \\(W\\) 에 직교하는 벡터로 분해 할 수 있다.\n\n내적벡터공간 \\(V\\) 의 두 벡터 \\(\\boldsymbol{v}_1,\\,\\boldsymbol{v}_2\\) 의 거리는 \\(\\|\\boldsymbol{v}_1-\\boldsymbol{v}_2\\| = \\sqrt{\\langle \\boldsymbol{v}_1-\\boldsymbol{v}_2,\\,\\boldsymbol{v}_1-\\boldsymbol{v}_2 \\rangle}\\) 로 정의된다. \\(V\\) 와 그 부분공간 \\(W\\) 를 생각하자. \\(V\\) 의 벡터 \\(\\boldsymbol{v}\\) 와 \\(W\\) 사이의 거리 \\(d(\\boldsymbol{v},\\,W)\\) 는 \\(W\\) 에 속한 벡터 가운데 \\(\\boldsymbol{v}\\) 와의 거리가 가장 작은 벡터 \\(\\boldsymbol{v}_0\\) 와의 거리로 정의된다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\min_{\\boldsymbol{w}\\in W} \\| \\boldsymbol{v} - \\boldsymbol{w}\\|\n\\]\n이다. 여기서 \\(d(\\boldsymbol{v},\\,W) = d(\\boldsymbol{v},\\, \\text{Proj}_W \\boldsymbol{v})\\) 임을 보이고자 한다. \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n\\}\\) 을 생각하자. 그리고 \\(V\\) 의 정규기저 벡터는 앞의 \\(W\\) 의 정규기저벡터를 확장하여 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n,\\,\\hat{\\boldsymbol{f}}_1,\\ldots,\\,\\hat{\\boldsymbol{f}}_m\\}\\) 라 하자. 그렇다면 \\(\\langle \\hat{\\boldsymbol{u}}_i,\\, \\hat{\\boldsymbol{f}}_j \\rangle = 0\\), \\(\\langle \\hat{\\boldsymbol{f}}_i ,\\,\\hat{\\boldsymbol{f}}_j \\rangle = \\delta_{ij}\\) 이다. 이제 이 정규기저벡터로 \\(\\boldsymbol{v}\\in V\\) 를 표현하면,\n\\[\n\\boldsymbol{v} = a_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + a_n \\hat{\\boldsymbol{u}}_n + b_1 \\hat{\\boldsymbol{f}}_1 + \\cdots + b_m \\hat{\\boldsymbol{f}}_m\n\\]\n이다. 임의의 \\(\\boldsymbol{w} = c_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + c_n \\hat{\\boldsymbol{u}}_n \\in W\\) 와 \\(\\boldsymbol{v}\\) 와의 거리의 제곱은\n\\[\n\\begin{aligned}\n\\left(d(\\boldsymbol{v},\\,\\boldsymbol{w}) \\right)^2&= (a_1-c_1)^2 + \\cdots + (a_n - c_n)^2 + b_1^2 + \\cdots + b_m^2 \\ge b_1^2 + \\cdots +b_m ^2\n\\end{aligned}\n\\]\n이므로 \\(a_1=c_1, \\cdots , a_n = c_n\\) 일 때 \\(d(\\boldsymbol{v},\\,W)\\) 가 최소값이 됨을 알 수 있다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\|\\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\|\n\\]\n이다.\n선형 시스템에서 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족시키는 해가 없지만 \\(\\|\\boldsymbol{Ax}-\\boldsymbol{b}\\|\\) 를 최소화 하는 \\(\\boldsymbol{x}\\) 를 구하고자 할 경우를 생각하자. \\(\\boldsymbol{A}\\) 가 \\(m\\times n\\) 행렬이고 \\(\\boldsymbol{x}\\in \\mathbb{F}^n,\\,\\boldsymbol{b}\\in \\mathbb{F}^m\\) 이라 하자. \\(\\boldsymbol{A}\\) 의 \\(i\\) 번째 행을 \\(\\boldsymbol{a}_i\\) 라 하면 \\(\\boldsymbol{a}_i \\in \\mathbb{F}^m\\) 이며,\n\\[\n\\boldsymbol{A} = \\begin{bmatrix} \\boldsymbol{a}_1 & \\boldsymbol{a}_2 & \\cdots & \\boldsymbol{a}_n\\end{bmatrix}\n\\]\n이다. \\(\\boldsymbol{x} = \\begin{bmatrix}x_1 & x_2 & \\ldots & x_n\\end{bmatrix}^T\\) 이라 하면, \\(\\boldsymbol{Ax}= x_1 \\boldsymbol{a}_1 + \\cdots x_n \\boldsymbol{a}_n\\) 이다. 즉 \\(\\boldsymbol{Ax}\\) 는 \\(\\boldsymbol{a}_1,\\ldots,\\boldsymbol{a}_n\\) 에 의해 정해지는 \\(\\mathbb{F}^n\\) 의 부분공간의 한 벡터이며, \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 는 이 부분공간의 벡터 가운데 \\(\\boldsymbol{b}\\) 와 같도록 하는 계수 \\(x_1,\\ldots,\\,x_n\\) 을 찾는 것이라고 이해 할 수 있다.\n\n\\(m=n,\\, \\text{rank}(\\boldsymbol{A})=n\\) 이면 \\(\\boldsymbol{A}\\) 가 가역행렬이므로 \\(\\boldsymbol{x}\\) 의 정확한 해가 반드시 존재한다. QR 분해의 경우 \\(\\boldsymbol{R}\\) 은 대각성분이 양수인 \\(n \\times n\\) 상삼각행렬이 된다.\n\\(m&gt;n\\) 이라면 \\(\\text{rank}(\\boldsymbol{A}) \\le n&lt; m\\) 이므로 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 해가 존재하지 않을 수 있다.\n\\(m&lt;n\\) 이라면\n\n– to be continued"
  },
  {
    "objectID": "src/numerical_analysis_using_julia/09_ode.html",
    "href": "src/numerical_analysis_using_julia/09_ode.html",
    "title": "상미분 방정식",
    "section": "",
    "text": "상미분 방정식은 하나의 독립변수에 대한 미분방정식이다. \\(f(x)\\) 에 대한 미분방정식이 \\(f\\) 에 대해 최대 \\(n\\) 차 미분까지 포함되었을 경우, \\(n\\)-차 상미분 방정식이라 한다.\n\n\n\n\\(y=f(x)\\) 에 대해 미분방정식이\n\\[\n\\dfrac{dy}{dx} = f(x, y)\n\\]\n로 주어지고, 초기값 \\(x_0,\\,y_0\\) 가 주어졌을 때 가장 간단하게 \\(y=f(x)\\) 를 구하는 방법이다. 테일러 전개를 이용하면,\n\\[\ny(x + h) = y(x) + y'(x)\\epsilon + \\dfrac{y''(\\xi)}{2}h^2\n\\]\n를 만족하는 \\(\\xi\\in (x,\\, x+h)\\) 이 존재한다는 것을 안다. \\(|h | \\ll 1\\) 이면,\n\\[\ny(x + h) \\approx y(x) + y'(x)h\n\\]\n임을 이용하는 것이 오일러 벙법이다.\n\\(x_{k+1}=x_k+h\\) 일 때,\n\\[\ny_{k+1} = y(x_{k+1}) = y(x_k) + f(x_k, y_k)\\, h\n\\]\n라고 하여 \\(y\\) 값을 구한다. 위의 식에서 \\(f(x,\\,y)\\) 가 \\(x\\) 만의 함수일 때 아래와 같이 julia 로 구현 할 수 있다.\nfunction ode_euler1(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        yp[i] = yp[i-1]+ f(xp[i-1]) * eps\n    end\n    return xp, yp\nend\n\\(f(x,\\,y)\\) 가 변수 2개에 대한 함수일 때는 위의 함수를 약간 수정하여 구현 할 수 있을 것이다.\n우리는 \\(y'= e^x,\\, y(0)=1\\) 일 때, \\(y=e^x\\) 임을 알고 있다. 아래 그림은 위의 ode_euler 함수를 이용하여 미분방정식을 푼 값과, 실제 함수값을 비교해 보았다.\n\n\n\n여기서는 비교작 잘 맞지만 오일러 방법은 잘 사용되지 않는다. 우선 앞서 보았듯이 테일러 전개를 이용한 근사를 사용했으므로 \\(y_{k+1}-y_k\\) 를 추산하는데 \\(\\dfrac{y''(x_k)}{2}h^2\\) 정도의 에러가 발생 할 수 있다. 또한 \\(y_{k+1}\\) 이 \\(y_k\\)에 의존하여 계산되므로 오차값이 축적된다.\n\n\n\n\n역시 \\[\n\\dfrac{dy}{dx} = f(x, y)\n\\]\n와 초기조건 \\(y_0 = f(x_0)\\) 가 주어졌다고 하자. 우리는 여기서,\n\\[\n\\dfrac{d^2y}{dx^2 } = \\dfrac{d}{dx}f(x, \\,y) = \\dfrac{\\partial f}{\\partial x} + \\dfrac{dy}{dx} \\dfrac{\\partial f}{\\partial y}\n\\]\n라는 것을 안다. 이것을 이용하여 2차항까지 테일러 전개를 하면, \\[\n\\begin{aligned}\ny(x+h) & = y(x) + \\dfrac{dy}{dx}h  + \\dfrac{1}{2}\\dfrac{d^2 y}{dx^2}h^2 + \\cdots \\\\\n&= y(x)  + f(x, y)\\, h + \\dfrac{1}{2} \\left(\\dfrac{\\partial f}{\\partial x} + \\dfrac{dy}{dx} \\dfrac{\\partial f}{\\partial y}\\right) h^2 + \\cdots \\\\\n&= y(x)  + f(x, y)\\, h + \\dfrac{1}{2} \\left(\\dfrac{\\partial f}{\\partial x} + f(x,\\,y) \\dfrac{\\partial f}{\\partial y}\\right) h^2 + \\cdots\n\\end{aligned}\n\\]\n이다. 이 때,\n\\[\n\\begin{aligned}\nk_1 &= f(x_n, y_n) \\,,\\\\\nk_2 &= f\\left( x_n + \\dfrac{h}{2},\\, y_n + h \\dfrac{k_1}{2}\\right)\n\\end{aligned}\n\\]\n라 하자. 그렇다면,\n\\[\n\\begin{aligned}\nk_2 &= f(x_n,\\, y_n) + \\dfrac{h}{2} \\dfrac{\\partial f}{\\partial x}(x_n,\\, y_n) + \\dfrac{hk_1}{2} \\dfrac{\\partial f}{\\partial y} (x_n,\\, y_n) \\\\\n&= k_1 + \\dfrac{h}{2} \\left(\\dfrac{\\partial f}{\\partial x}(x_n,\\, y_n)  + f(x_n,\\, y_n) \\dfrac{\\partial f}{\\partial y}(x_n,\\, y_n) \\right)\n\\end{aligned}\n\\]\n이므로,\n\\[\n\\begin{aligned}\n\\dfrac{\\partial f}{\\partial x}(x_n,\\, y_n) + f(x_n,\\,y_n) \\dfrac{\\partial f}{\\partial y} (x_n,\\, y_n) & = \\dfrac{2}{h}(k_2-k_1)\n\\end{aligned}\n\\]\n이다. 이를 이용하면,\n\\[\ny_{n+1} = y_n + k_1h + \\dfrac{h^2}{2} \\dfrac{2}{h} (k_2-k_1) = y_n+ \\dfrac{h}{2}(k_1+k_2)\n\\]\n이다. 이것을 2차 룽게-쿠타 방법이라 한다.\n\n\n\n\n2차 룽게 쿠타 방법은 테일러 전개의 2차항까지 사용하였다. 4차 룽게 구타 방법은 테일러 전개의 4차항까지 사용한다. \\[\ny(x+h)  = y(x) + y'(x) h + \\dfrac{y''(x)}{2} h^2 + \\dfrac{y^{(3)}(x)}{6}h^3 + \\dfrac{y^{(4)}}{24}h^4 + \\cdots\n\\]\n아래와 같이 \\(k_1,\\,k_2,\\,k_3,\\,k_4\\) 를 정의하면, \\[\n\\begin{aligned}\nk_{1} &= f(x_{n},y_{n}),\\\\\nk_{2}&=\\ f\\!\\left(x_{n}+{\\frac {h}{2}},y_{n}+h{\\frac {k_{1}}{2}}\\right),\\\\\nk_{3}&=\\ f\\!\\left(x_{n}+{\\frac {h}{2}},y_{n}+h{\\frac {k_{2}}{2}}\\right),\\\\\nk_{4}&=\\ f\\!\\left(x_{n}+h,y_{n}+hk_{3}\\right).\n\\end{aligned}\n\\]\n4차항까지의 테일러 전개가 아래와 같다는 것을 보일 수 있다. 아주 지루한 과정이므로 여기서는 생략한다. \\[\n\\begin{aligned}\ny_{n+1}&=y_{n}+{\\frac {1}{6}}\\left(k_{1}+2k_{2}+2k_{3}+k_{4}\\right)h,\\\\\nt_{n+1}&=t_{n}+h\n\\end{aligned}\n\\]\n오일러 방법, 2차 및 4차 룽게-쿠타 방법을 이용하여 상미분 방정식을 푸는 julia 코드는 아래와 같다. 모두 이변수 함수 f 와 초기값 x0, y0, 위의 \\(h\\) 에 해당하는 값 epsilon 과 초기 값을 포함하여 몇개의 점에 대해 얻을지에 대한 Npoints 를 인자로 받는다.\nfunction ode_euler(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        yp[i] = yp[i-1]+ f(xp[i-1], yp[i-1]) * eps\n    end\n    return xp, yp\nend\n\nfunction ode_runge_kutta2(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        xn, yn = xp[i-1], yp[i-1]\n        k1 = f(xn, yn)\n        k2 = f(xn + eps/2, yn + k1*eps/2)\n        yp[i] = yn + (k1+k2)*eps/2\n    end\n    return xp, yp\nend\n\nfunction ode_runge_kutta4(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        xn, yn = xp[i-1], yp[i-1]\n        k1 = f(xn, yn)\n        k2 = f(xn + eps/2, yn + eps*k1/2)\n        k3 = f(xn + eps/2, yn + eps* k2/2)\n        k4 = f(xn + eps, yn + eps*k3)\n        yp[i] = yn + (k1 + 2*k2 + 2*k3 + k4)*eps/6\n    end\n    return xp, yp\nend\n간단한 사용법은 아래와 같다.\nf1(x, y) = cos(0.1*x)*x\nx0 = 0.0\ny0 = 0.0\nxp, yp1 = ode_euler2(f1, x0, y0, 10000, 1.0e-1);\nxp, yp2 = ode_runge_kutta2(f1, x0, y0, 10000, 1.0e-1);\nxp, yp3 = ode_runge_kutta4(f1, x0, y0, 10000, 1.0e-1);\n\n\n\n\n\n\n\\[\n\\dfrac{dy}{dt} = -a y(t),\\, y(0)=y_0\n\\]\n의 해가 \\(y=y_0 e^{-at}\\) 라는 것을 알지만, 이것을 수치해석적으로 풀어보기로 하자. 오일러 방법으로도 좋은 결과를 얻을 수 있으므로 오일러 방법만을 수행하기로 한다.\nusing Plots\na=1.0\nf(x, y) = -a*y\nxp, y_newton = ode_euler((x, y)-&gt;-a*y, 0.0, 1.0, 10000, 1.0e-3)\nplot(xp, exp.(-a.*xp), label=L\"e^{-ax}\")\nplot!(xp, y_newton, label=\"Euler method\")\n이 결과는 다음과 같다.\n\n\n\n\n\n\n\\[\nm \\dfrac{d^2x}{dt^2}  =- kx\n\\] 를 단순조화진동자 문제라고 한다. 이와 같은 이차미분방정식은 \\(x_1 = x,\\, x_2 = \\dfrac{dx_1}{dt}\\) 라 놓으면\n\\[\n\\dfrac{dx_2}{dt} = -\\dfrac{k}{m}x_1,\\, \\dfrac{dx_1}{dt} = x_2\n\\]\n로 놓을 수 있다. \\(\\mathbf{x}(t) = \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\end{bmatrix}\\) 라 놓으면,\n\\[\n\\dfrac{d\\mathbf{x}}{dt}= \\begin{bmatrix} x_2 \\\\ - \\dfrac{k}{m} x_1 \\end{bmatrix}\n\\]\n이다.\n이제 오일러 방법과 룽게-쿠타 방법을 벡터에 대한 미분방정식으로 확장하자. Julia 에서 제공하는 다중 디스패치(multiple dispatch) 는 함수 이름이 같을 때 인자의 갯수와 타입에 가장 적합한 함수를 자동으로 선택하여 실행시킨다.\n벡터 \\(\\mathbf{x}\\) 에 대한 시간 미분이 \\(f(t,\\, \\mathbf{x})\\) 라 하자. 즉,\n\\[\n\\dfrac{d\\mathbf{x}}{dt} = f(t,\\,\\mathbf{x})\n\\]\nfunction ode_euler(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    N = length(x0)\n    eps = convert(T, epsilon)\n    tp = t0 .+ collect(0:1:(Npoints-1)) * eps\n    xp = zeros(T,  N, Npoints)\n    xp[:,1] = x0[:]\n    for i in 2:Npoints\n        xp[:, i] = xp[:, i-1] .+ f(tp[i-1], xp[:, i-1]) .*eps \n    end\n    return t, xp\nend\n\nfunction ode_runge_kutta2(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    N = length(x0)\n    eps = convert(T, epsilon)\n    tp = t0 .+ collect(0:1:(Npoints-1)) * eps\n    xp = zeros(T,  N, Npoints)\n    xp[:,1] = x0[:]\n    for i in 2:Npoints\n        tn, xn = tp[i-1], xp[:, i-1]\n        k1 = f(tn, xn)\n        k2 = f(tn + eps/2, xn .+ (eps/2) .* k1)\n        xp[:, i] = xn .+ (k1 .+ k2) .* (eps/2)\n    end\n    return tp, xp\nend\n\nfunction ode_runge_kutta4(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    N = length(x0)\n    eps = convert(T, epsilon)\n    tp = t0 .+ collect(0:1:(Npoints-1)) * eps\n    xp = zeros(T,  N, Npoints)\n    xp[:,1] = x0[:]\n    for i in 2:Npoints\n        tn, xn = t[i-1], xp[:, i-1]\n        k1 = f(tn, xn)\n        k2 = f(tn + eps/2, xn .+ (eps/2) .* k1)\n        k3 = f(tn + eps/2, xn .+ (eps/2) .* k2)\n        k4 = f(tn + eps, xn .+ eps.*k3)\n        xp[:, i] = xn .+ (k1 .+ 2*k2 .+ 2*k3 .+ k4).*(eps/6)\n    end\n    return tp, xp\nend\n\\(k=1.0,\\, m=1.0\\) 으로 정하여 오일러 방법과 4차 룽게-쿠타 방법을 이용하여 미분방정식을 다음과 같이 수치해석적으로 풀 수 있다.\nk = 1.0\nm = 1.0\nf_ho(t, x) = return [x[2], -k/m*x[1]]\n\nt, xp1 = ode_euler(f_ho, 0.0, [0.0 ; 1.0], 10000, 1.0e-3)\nt, xp2 = ode_runge_kutta4(f_ho, 0.0, [0.0 ; 1.0], 10000, 1.0e-3)\n그 결과를 그래프로 그리면 다음과 같다.\n\n\n\n\n\n\\[\nm \\dfrac{d^2x}{dt^2} + \\gamma \\dfrac{dx}{dt} + kx=0\n\\]\n로 기술되는 \\(x(t)\\) 를 감쇄조화진동자라 한다. 일단 방정식을 간단히 하자.\n\\[\n\\dfrac{d^2x}{dt^2} + \\dfrac{\\gamma}{m}\\dfrac{dx}{dt} + \\dfrac{k}{m} x = 0\n\\]\n\\(v=\\dot{x}\\) 라 하면 \\(\\dot{v} = -\\dfrac{\\gamma}{m}\\dfrac{dx}{dt} - \\dfrac{k}{m} x\\) 이므로,\n\\[\n\\dfrac{d}{dt} \\begin{bmatrix} x \\\\ v\\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\dfrac{\\gamma}{m}v - \\dfrac{k}{m} x\\end{bmatrix}\n\\]\n이다.\n많은 고전물리학 책에 이 감쇄조화진동자가 나와 있다. 감쇄조화진동자의 해는 다음과 같다.\n\\[\nx(t) = \\exp(-\\lambda t) \\left[ a \\exp \\left(\\sqrt{-\\omega_0^2} \\right)+ b \\exp \\left(-\\sqrt{-\\omega_0^2}\\right)\\right]\\qquad \\text{where }  \\lambda  =\\dfrac{\\gamma}{2m},\\, \\omega_0^2 = \\dfrac{k}{m}-\\dfrac{b^2}{4m^2}\n\\]\n이다. 여기서 \\(a,\\,b\\) 는 초기조건 \\(x(t=0),\\, \\dot{x}(t=0)\\) 에 의해 정해진다.\n\\(\\omega_0^2 &gt;0\\) 이면 \\(x(t)\\) 의 \\([\\,\\cdots]\\) 부분이 \\(\\cos\\) 함수 (혹은 \\(\\sin\\) 함수) 꼴로 나타날 수 있으므로 진폭이 점점 줄어드는 진동을 한다. 이를 underdamping 라 한다. $_0^2 &lt;0 $ 이면 진동 없이 감쇄만 하게 되며 이를 overdamping 라 한다. \\(\\omega_0^2 = 0\\) 일 경우를 critical damping 이라 한다.\n\\(m=1,\\, \\gamma=1,\\, k=1\\) 과 \\(x(t=0)=0,\\, \\dot{x}(t=0)=1\\) 일 때에 대해 오일러 방법, 2차 및 4차 룽게 쿠타 방법과, 해석적 해를 같이 그려보자.\n\n\n\n\n\n\n\n\n중력가속도 \\(g\\) 의 영향을 받는 길이 \\(L\\)인 진자의 운동은 다음의 미분방정식으로 기술된다.\n\\[\n\\dfrac{d^2 \\theta}{dt^2} = -\\dfrac{g}{L} \\sin \\theta\n\\]\n보통 \\(\\theta\\) 가 아주 작을 때 \\(\\sin \\theta \\approx \\theta\\) 로 가정하여 풀면\n\\[\n\\dfrac{d^2\\theta}{dt^2}= -\\left( \\dfrac{g}{L} \\right)\\theta\n\\]\n이므로 단순조화진동자 문제이다.\n이제 수치적으로 풀어보자. \\(\\phi= \\dfrac{d\\theta}{dt}\\), \\(\\mathbf{x} = \\begin{bmatrix} \\theta \\\\ \\phi \\end{bmatrix}\\) 라 하면,\n\\[\n\\dfrac{d}{dt}\\begin{bmatrix} \\theta \\\\ \\phi \\end{bmatrix} = \\begin{bmatrix} \\phi \\\\ -g/L \\sin \\theta  \\end{bmatrix}\n\\]\n가 된다. \\(g=1.0,\\, L=2.0\\) 으로 잡고 시간 간격을 \\(1\\times 10^{-2}\\) 간격으로 미분방정식을 3가지 방법으로 풀면\ng = 1\nL = 2.0\nNp = 10000\nepsilon = 1.0e-2\nθ0, ϕ0 = 0.0, 1.0\n\nf_pendulum(t, x) = return [x[2], -g/L*sin(x[1])]\nt, xp1 = ode_euler(f_pendulum, 0.0, [ θ0 ; ϕ0], Np, epsilon)\nt, xp2 = ode_runge_kutta2(f_pendulum, 0.0, [θ0 ; ϕ0], Np, epsilon)\nt, xp3 = ode_runge_kutta4(f_pendulum, 0.0, [θ0 ; ϕ0], Np, epsilon)\n\nplot(t, xp1[1, :], label = \"Euler\", frame = :box, loc=:topcenter)\nplot!(t, xp2[1, :], xlabel = \"t\", label = \"RK2\")\nplot!(t, xp3[1, :], xlabel = \"t\", label = \"RK4\")\n\n\n\n와 같다. 여기서는 세 방법이 시간이 지날수록 큰 차이를 보인다. 그러나 시간간격을 앞서보다 1/10 으로 줄여서 풀어 그리면 차이가 앞서보다 많이 주는 것을 볼 수 있다.\n\n\n\n\n\n\n\n이번 장에서는 상미분 방정식을 푸는 가장 기본적인 방법인 오일러 방법과 2차, 4차 룽게-쿠타 방법을 배웠다. 수치해석이 늘 그렇듯이 간단한 미분방정식은 잘 풀 수 있지만 다양하고 복잡한 문제에서는 더 정확한 방법을 사용해야 한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/09_ode.html#상미분-방정식-ordinary-differential-equations",
    "href": "src/numerical_analysis_using_julia/09_ode.html#상미분-방정식-ordinary-differential-equations",
    "title": "상미분 방정식",
    "section": "",
    "text": "상미분 방정식은 하나의 독립변수에 대한 미분방정식이다. \\(f(x)\\) 에 대한 미분방정식이 \\(f\\) 에 대해 최대 \\(n\\) 차 미분까지 포함되었을 경우, \\(n\\)-차 상미분 방정식이라 한다.\n\n\n\n\\(y=f(x)\\) 에 대해 미분방정식이\n\\[\n\\dfrac{dy}{dx} = f(x, y)\n\\]\n로 주어지고, 초기값 \\(x_0,\\,y_0\\) 가 주어졌을 때 가장 간단하게 \\(y=f(x)\\) 를 구하는 방법이다. 테일러 전개를 이용하면,\n\\[\ny(x + h) = y(x) + y'(x)\\epsilon + \\dfrac{y''(\\xi)}{2}h^2\n\\]\n를 만족하는 \\(\\xi\\in (x,\\, x+h)\\) 이 존재한다는 것을 안다. \\(|h | \\ll 1\\) 이면,\n\\[\ny(x + h) \\approx y(x) + y'(x)h\n\\]\n임을 이용하는 것이 오일러 벙법이다.\n\\(x_{k+1}=x_k+h\\) 일 때,\n\\[\ny_{k+1} = y(x_{k+1}) = y(x_k) + f(x_k, y_k)\\, h\n\\]\n라고 하여 \\(y\\) 값을 구한다. 위의 식에서 \\(f(x,\\,y)\\) 가 \\(x\\) 만의 함수일 때 아래와 같이 julia 로 구현 할 수 있다.\nfunction ode_euler1(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        yp[i] = yp[i-1]+ f(xp[i-1]) * eps\n    end\n    return xp, yp\nend\n\\(f(x,\\,y)\\) 가 변수 2개에 대한 함수일 때는 위의 함수를 약간 수정하여 구현 할 수 있을 것이다.\n우리는 \\(y'= e^x,\\, y(0)=1\\) 일 때, \\(y=e^x\\) 임을 알고 있다. 아래 그림은 위의 ode_euler 함수를 이용하여 미분방정식을 푼 값과, 실제 함수값을 비교해 보았다.\n\n\n\n여기서는 비교작 잘 맞지만 오일러 방법은 잘 사용되지 않는다. 우선 앞서 보았듯이 테일러 전개를 이용한 근사를 사용했으므로 \\(y_{k+1}-y_k\\) 를 추산하는데 \\(\\dfrac{y''(x_k)}{2}h^2\\) 정도의 에러가 발생 할 수 있다. 또한 \\(y_{k+1}\\) 이 \\(y_k\\)에 의존하여 계산되므로 오차값이 축적된다.\n\n\n\n\n역시 \\[\n\\dfrac{dy}{dx} = f(x, y)\n\\]\n와 초기조건 \\(y_0 = f(x_0)\\) 가 주어졌다고 하자. 우리는 여기서,\n\\[\n\\dfrac{d^2y}{dx^2 } = \\dfrac{d}{dx}f(x, \\,y) = \\dfrac{\\partial f}{\\partial x} + \\dfrac{dy}{dx} \\dfrac{\\partial f}{\\partial y}\n\\]\n라는 것을 안다. 이것을 이용하여 2차항까지 테일러 전개를 하면, \\[\n\\begin{aligned}\ny(x+h) & = y(x) + \\dfrac{dy}{dx}h  + \\dfrac{1}{2}\\dfrac{d^2 y}{dx^2}h^2 + \\cdots \\\\\n&= y(x)  + f(x, y)\\, h + \\dfrac{1}{2} \\left(\\dfrac{\\partial f}{\\partial x} + \\dfrac{dy}{dx} \\dfrac{\\partial f}{\\partial y}\\right) h^2 + \\cdots \\\\\n&= y(x)  + f(x, y)\\, h + \\dfrac{1}{2} \\left(\\dfrac{\\partial f}{\\partial x} + f(x,\\,y) \\dfrac{\\partial f}{\\partial y}\\right) h^2 + \\cdots\n\\end{aligned}\n\\]\n이다. 이 때,\n\\[\n\\begin{aligned}\nk_1 &= f(x_n, y_n) \\,,\\\\\nk_2 &= f\\left( x_n + \\dfrac{h}{2},\\, y_n + h \\dfrac{k_1}{2}\\right)\n\\end{aligned}\n\\]\n라 하자. 그렇다면,\n\\[\n\\begin{aligned}\nk_2 &= f(x_n,\\, y_n) + \\dfrac{h}{2} \\dfrac{\\partial f}{\\partial x}(x_n,\\, y_n) + \\dfrac{hk_1}{2} \\dfrac{\\partial f}{\\partial y} (x_n,\\, y_n) \\\\\n&= k_1 + \\dfrac{h}{2} \\left(\\dfrac{\\partial f}{\\partial x}(x_n,\\, y_n)  + f(x_n,\\, y_n) \\dfrac{\\partial f}{\\partial y}(x_n,\\, y_n) \\right)\n\\end{aligned}\n\\]\n이므로,\n\\[\n\\begin{aligned}\n\\dfrac{\\partial f}{\\partial x}(x_n,\\, y_n) + f(x_n,\\,y_n) \\dfrac{\\partial f}{\\partial y} (x_n,\\, y_n) & = \\dfrac{2}{h}(k_2-k_1)\n\\end{aligned}\n\\]\n이다. 이를 이용하면,\n\\[\ny_{n+1} = y_n + k_1h + \\dfrac{h^2}{2} \\dfrac{2}{h} (k_2-k_1) = y_n+ \\dfrac{h}{2}(k_1+k_2)\n\\]\n이다. 이것을 2차 룽게-쿠타 방법이라 한다.\n\n\n\n\n2차 룽게 쿠타 방법은 테일러 전개의 2차항까지 사용하였다. 4차 룽게 구타 방법은 테일러 전개의 4차항까지 사용한다. \\[\ny(x+h)  = y(x) + y'(x) h + \\dfrac{y''(x)}{2} h^2 + \\dfrac{y^{(3)}(x)}{6}h^3 + \\dfrac{y^{(4)}}{24}h^4 + \\cdots\n\\]\n아래와 같이 \\(k_1,\\,k_2,\\,k_3,\\,k_4\\) 를 정의하면, \\[\n\\begin{aligned}\nk_{1} &= f(x_{n},y_{n}),\\\\\nk_{2}&=\\ f\\!\\left(x_{n}+{\\frac {h}{2}},y_{n}+h{\\frac {k_{1}}{2}}\\right),\\\\\nk_{3}&=\\ f\\!\\left(x_{n}+{\\frac {h}{2}},y_{n}+h{\\frac {k_{2}}{2}}\\right),\\\\\nk_{4}&=\\ f\\!\\left(x_{n}+h,y_{n}+hk_{3}\\right).\n\\end{aligned}\n\\]\n4차항까지의 테일러 전개가 아래와 같다는 것을 보일 수 있다. 아주 지루한 과정이므로 여기서는 생략한다. \\[\n\\begin{aligned}\ny_{n+1}&=y_{n}+{\\frac {1}{6}}\\left(k_{1}+2k_{2}+2k_{3}+k_{4}\\right)h,\\\\\nt_{n+1}&=t_{n}+h\n\\end{aligned}\n\\]\n오일러 방법, 2차 및 4차 룽게-쿠타 방법을 이용하여 상미분 방정식을 푸는 julia 코드는 아래와 같다. 모두 이변수 함수 f 와 초기값 x0, y0, 위의 \\(h\\) 에 해당하는 값 epsilon 과 초기 값을 포함하여 몇개의 점에 대해 얻을지에 대한 Npoints 를 인자로 받는다.\nfunction ode_euler(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        yp[i] = yp[i-1]+ f(xp[i-1], yp[i-1]) * eps\n    end\n    return xp, yp\nend\n\nfunction ode_runge_kutta2(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        xn, yn = xp[i-1], yp[i-1]\n        k1 = f(xn, yn)\n        k2 = f(xn + eps/2, yn + k1*eps/2)\n        yp[i] = yn + (k1+k2)*eps/2\n    end\n    return xp, yp\nend\n\nfunction ode_runge_kutta4(f::Function, x0::T, y0::T, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    eps = convert(T, epsilon)\n    xp = x0 .+ collect(0:1:(Npoints-1)) * eps\n    yp = zeros(T, length(xp))\n    yp[1] = y0\n    for i in 2:Npoints\n        xn, yn = xp[i-1], yp[i-1]\n        k1 = f(xn, yn)\n        k2 = f(xn + eps/2, yn + eps*k1/2)\n        k3 = f(xn + eps/2, yn + eps* k2/2)\n        k4 = f(xn + eps, yn + eps*k3)\n        yp[i] = yn + (k1 + 2*k2 + 2*k3 + k4)*eps/6\n    end\n    return xp, yp\nend\n간단한 사용법은 아래와 같다.\nf1(x, y) = cos(0.1*x)*x\nx0 = 0.0\ny0 = 0.0\nxp, yp1 = ode_euler2(f1, x0, y0, 10000, 1.0e-1);\nxp, yp2 = ode_runge_kutta2(f1, x0, y0, 10000, 1.0e-1);\nxp, yp3 = ode_runge_kutta4(f1, x0, y0, 10000, 1.0e-1);\n\n\n\n\n\n\n\\[\n\\dfrac{dy}{dt} = -a y(t),\\, y(0)=y_0\n\\]\n의 해가 \\(y=y_0 e^{-at}\\) 라는 것을 알지만, 이것을 수치해석적으로 풀어보기로 하자. 오일러 방법으로도 좋은 결과를 얻을 수 있으므로 오일러 방법만을 수행하기로 한다.\nusing Plots\na=1.0\nf(x, y) = -a*y\nxp, y_newton = ode_euler((x, y)-&gt;-a*y, 0.0, 1.0, 10000, 1.0e-3)\nplot(xp, exp.(-a.*xp), label=L\"e^{-ax}\")\nplot!(xp, y_newton, label=\"Euler method\")\n이 결과는 다음과 같다.\n\n\n\n\n\n\n\\[\nm \\dfrac{d^2x}{dt^2}  =- kx\n\\] 를 단순조화진동자 문제라고 한다. 이와 같은 이차미분방정식은 \\(x_1 = x,\\, x_2 = \\dfrac{dx_1}{dt}\\) 라 놓으면\n\\[\n\\dfrac{dx_2}{dt} = -\\dfrac{k}{m}x_1,\\, \\dfrac{dx_1}{dt} = x_2\n\\]\n로 놓을 수 있다. \\(\\mathbf{x}(t) = \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\end{bmatrix}\\) 라 놓으면,\n\\[\n\\dfrac{d\\mathbf{x}}{dt}= \\begin{bmatrix} x_2 \\\\ - \\dfrac{k}{m} x_1 \\end{bmatrix}\n\\]\n이다.\n이제 오일러 방법과 룽게-쿠타 방법을 벡터에 대한 미분방정식으로 확장하자. Julia 에서 제공하는 다중 디스패치(multiple dispatch) 는 함수 이름이 같을 때 인자의 갯수와 타입에 가장 적합한 함수를 자동으로 선택하여 실행시킨다.\n벡터 \\(\\mathbf{x}\\) 에 대한 시간 미분이 \\(f(t,\\, \\mathbf{x})\\) 라 하자. 즉,\n\\[\n\\dfrac{d\\mathbf{x}}{dt} = f(t,\\,\\mathbf{x})\n\\]\nfunction ode_euler(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    N = length(x0)\n    eps = convert(T, epsilon)\n    tp = t0 .+ collect(0:1:(Npoints-1)) * eps\n    xp = zeros(T,  N, Npoints)\n    xp[:,1] = x0[:]\n    for i in 2:Npoints\n        xp[:, i] = xp[:, i-1] .+ f(tp[i-1], xp[:, i-1]) .*eps \n    end\n    return t, xp\nend\n\nfunction ode_runge_kutta2(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    N = length(x0)\n    eps = convert(T, epsilon)\n    tp = t0 .+ collect(0:1:(Npoints-1)) * eps\n    xp = zeros(T,  N, Npoints)\n    xp[:,1] = x0[:]\n    for i in 2:Npoints\n        tn, xn = tp[i-1], xp[:, i-1]\n        k1 = f(tn, xn)\n        k2 = f(tn + eps/2, xn .+ (eps/2) .* k1)\n        xp[:, i] = xn .+ (k1 .+ k2) .* (eps/2)\n    end\n    return tp, xp\nend\n\nfunction ode_runge_kutta4(f::Function, t0::T, x0::Vector{T}, Npoints::Integer, epsilon = 1.0e-6) where T&lt;:AbstractFloat\n    N = length(x0)\n    eps = convert(T, epsilon)\n    tp = t0 .+ collect(0:1:(Npoints-1)) * eps\n    xp = zeros(T,  N, Npoints)\n    xp[:,1] = x0[:]\n    for i in 2:Npoints\n        tn, xn = t[i-1], xp[:, i-1]\n        k1 = f(tn, xn)\n        k2 = f(tn + eps/2, xn .+ (eps/2) .* k1)\n        k3 = f(tn + eps/2, xn .+ (eps/2) .* k2)\n        k4 = f(tn + eps, xn .+ eps.*k3)\n        xp[:, i] = xn .+ (k1 .+ 2*k2 .+ 2*k3 .+ k4).*(eps/6)\n    end\n    return tp, xp\nend\n\\(k=1.0,\\, m=1.0\\) 으로 정하여 오일러 방법과 4차 룽게-쿠타 방법을 이용하여 미분방정식을 다음과 같이 수치해석적으로 풀 수 있다.\nk = 1.0\nm = 1.0\nf_ho(t, x) = return [x[2], -k/m*x[1]]\n\nt, xp1 = ode_euler(f_ho, 0.0, [0.0 ; 1.0], 10000, 1.0e-3)\nt, xp2 = ode_runge_kutta4(f_ho, 0.0, [0.0 ; 1.0], 10000, 1.0e-3)\n그 결과를 그래프로 그리면 다음과 같다.\n\n\n\n\n\n\\[\nm \\dfrac{d^2x}{dt^2} + \\gamma \\dfrac{dx}{dt} + kx=0\n\\]\n로 기술되는 \\(x(t)\\) 를 감쇄조화진동자라 한다. 일단 방정식을 간단히 하자.\n\\[\n\\dfrac{d^2x}{dt^2} + \\dfrac{\\gamma}{m}\\dfrac{dx}{dt} + \\dfrac{k}{m} x = 0\n\\]\n\\(v=\\dot{x}\\) 라 하면 \\(\\dot{v} = -\\dfrac{\\gamma}{m}\\dfrac{dx}{dt} - \\dfrac{k}{m} x\\) 이므로,\n\\[\n\\dfrac{d}{dt} \\begin{bmatrix} x \\\\ v\\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\dfrac{\\gamma}{m}v - \\dfrac{k}{m} x\\end{bmatrix}\n\\]\n이다.\n많은 고전물리학 책에 이 감쇄조화진동자가 나와 있다. 감쇄조화진동자의 해는 다음과 같다.\n\\[\nx(t) = \\exp(-\\lambda t) \\left[ a \\exp \\left(\\sqrt{-\\omega_0^2} \\right)+ b \\exp \\left(-\\sqrt{-\\omega_0^2}\\right)\\right]\\qquad \\text{where }  \\lambda  =\\dfrac{\\gamma}{2m},\\, \\omega_0^2 = \\dfrac{k}{m}-\\dfrac{b^2}{4m^2}\n\\]\n이다. 여기서 \\(a,\\,b\\) 는 초기조건 \\(x(t=0),\\, \\dot{x}(t=0)\\) 에 의해 정해진다.\n\\(\\omega_0^2 &gt;0\\) 이면 \\(x(t)\\) 의 \\([\\,\\cdots]\\) 부분이 \\(\\cos\\) 함수 (혹은 \\(\\sin\\) 함수) 꼴로 나타날 수 있으므로 진폭이 점점 줄어드는 진동을 한다. 이를 underdamping 라 한다. $_0^2 &lt;0 $ 이면 진동 없이 감쇄만 하게 되며 이를 overdamping 라 한다. \\(\\omega_0^2 = 0\\) 일 경우를 critical damping 이라 한다.\n\\(m=1,\\, \\gamma=1,\\, k=1\\) 과 \\(x(t=0)=0,\\, \\dot{x}(t=0)=1\\) 일 때에 대해 오일러 방법, 2차 및 4차 룽게 쿠타 방법과, 해석적 해를 같이 그려보자.\n\n\n\n\n\n\n\n\n중력가속도 \\(g\\) 의 영향을 받는 길이 \\(L\\)인 진자의 운동은 다음의 미분방정식으로 기술된다.\n\\[\n\\dfrac{d^2 \\theta}{dt^2} = -\\dfrac{g}{L} \\sin \\theta\n\\]\n보통 \\(\\theta\\) 가 아주 작을 때 \\(\\sin \\theta \\approx \\theta\\) 로 가정하여 풀면\n\\[\n\\dfrac{d^2\\theta}{dt^2}= -\\left( \\dfrac{g}{L} \\right)\\theta\n\\]\n이므로 단순조화진동자 문제이다.\n이제 수치적으로 풀어보자. \\(\\phi= \\dfrac{d\\theta}{dt}\\), \\(\\mathbf{x} = \\begin{bmatrix} \\theta \\\\ \\phi \\end{bmatrix}\\) 라 하면,\n\\[\n\\dfrac{d}{dt}\\begin{bmatrix} \\theta \\\\ \\phi \\end{bmatrix} = \\begin{bmatrix} \\phi \\\\ -g/L \\sin \\theta  \\end{bmatrix}\n\\]\n가 된다. \\(g=1.0,\\, L=2.0\\) 으로 잡고 시간 간격을 \\(1\\times 10^{-2}\\) 간격으로 미분방정식을 3가지 방법으로 풀면\ng = 1\nL = 2.0\nNp = 10000\nepsilon = 1.0e-2\nθ0, ϕ0 = 0.0, 1.0\n\nf_pendulum(t, x) = return [x[2], -g/L*sin(x[1])]\nt, xp1 = ode_euler(f_pendulum, 0.0, [ θ0 ; ϕ0], Np, epsilon)\nt, xp2 = ode_runge_kutta2(f_pendulum, 0.0, [θ0 ; ϕ0], Np, epsilon)\nt, xp3 = ode_runge_kutta4(f_pendulum, 0.0, [θ0 ; ϕ0], Np, epsilon)\n\nplot(t, xp1[1, :], label = \"Euler\", frame = :box, loc=:topcenter)\nplot!(t, xp2[1, :], xlabel = \"t\", label = \"RK2\")\nplot!(t, xp3[1, :], xlabel = \"t\", label = \"RK4\")\n\n\n\n와 같다. 여기서는 세 방법이 시간이 지날수록 큰 차이를 보인다. 그러나 시간간격을 앞서보다 1/10 으로 줄여서 풀어 그리면 차이가 앞서보다 많이 주는 것을 볼 수 있다.\n\n\n\n\n\n\n\n이번 장에서는 상미분 방정식을 푸는 가장 기본적인 방법인 오일러 방법과 2차, 4차 룽게-쿠타 방법을 배웠다. 수치해석이 늘 그렇듯이 간단한 미분방정식은 잘 풀 수 있지만 다양하고 복잡한 문제에서는 더 정확한 방법을 사용해야 한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A01_appendix_01.html",
    "href": "src/numerical_analysis_using_julia/A01_appendix_01.html",
    "title": "부록",
    "section": "",
    "text": "명제 1 (Young’s Inequality) \\(a\\ge 0,\\, b\\ge 0, p&gt;1,\\, q&gt;1\\) 이며 \\(1/p+1/q=1\\) 일 때 다음이 성립한다.\n\\[\nab \\le \\dfrac{a^p}{p} + \\dfrac{b^q}{q}.\n\\]\n등호는 \\(a^p=b^q\\) 일 때 성립한다.\n\n\n(증명). 우선 \\(p&gt;1,\\,q&gt;1\\) 에 대해 다음이 성립한다. \\[\n\\int_0^a x^{p-1}\\, dx + \\int_0^b y^{q-1}\\, dy = \\dfrac{a^p}{p} + \\dfrac{b^q}{q}\n\\]\n\\(\\dfrac{1}{p}+ \\dfrac{1}{q}\\) 로부터 \\(p-1 = \\dfrac{1}{q-1}\\) 임을 안다. 따라서, \\(y=x^{p-1}\\) 이면 \\(x=y^{q-1}\\) 이다. 이제 \\(\\displaystyle \\int_0^a x^{p-1}\\, dx + \\int_0^b y^{q-1}\\, dy\\) 를 생각하자. 아래 그림을 생각하면, 위의 적분이 \\(ab\\) 보다 항상 크다는 것을 알 수 있다. \\(\\square\\)\n\n\n\n\nPlots for Young’s inequality\n\n\n\n\n명제 2 (Hölder’s inequality and Minkowski ineqality) \\(p\\ge 1\\) 이며 \\(1/p+1/q =1\\) 일 때 다음이 성립한다. \\[\n\\begin{aligned}\n\\text{H\\\"older's inequality} : & \\sum_{i=1}^n |u_i v_i| \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}, \\\\\n\\text{Mincowski inequality}  : & \\left(\\sum_{i=1}^n |u_i+v_i|^p\\right)^{1/p} \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}.\n\\end{aligned}\n\\]\n\n\n(증명). 우선 횔더 부등식을 보이자. 영의 부등식 \\(ab &lt; \\dfrac{a^p}{p}+ \\dfrac{b^q}{q}\\) 를 이용한다. \\(\\boldsymbol{u},\\,\\boldsymbol{v}\\in \\mathbb{F}^n\\) 에 대해 \\(\\displaystyle \\|\\boldsymbol{u}\\|_p = \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p},\\, \\|\\boldsymbol{v}\\|_q = \\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}\\) 라 하자. \\(a_i,\\,b_i\\) 를 각각\n\\[\na_i = \\dfrac{|u_i|}{\\|\\boldsymbol{u}\\|_p},\\, \\qquad b_i = \\dfrac{|v_i|}{\\|\\boldsymbol{v}\\|_q}\n\\]\n라 하면, 영의 부등식에 의해\n\\[\na_i b_i = \\dfrac{|u_iv_i|}{\\|\\boldsymbol{u}\\|_p \\|\\boldsymbol{v}\\|_q} \\le \\dfrac{|u_i|^p}{p (\\|\\boldsymbol{u}\\|_p)^p} +  \\dfrac{|v_i|^p}{q(\\|\\boldsymbol{v}\\|_q)^q}\n\\]\n이며,\n\\[\n\\sum_{i=1}^n a_ib_i = \\dfrac{\\sum_{i=1}^n |u_i v_i|}{\\|\\boldsymbol{u}\\|_p \\|\\boldsymbol{v}\\|_q} \\le \\dfrac{\\sum_{i=1}^n|u_i|^p}{p (\\|\\boldsymbol{u}\\|_p)^p} +  \\dfrac{\\sum_{i=1}^n |v_i|^p}{q(\\|\\boldsymbol{v}\\|_q)^q}  =  \\dfrac{1}{p} + \\dfrac{1}{q} = 1\n\\]\n이므로,\n\\[\n\\sum_{i=1}^n |u_i v_i| \\le \\|\\boldsymbol{u}\\|_p \\| \\boldsymbol{v}\\|_q = \\left( \\sum_{i=1}^n |u_i|^p)^{1/p} \\right)^{1/p} \\left( \\sum_{i=1}^n |v_i|^q)^{1/q} \\right)^{1/q}\n\\]\n이다.\n이제 민코프스키 부등식을 보이자. \\(p&gt;1\\) 이므로 삼각부등식에 의해 다음이 성립한다.\n\\[\n|u_i+v_i|^p = |u_i + v_i| |u_i + v_i|^{p-1} \\le (|u_i|+|v_i|)|u_i + v_i|^{p-1} = |u_i||u_i+v_i|^{p-1} + |v_i||u_i+v_i|^{p-1}\n\\]\nHölder’s inequality 에 의해,\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n |u_i| |u_i + v_i|^{p-1} &\\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |u_i+v_i|^{q(p-1)}\\right)^{1/q}, \\\\\n\\sum_{i=1}^n |v_i| |u_i + v_i|^{p-1} &\\le \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |u_i+v_i|^{q(p-1)}\\right)^{1/q},\n\\end{aligned}\n\\]\n\\(1/p + 1/q=1\\) 로부터 \\(q(p-1)=p\\) 임을 안다. 따라서,\n\\[\n\\sum_{i=1}^n (|u_i|+|v_i|) |u_i+v_i|^{p-1} \\le \\left[\\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p}\\right]\\left(\\sum_{i=1}^n |u_i+v_i|^{p}\\right)^{1/q}\n\\]\n이므로,\n\\[\n\\begin{aligned}\n\\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p} &\\ge \\dfrac{\\displaystyle\\sum_{i=1}^n (|u_i|+|v_i|) |u_i+v_i|^{p-1}}{\\left(\\displaystyle \\sum_{i=1}^n |u_i+v_i|^{p}\\right)^{1/q}} \\ge \\dfrac{\\displaystyle \\sum_{i=1}^n |u_i + v_i|^p}{\\left(\\displaystyle \\sum_{i=1}^n |u_i+v_i|^{p}\\right)^{1/q}}, \\\\\n& = \\left(\\sum_{i=1}^n |u_i + v_i|^p\\right)^{1-1/q} = \\left(\\sum_{i=1}^n |u_i + v_i|^p\\right)^{1/p}\n\\end{aligned}\n\\]\n이다. 따라서 민코프스키 부등식이 성립한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A01_appendix_01.html#sec-mathematical_proof",
    "href": "src/numerical_analysis_using_julia/A01_appendix_01.html#sec-mathematical_proof",
    "title": "부록",
    "section": "",
    "text": "명제 1 (Young’s Inequality) \\(a\\ge 0,\\, b\\ge 0, p&gt;1,\\, q&gt;1\\) 이며 \\(1/p+1/q=1\\) 일 때 다음이 성립한다.\n\\[\nab \\le \\dfrac{a^p}{p} + \\dfrac{b^q}{q}.\n\\]\n등호는 \\(a^p=b^q\\) 일 때 성립한다.\n\n\n(증명). 우선 \\(p&gt;1,\\,q&gt;1\\) 에 대해 다음이 성립한다. \\[\n\\int_0^a x^{p-1}\\, dx + \\int_0^b y^{q-1}\\, dy = \\dfrac{a^p}{p} + \\dfrac{b^q}{q}\n\\]\n\\(\\dfrac{1}{p}+ \\dfrac{1}{q}\\) 로부터 \\(p-1 = \\dfrac{1}{q-1}\\) 임을 안다. 따라서, \\(y=x^{p-1}\\) 이면 \\(x=y^{q-1}\\) 이다. 이제 \\(\\displaystyle \\int_0^a x^{p-1}\\, dx + \\int_0^b y^{q-1}\\, dy\\) 를 생각하자. 아래 그림을 생각하면, 위의 적분이 \\(ab\\) 보다 항상 크다는 것을 알 수 있다. \\(\\square\\)\n\n\n\n\nPlots for Young’s inequality\n\n\n\n\n명제 2 (Hölder’s inequality and Minkowski ineqality) \\(p\\ge 1\\) 이며 \\(1/p+1/q =1\\) 일 때 다음이 성립한다. \\[\n\\begin{aligned}\n\\text{H\\\"older's inequality} : & \\sum_{i=1}^n |u_i v_i| \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}, \\\\\n\\text{Mincowski inequality}  : & \\left(\\sum_{i=1}^n |u_i+v_i|^p\\right)^{1/p} \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}.\n\\end{aligned}\n\\]\n\n\n(증명). 우선 횔더 부등식을 보이자. 영의 부등식 \\(ab &lt; \\dfrac{a^p}{p}+ \\dfrac{b^q}{q}\\) 를 이용한다. \\(\\boldsymbol{u},\\,\\boldsymbol{v}\\in \\mathbb{F}^n\\) 에 대해 \\(\\displaystyle \\|\\boldsymbol{u}\\|_p = \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p},\\, \\|\\boldsymbol{v}\\|_q = \\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}\\) 라 하자. \\(a_i,\\,b_i\\) 를 각각\n\\[\na_i = \\dfrac{|u_i|}{\\|\\boldsymbol{u}\\|_p},\\, \\qquad b_i = \\dfrac{|v_i|}{\\|\\boldsymbol{v}\\|_q}\n\\]\n라 하면, 영의 부등식에 의해\n\\[\na_i b_i = \\dfrac{|u_iv_i|}{\\|\\boldsymbol{u}\\|_p \\|\\boldsymbol{v}\\|_q} \\le \\dfrac{|u_i|^p}{p (\\|\\boldsymbol{u}\\|_p)^p} +  \\dfrac{|v_i|^p}{q(\\|\\boldsymbol{v}\\|_q)^q}\n\\]\n이며,\n\\[\n\\sum_{i=1}^n a_ib_i = \\dfrac{\\sum_{i=1}^n |u_i v_i|}{\\|\\boldsymbol{u}\\|_p \\|\\boldsymbol{v}\\|_q} \\le \\dfrac{\\sum_{i=1}^n|u_i|^p}{p (\\|\\boldsymbol{u}\\|_p)^p} +  \\dfrac{\\sum_{i=1}^n |v_i|^p}{q(\\|\\boldsymbol{v}\\|_q)^q}  =  \\dfrac{1}{p} + \\dfrac{1}{q} = 1\n\\]\n이므로,\n\\[\n\\sum_{i=1}^n |u_i v_i| \\le \\|\\boldsymbol{u}\\|_p \\| \\boldsymbol{v}\\|_q = \\left( \\sum_{i=1}^n |u_i|^p)^{1/p} \\right)^{1/p} \\left( \\sum_{i=1}^n |v_i|^q)^{1/q} \\right)^{1/q}\n\\]\n이다.\n이제 민코프스키 부등식을 보이자. \\(p&gt;1\\) 이므로 삼각부등식에 의해 다음이 성립한다.\n\\[\n|u_i+v_i|^p = |u_i + v_i| |u_i + v_i|^{p-1} \\le (|u_i|+|v_i|)|u_i + v_i|^{p-1} = |u_i||u_i+v_i|^{p-1} + |v_i||u_i+v_i|^{p-1}\n\\]\nHölder’s inequality 에 의해,\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n |u_i| |u_i + v_i|^{p-1} &\\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |u_i+v_i|^{q(p-1)}\\right)^{1/q}, \\\\\n\\sum_{i=1}^n |v_i| |u_i + v_i|^{p-1} &\\le \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |u_i+v_i|^{q(p-1)}\\right)^{1/q},\n\\end{aligned}\n\\]\n\\(1/p + 1/q=1\\) 로부터 \\(q(p-1)=p\\) 임을 안다. 따라서,\n\\[\n\\sum_{i=1}^n (|u_i|+|v_i|) |u_i+v_i|^{p-1} \\le \\left[\\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p}\\right]\\left(\\sum_{i=1}^n |u_i+v_i|^{p}\\right)^{1/q}\n\\]\n이므로,\n\\[\n\\begin{aligned}\n\\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p} &\\ge \\dfrac{\\displaystyle\\sum_{i=1}^n (|u_i|+|v_i|) |u_i+v_i|^{p-1}}{\\left(\\displaystyle \\sum_{i=1}^n |u_i+v_i|^{p}\\right)^{1/q}} \\ge \\dfrac{\\displaystyle \\sum_{i=1}^n |u_i + v_i|^p}{\\left(\\displaystyle \\sum_{i=1}^n |u_i+v_i|^{p}\\right)^{1/q}}, \\\\\n& = \\left(\\sum_{i=1}^n |u_i + v_i|^p\\right)^{1-1/q} = \\left(\\sum_{i=1}^n |u_i + v_i|^p\\right)^{1/p}\n\\end{aligned}\n\\]\n이다. 따라서 민코프스키 부등식이 성립한다."
  },
  {
    "objectID": "src/numerical_analysis_using_julia/index.html",
    "href": "src/numerical_analysis_using_julia/index.html",
    "title": "Numerical Analysis Using Julia",
    "section": "",
    "text": "Numerical Analysis Using Julia"
  },
  {
    "objectID": "src/tools/Asymptote/asymptote.html",
    "href": "src/tools/Asymptote/asymptote.html",
    "title": "Asymptote",
    "section": "",
    "text": "1 Examples\nimport graph;\nimport geometry;\nimport math;\nimport settings;\nimport fontsize;\n\n\nsettings.outformat = \"pdf\";\ndefaultpen(fontsize(17pt));\ndefaultpen(1);\n\nsize(400,300,IgnoreAspect);\n\nreal a=1, b=1.5, c=2;\nreal ya=1.0, yb=2.4, yc=3.0;\nreal yb2=2.6, yb3=2.2;\nint t=2;\n\nreal f(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\nreal f2(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb2;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\nreal f3(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb3;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\npair F(real x) {return (x,f(x));}\n\ndotfactor=7;\n\nxaxis(\"$t$\", xmin=0.5, xmax=2.5, Arrow, ticks=Ticks(DefaultFormat,\n                                        new real[] {1, 2}));\nyaxis(\"$P$\", XEquals(0.7), ymin=-0.2, ymax=4, Arrow);\n\npath g=graph(f,a,c);\npath g2=graph(f2,a,c);\npath g3=graph(f3,a,c);\n\ndraw(g,black);   \ndraw(g2,blue+dashed);  \ndraw(g3,dashed+red);  \n\nint n=2;\n\n\n\ndot(Label(\"$P_1$\",align=W), F(a));\ndot(Label(\"$P_2$\",align=E), F(c));\n\n\n\nEuler Lagrange"
  }
]